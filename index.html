<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneshell.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ToT">
<meta property="og:type" content="website">
<meta property="og:title" content="OneShell">
<meta property="og:url" content="https://oneshell.top/index.html">
<meta property="og:site_name" content="OneShell">
<meta property="og:description" content="ToT">
<meta property="og:locale">
<meta property="article:author" content="OneShell">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://oneshell.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>OneShell</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OneShell</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I fight for a brighter tomorrow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">FirmAE：网络仿真配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-19 05:59:18" itemprop="dateCreated datePublished" datetime="2023-04-19T05:59:18+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-20 11:25:53" itemprop="dateModified" datetime="2023-04-20T11:25:53+08:00">2023-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/FirmAE/" itemprop="url" rel="index"><span itemprop="name">FirmAE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在run.sh中，FirmAE会检查当前固件是否在之前仿真成功过，如果是第一次仿真或者是之前仿真失败，FirmAE会重新开始创建镜像、生成qemu启动网络配置的工作；如果之前已经仿真成功了，则直接执行之前的启动命令。</p>
<h2 id="run-sh：是否之前仿真成功"><a href="#run-sh：是否之前仿真成功" class="headerlink" title="run.sh：是否之前仿真成功"></a>run.sh：是否之前仿真成功</h2><p>如下是关键代码，其中<code>$&#123;WORK_DIR&#125;</code>目录是工作目录，对应着实际的目录<code>scratch/固件编号/</code>目录。<code>$&#123;WORK_DIR&#125;/web</code>是web仿真成功的标志文件，FirmAE仿真成功一个目录则会在其中写入<code>true</code>。<code>./scripts/makeImage.sh</code>是创建qemu镜像、将文件系统写入到镜像、并对文件系统做修改的脚本；<code>./scripts/makeNetwork.py</code>则是负责生成qemu运行命令、配置qemu启动命令的参数，也是这篇文章将要简单说明的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">if (! egrep -sqi &quot;true&quot; $&#123;WORK_DIR&#125;/web); then</span><br><span class="line">    # ================================</span><br><span class="line">    # make qemu image</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 查询数据库</span><br><span class="line">    ./scripts/tar2db.py -i $IID -f ./images/$IID.tar.gz -h $PSQL_IP \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/tar2db.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_tar=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_tar &gt; $&#123;WORK_DIR&#125;/time_tar</span><br><span class="line"></span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 制作qemu镜像</span><br><span class="line">    ./scripts/makeImage.sh $IID $ARCH $FILENAME \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/makeImage.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_image=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_image &gt; $&#123;WORK_DIR&#125;/time_image</span><br><span class="line"></span><br><span class="line">    # ================================</span><br><span class="line">    # infer network interface</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    echo &quot;[*] infer network start!!!&quot;</span><br><span class="line">    # TIMEOUT is set in &quot;firmae.config&quot;. This TIMEOUT is used for initial</span><br><span class="line">    # log collection.</span><br><span class="line">    TIMEOUT=$TIMEOUT FIRMAE_NET=$&#123;FIRMAE_NET&#125; \</span><br><span class="line">      ./scripts/makeNetwork.py -i $IID -q -o -a $&#123;ARCH&#125; \</span><br><span class="line">      &amp;&gt; $&#123;WORK_DIR&#125;/makeNetwork.log</span><br><span class="line">    # run_debug.sh等实际上都是./run.sh的软连接</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_debug.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_analyze.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_boot.sh | true</span><br><span class="line"></span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_network=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_network &gt; $&#123;WORK_DIR&#125;/time_network</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果之前仿真成功过则直接仿真</span></span><br><span class="line">    echo &quot;[*] $&#123;INFILE&#125; already succeed emulation!!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="makeNetwork-py：生成最终的qemu启动命令"><a href="#makeNetwork-py：生成最终的qemu启动命令" class="headerlink" title="makeNetwork.py：生成最终的qemu启动命令"></a>makeNetwork.py：生成最终的qemu启动命令</h2><p><code>makeNetwork.py</code>是进行网络处理的python脚本，里面大概包含了首次通过命令启动qemu虚拟机、然后分析qemu虚拟机的启动日志、生成新的启动参数、通过新的qemu命令再次启动虚拟机，并检查虚拟机的web服务器启动状况。</p>
<p><code>makeNetwork.py</code>中调用的关键函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">  -&gt; process</span><br><span class="line">    -&gt; inferNetwork</span><br><span class="line">    -&gt; checkNetwork</span><br></pre></td></tr></table></figure>
<h3 id="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"><a href="#inferNetwork函数：首次启动QEMU虚拟机并分析启动日志" class="headerlink" title="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"></a>inferNetwork函数：首次启动QEMU虚拟机并分析启动日志</h3><h4 id="1-首次启动虚拟机"><a href="#1-首次启动虚拟机" class="headerlink" title="1. 首次启动虚拟机"></a>1. 首次启动虚拟机</h4><p><code>inferNetwork</code>函数会重新挂载qemu磁盘，获取磁盘文件系统中的一些启动服务，在文件系统中修改<code>preInit.sh</code>脚本，并生成QEMU启动命令。QEMU启动命令会增加<code>rdinit=/firmadyne/preInit.sh</code>参数，使得虚拟机启动后会首先去执行该脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Running firmware %d: terminating after %d secs...&quot;</span> % (iid, TIMEOUT))</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;timeout --preserve-status --signal SIGINT &#123;0&#125; &quot;</span>.<span class="built_in">format</span>(TIMEOUT)</span><br><span class="line">cmd += <span class="string">&quot;&#123;0&#125;/run.&#123;1&#125;.sh \&quot;&#123;2&#125;\&quot; \&quot;&#123;3&#125;\&quot; &quot;</span>.<span class="built_in">format</span>(SCRIPTDIR,</span><br><span class="line">                                                arch + endianness,</span><br><span class="line">                                                iid,</span><br><span class="line">                                                qemuInitValue)</span><br><span class="line">cmd += <span class="string">&quot; 2&gt;&amp;1 &gt; /dev/null&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(iid) + <span class="string">&quot;/qemu.init.cmd&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(cmd)</span><br><span class="line"><span class="comment"># 首次执行虚拟机，设置了时间上的延迟，因此这个地方的时间是必须等待的</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<p>首次执行的qemu虚拟机启动命令如下，这次仿真所消耗的时间就是6分钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout --preserve-status --signal SIGINT 240 /home/utest/app/FirmAE/scripts/run.mipseb.sh &quot;3&quot; &quot;rdinit=/firmadyne/preInit.sh&quot;  2&gt;&amp;1 &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>我从一个已经启动的虚拟机中查看脚本内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/firmadyne/sh</span></span><br><span class="line"></span><br><span class="line">BUSYBOX=/firmadyne/busybox</span><br><span class="line"></span><br><span class="line">[ -d /dev ] || <span class="built_in">mkdir</span> -p /dev</span><br><span class="line">[ -d /root ] || <span class="built_in">mkdir</span> -p /root</span><br><span class="line">[ -d /sys ] || <span class="built_in">mkdir</span> -p /sys</span><br><span class="line">[ -d /proc ] || <span class="built_in">mkdir</span> -p /proc</span><br><span class="line">[ -d /tmp ] || <span class="built_in">mkdir</span> -p /tmp</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lock</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t sysfs sysfs /sys</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t proc proc /proc</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> <span class="built_in">ln</span> -sf /proc/mounts /etc/mtab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t tmpfs tmpfs /run</span><br><span class="line"></span><br><span class="line">/sbin/init &amp;</span><br><span class="line"></span><br><span class="line">/firmadyne/network.sh &amp;</span><br><span class="line">/firmadyne/run_service.sh &amp;</span><br><span class="line">/firmadyne/debug.sh</span><br><span class="line">/firmadyne/busybox <span class="built_in">sleep</span> 36000</span><br></pre></td></tr></table></figure>

<p>可以看到脚本会创建一些必备的目录以提高仿真生成率（来自FirmAE论文，有数据证实），并挂载一些设备。然后执行文件系统中的<code>/sbin/init</code>，这个或许在真实设备中是首次执行的程序。最后会运行内置的一些脚本，启动<code>debug.sh</code>是FirmAE较FirmAdyne所没有的。还有一个sleep命令，应该是为了等待启动成功。</p>
<h4 id="2-分析启动日志"><a href="#2-分析启动日志" class="headerlink" title="2. 分析启动日志"></a>2. 分析启动日志</h4><p>虚拟机首次执行是有时间限制的，时间到后关闭虚拟机。随后<code>inferNetwork</code>函数会分析qemu启动日志，从中得到例如开放端口、IP、MAC地址改变等信息，然后返回。FirmAE的内核源码是被修改过的，对一些关键系统调用做了hook，因此是可以在qemu启动日志中得到许多信息。这些信息随后会辅助生成最终的qemu启动命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始分析qemu虚拟机首次启动的日志</span></span><br><span class="line">data = <span class="built_in">open</span>(<span class="string">&quot;%s/qemu.initial.serial.log&quot;</span> % targetDir, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找开放端口</span></span><br><span class="line">ports = findPorts(data, endianness)</span><br><span class="line"></span><br><span class="line"><span class="comment">#find interfaces with non loopback ip addresses</span></span><br><span class="line">ifacesWithIps = findNonLoInterfaces(data, endianness)</span><br><span class="line"><span class="comment">#find changes of mac addresses for devices</span></span><br><span class="line"><span class="comment"># 寻找MAC地址的变化</span></span><br><span class="line">macChanges = findMacChanges(data, endianness)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[*] Interfaces: %r&#x27;</span> % ifacesWithIps)</span><br><span class="line"></span><br><span class="line">networkList = getNetworkList(data, ifacesWithIps, macChanges)</span><br><span class="line"><span class="keyword">return</span> qemuInitValue, networkList, targetFile, targetData, ports</span><br></pre></td></tr></table></figure>

<h3 id="checkNetwork函数"><a href="#checkNetwork函数" class="headerlink" title="checkNetwork函数"></a>checkNetwork函数</h3><p>继续返回到<code>process</code>函数中，接下来会调用<code>checkNetwork</code>函数。该函数的主要功能是从<code>inferNetwork</code>函数提取的日志信息<code>networkList</code>中分析虚拟机的网络类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vlanNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has vlan ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = vlanNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> ethNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = ethNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidEthNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidEthNetworkList:</span><br><span class="line">        filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;reload&quot;</span></span><br><span class="line"><span class="keyword">elif</span> brNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> brNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((ip, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidBrNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidBrNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridgereload&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="test-emulation-sh：第二次启动虚拟机并分析网络仿真结果"><a href="#test-emulation-sh：第二次启动虚拟机并分析网络仿真结果" class="headerlink" title="test_emulation.sh：第二次启动虚拟机并分析网络仿真结果"></a>test_emulation.sh：第二次启动虚拟机并分析网络仿真结果</h3><p>通过首次仿真的结果，我们可以得到一系列的信息，例如网络列表、端口等等。这些信息将用于生成最终的qemu启动命令。如下还是<code>process</code>函数中，根据首次仿真的日志得到一些关键信息，用于生成最后的仿真命令<code>qemuCommandLine</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">qemuCommandLine = qemuCmd(iid,</span><br><span class="line">                          filterNetworkList,</span><br><span class="line">                          ports,</span><br><span class="line">                          network_type,</span><br><span class="line">                          arch,</span><br><span class="line">                          endianness,</span><br><span class="line">                          qemuInitValue,</span><br><span class="line">                          isUserNetwork)</span><br><span class="line"><span class="comment"># 重新生成了QEMU命令</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(outfile, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(qemuCommandLine)</span><br><span class="line">os.chmod(outfile, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;./scripts/test_emulation.sh &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iid, arch + endianness))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (os.path.exists(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">    <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>).read().strip() == <span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    success = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>随后调用<code>test_emulation.sh</code>去执行这条仿真命令，该虚拟机启动命令在后台执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;[*] test emulator&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;WORK_DIR&#125;/run.sh 2&gt;&amp;1 &gt;<span class="variable">$&#123;WORK_DIR&#125;</span>/emulation.log &amp;</span></span><br><span class="line"></span><br><span class="line">sleep 10</span><br></pre></td></tr></table></figure>

<p>脚本还会调用<code>check_network</code>函数检查虚拟机的网络仿真状态，主要是通过ping和访问web服务端口来判断：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;[*] Waiting web service... from $&#123;IPS[@]&#125;&quot;</span><br><span class="line">read IP PING_RESULT WEB_RESULT TIME_PING TIME_WEB &lt; &lt;(check_network &quot;$&#123;IPS[@]&#125;&quot; false)</span><br><span class="line"></span><br><span class="line">if ($&#123;PING_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/ping</span><br><span class="line">    echo $&#123;TIME_PING&#125; &gt; $&#123;WORK_DIR&#125;/time_ping</span><br><span class="line">    echo $&#123;IP&#125; &gt; $&#123;WORK_DIR&#125;/ip</span><br><span class="line">fi</span><br><span class="line">if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/web</span><br><span class="line">    echo $&#123;TIME_WEB&#125; &gt; $&#123;WORK_DIR&#125;/time_web</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>check_network</code>函数的代码如下，循环通过ping判断虚拟机是否存活，以及通过curl判断WEB服务是否启动起来，然后写入到固件工作目录的状态文件：<code>$&#123;WORK_DIR&#125;/ping</code>和<code>$&#123;WORK_DIR&#125;/web</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">check_network () &#123;</span><br><span class="line">    sleep 10</span><br><span class="line"></span><br><span class="line">    IPS=(&quot;$&#123;@&#125;&quot;)</span><br><span class="line">    DEBUG_MODE=$&#123;IPS[-1]&#125;</span><br><span class="line">    unset &#x27;IPS[$&#123;#IPS[@]&#125;-1]&#x27;</span><br><span class="line"></span><br><span class="line">    PING_RESULT=false</span><br><span class="line">    PING_TIME=-1</span><br><span class="line">    WEB_RESULT=false</span><br><span class="line">    WEB_TIME=-1</span><br><span class="line">    RET_IP=&quot;None&quot;</span><br><span class="line"></span><br><span class="line">    START_TIME=$(date +%s | bc)</span><br><span class="line">    CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">    t_start=$(date +%s.%N)</span><br><span class="line">    while [ $&#123;CURRENT_TIME&#125; -le $[$&#123;START_TIME&#125; + $&#123;CHECK_TIMEOUT&#125;] ]</span><br><span class="line">    do</span><br><span class="line">        for IP in &quot;$&#123;IPS[@]&#125;&quot;</span><br><span class="line">        do</span><br><span class="line">            if (curl --max-time 2 --output /dev/null --silent http://$&#123;IP&#125; || curl --max-time 2 --output /dev/null --silent https://$&#123;IP&#125;); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;WEB_RESULT&#125;); then</span><br><span class="line">                    WEB_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$&#123;WEB_TIME&#125;</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                WEB_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            if (ping -c 1 $&#123;IP&#125; &gt; /dev/null); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            sleep 1</span><br><span class="line">            CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$&#123;RET_IP&#125;&quot; &quot;$&#123;PING_RESULT&#125;&quot; &quot;$&#123;WEB_RESULT&#125;&quot; &quot;$&#123;PING_TIME&#125;&quot; &quot;$&#123;WEB_TIME&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，关键脚本<code>makeNetwork.py</code>分析完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以前在看FirmAE论文的时候，论文中强调仿真采用了启发式的分析方法，其实这个启发式主要就是对固件的文件系统和网络进行分析，然后进行相应的patch。</p>
<p>对于文件系统，FirmAE会分析其中的web服务、服务程序中所需的文件和文件夹和设备、然后生成脚本在启动时创建相应的文件和文件夹，挂载相应的设备。对于网络配置，FirmAE会在分析阶段启动两次qemu虚拟机。第一次是为了获取到网络配置信息，然后生成新的qemu启动命令；第二次是为了判断虚拟机是否被启动、web服务是否被启动。</p>
<p>综合来说，FirmAE的时间消耗大头是在网络配置上，要是不顺利的话，第一次网络启动会默认消耗6分钟、第二次也会消耗6分钟。而且，FirmAE真正启动还会再执行一次qemu虚拟机的启动，也就是说，从固件到仿真成功，一共需要执行三次qemu虚拟机。</p>
<p>出于个人需求，FirmAE对我来说在判断逻辑上还可以改改。例如有时候WEB服务着实启动条件比较苛刻，需要对WEB程序进行patch，这种场景下我们实际上只想让FirmAE快速搭建起来一个qemu虚拟机，在网络判定的时候ping能够ping通就行，web服务可以自己连接到虚拟机上去手动启动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20date/" class="post-title-link" itemprop="url">[afl-training] date</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:23:03 / Modified: 10:26:29" itemprop="dateCreated datePublished" datetime="2023-04-13T10:23:03+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-date"><a href="#afl-training-date" class="headerlink" title="[afl-training] date"></a>[afl-training] date</h1><p>date 的这个漏洞也是使用 AFL 发现的。通过查看 date 的 man 手册，可以看到 date 可以从命令行、日期相关系统调用、环境变量和一些文件中读取输入。此次 challenge 是如何对一个程序的环境变量进行 fuzz，个人还是比较重视这个 challenge，因为我的毕业设计是打算对 IoT 固件中的 CGI 程序进行模糊测试，而 CGI 程序大多是从环境变量以及标准输入 STDIN 中获取数据，然后处理完毕后通过标准输出 STDOUT 输出，做完这个 challenge 应该就可以开始进行毕业设计的总体实现了。</p>
<h2 id="编译-date"><a href="#编译-date" class="headerlink" title="编译 date"></a>编译 date</h2><p>首先对 date 的源码进行编译，和之前的 challenge 类似，需要使用 afl-clang-fast 以及开启 AFL_USE_ASAN&#x3D;1 编译选项。</p>
<p>进入 challenge 中的 date 目录，下载源码，并编译时必要的依赖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">sudo apt install autopoint bison gperf autoconf texinfo</span><br></pre></td></tr></table></figure>

<p>编译 date</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd coreutils</span><br><span class="line">./bootstrap</span><br><span class="line">patch --follow-symlinks -p1 &lt; ../coreutils-8.29-gnulib-fflush.patch</span><br><span class="line">CC=afl-clang-fast ./configure # 如果是root用户编译加上FORCE_UNSAFE_CONFIGURE=1选项</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure>

<p>运行编译出来的带有 bug 的 date 程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./src/date</span><br><span class="line">TZ=&#x27;Asia/Tokyo&#x27; ./src/date # 加上环境变量TZ</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102333584.png" alt="undifined"></p>
<p>目前是已知 TZ 环境变量存在 bug，那么运行 poc，ASAN 报错发生堆溢出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TZ=&quot;aaa00000000000000000000aaaaaab00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102348762.png" alt="undifined"></p>
<h2 id="harness"><a href="#harness" class="headerlink" title="harness"></a>harness</h2><p>那么问题就是如何对环境变量进行 fuzz。在每一个 challenge 中都有一个 HINT.md 文档，作为对当前挑战的提示。对于如何 fuzz 环境变量，HINT.md 提出了三个方案：</p>
<ol>
<li>在源码中找到所有读取环境变量 TZ 的地方，然后替换为从 STDIN 中读取</li>
<li>修改 main 函数，在运行之初就设置 TZ 环境变量从 STDIN 中读取</li>
<li>使用 LD_PRELOAD 环境变量对 getenv 函数进行劫持，这样就可以通过标准输入传递到环境变量的值</li>
</ol>
<p>在 ANSWERS.md 中，推荐使用的是第二个方案，因为第一个方案需要对代码中每一个读取环境变量的地方进行修改，很难确定每个地方都替换了为了 STDIN；第三个方案虽然重用性比较高，但是对于入门而言，需要花费的功夫还是比较多的。我在毕设中应该会使用到第三种方案，因为这样可以最大限度不对 CGI 的程序做出修改。</p>
<p>使用第二个方案的一个原因也是，date.c 代码中，只有一个使用到了 getenv(“TZ”)，那么在 main 函数运行之初，就提前设定好 TZ 环境变量从 STDIN 中读取，从而实现 fuzz 环境变量的值从标准输入中读取。在 main 函数中增加如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> val[<span class="number">1024</span> * <span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>, val, <span class="keyword">sizeof</span>(val) - <span class="number">1</span>);</span><br><span class="line">setenv(<span class="string">&quot;TZ&quot;</span>, val, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102403450.png" alt="undifined"></p>
<p>然后重新编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>然后重新运行程序，可以看到每次 date 运行前都要从标准输入先获取 TZ 环境变量，修改成功</p>
<p><img src="/images/image-2023-0413-102417721.png" alt="undifined"></p>
<h2 id="开始-fuzz"><a href="#开始-fuzz" class="headerlink" title="开始 fuzz"></a>开始 fuzz</h2><p>设置初始种子，可以就用上面的 Europe&#x2F;London 作为初始种子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input </span><br><span class="line">echo &quot;Europe/London&quot; &gt;&gt; ./input/london</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102428963.png" alt="undifined"></p>
<p>fuzz 前需要注意，在教程中使用的是固定日期，并且如果使用 ASAN，需要设置内存限定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i ./input -o output -- ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102443656.png" alt="undifined"></p>
<p>运行了 1 个小时，玩了一会儿游戏，一共挖出 30k 个 crash，但是只有 3 个 unique crashes。</p>
<p>将 crash 传入到 date 运行，ASAN 报错如下：</p>
<p><img src="/images/image-2023-0413-102456866.png" alt="undifined"></p>
<p>的确是发生了溢出</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[PCB Blog] AFL Fuzzing with ASAN</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[安全客] AFL-training 学习记录</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20harness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20harness/" class="post-title-link" itemprop="url">[afl-training] harness</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:15:53 / Modified: 10:26:41" itemprop="dateCreated datePublished" datetime="2023-04-13T10:15:53+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-harness"><a href="#afl-training-harness" class="headerlink" title="[afl-training] harness"></a>[afl-training] harness</h1><p>harness 的名词含义是马具，动词含义是给马套上马具，引申为利用，治理。此处的意思或许应该理解为，如何写好一个 harness（马具）来使用 AFL。</p>
<p>之前在做 quickstart 的时候，没有使用 afl-clang-fast 进行编译，而是使用的 afl-clang，刚刚搜到 afl-clang-fast 的话，需要编译 llvm-mode。</p>
<p>此次的章节是讲的如何写 harness 让 AFL 测试代码片段。如果对 AFL 如何将数据发送到目标程序执行比较熟悉的话，可以跳过这一个章节，直接到 challenge 进行实战，如下的图描述了 AFL 的基本流程和模块间的关系。</p>
<ul>
<li>input：input 文件夹存放初始的种子，高质量的种子文件非常重要</li>
<li>queue：从 queue 中读取内容作为程序输入，如果突变后的输入可以触发新的状态变化，将变异后的输入重新放入 queue 中</li>
<li>crash：crash 存放触发 crashes 的输入</li>
</ul>
<p><img src="/images/overview.svg" alt="undifined"></p>
<p>在 library.h 的这个库中，主要的功能是提供输入数据并计算得到输出。假如要测试如下的代码，该如何进行测试？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lib_echo</span><span class="params">(<span class="type">char</span> *data, <span class="type">ssize_t</span> len)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(data) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">	<span class="built_in">strncpy</span>(buf, data, len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A crash so we can tell the harness is working for lib_echo</span></span><br><span class="line">	<span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(data[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[<span class="number">2</span>] ==<span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(data[<span class="number">3</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">					assert(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">lib_mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> y &lt;&lt; x;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt;&lt; y;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzz-库的单输入函数"><a href="#fuzz-库的单输入函数" class="headerlink" title="fuzz 库的单输入函数"></a>fuzz 库的单输入函数</h2><p>fuzz 需要的准备工作有以下三点：</p>
<ol>
<li>代码是可以正常运行的</li>
<li>需要插桩，来让 AFL 进行高效运行</li>
<li>需要将 fuzzer 生成的数据送入到测试库中，因此，我们必须写一个程序将外部输入送入到测试库中，这可以直接从文件中读取或者从标准输入中读取。</li>
</ol>
<p>为了测试 library.h 库中的函数，那么额外写一个文件 harness.c，其中 main 函数来调用库中的函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;Some input data\n&quot;</span>;</span><br><span class="line">    lib_echo(data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令进行编译，可以看到一共在 20 个地方进行了插桩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101641422.png" alt="undifined"></p>
<p>创建 input 文件夹，并在其中提供初始化的种子文件，如果就按照上面编译的方式直接 afl-fuzz，会发现 AFL 提示报错：odd, check syntax!</p>
<p><img src="/images/image-2023-0413-101654342.png" alt="undifined"></p>
<p>在 harness 可执行文件中，调用了 library.h 库中的函数，但是没有设置 hook 使得 AFL 变异产生的数据输入到目标库函数中，因此，运行 afl-fuzz 就会抛出一个警告，没有发生任何的事！因此，我们需要修改 harness 代码，使其从标准输入 STDIN 中获取输入，并且将输入数据喂给目标函数，将 harness.c 修改如下：</p>
<p>新增了 read 函数从标准输入 STDIN 中读取数据到缓冲区 input 中，然后喂给 lib_echo 函数运行，也就是对 lib_echo 函数进行 fuzz：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    <span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> length;</span><br><span class="line">    length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    lib_echo(input, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新使用 afl-clang-fast 插桩，再使用 afl-fuzz 运行，现在就可以正常被 fuzz 了，并且产生了 crashes。明确一点，AFL 产生的输入是直接通过标准输入 STDIN 传递。</p>
<p><img src="/images/image-2023-0413-101711061.png" alt="undifined"></p>
<h2 id="fuzz-库的任意输入函数"><a href="#fuzz-库的任意输入函数" class="headerlink" title="fuzz 库的任意输入函数"></a>fuzz 库的任意输入函数</h2><p>如果要测试 lib_mul(int x, int y) 函数，这个函数需要两个输入，而且是两个数字。作者提供的 harness 如下，通过两个 read 函数从 STDIN 标准输入中来传递数据到 harness 可执行文件中。代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    	<span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    	lib_echo(input, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;mul&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a,b = <span class="number">0</span>;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, <span class="number">4</span>);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(a,b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s mul|echo\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新使用 afl-clang-fast 编译，使用 afl-fuzz 进行 fuzz，但是这个时候需要带参数 mul 运行 harness，并且还需要在初始输入提供一个高质量：两个回车（或者 &#x2F;0）分隔的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br><span class="line">afl-fuzz -i in -o out ./harness mul</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101726958.png" alt="undifined"></p>
<p>应该是 fuzz 不出来什么结果了，因为 lib_mul 函数内部是数字运算，触发不了什么异常。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>作者留下了一个练习，如果有一个程序是从 argv 读取文件名，然后读取文件内容到缓冲区，并且将缓冲区传递到目标函数中，那么该如何对这个程序进行 fuzz。</p>
<p>这个部分我没有理解到，是要使用 AFL 构建文件内容然后进行 fuzz 么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[[afl-training]%20libxml2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5B%5Bafl-training%5D%20libxml2/" class="post-title-link" itemprop="url">[[afl-training] libxml2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:08:58 / Modified: 10:26:16" itemprop="dateCreated datePublished" datetime="2023-04-13T10:08:58+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-libxml2"><a href="#afl-training-libxml2" class="headerlink" title="[afl-training] libxml2"></a>[afl-training] libxml2</h1><p>libxml2 是一个流行的 XML 库，这类库是非常适合用来做 fuzzing ，理由如下：</p>
<ul>
<li>经常需要解析用户提供的数据</li>
<li>库是由不安全语言编写（例如 C、C++）</li>
<li>无状态</li>
<li>没有网络和文件系统交互</li>
<li>官方提供的 API 就是很好的 fuzz 目标，无需额外去分析和识别库内部的组件关系</li>
<li>运行速度快</li>
</ul>
<p>这次 fuzz 挑战的目标是在库中寻找 CVE-2015-8317，需要使用 AFL 对库源代码进行编译插桩，并且加上 ASAN 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">cd libxml2</span><br><span class="line">CC=afl-clang-fast ./autogen.sh</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>使用 AFL_USE_ASAN&#x3D;1 是开启 ASAN 辅助，这是基于 clang 的一个内存错误检测器，可以检测到常见的内存漏洞，例如栈溢出、堆溢出、double free、uaf 等等。</p>
<h2 id="编写-harness"><a href="#编写-harness" class="headerlink" title="编写 harness"></a>编写 harness</h2><p>在之前的 harness 章节就讲到，fuzz 一个库的基本流程是：</p>
<ol>
<li>对库使用 AFL 进行编译插桩</li>
<li>通过相关的官方文档知道库中的 API 是如何被正常调用的</li>
<li>写一个类似的 harness 调用 API，使得 AFL 产生的输入可以喂给 API 执行，并编译插桩 harness</li>
<li>使用 afl-fuzz 对 harness 进行 fuzz</li>
</ol>
<p>我们已经使用 afl-clang-fast 编译了 libxml2 库，那么接下来就是去官方文档中查看正常情况下正确调用库 API 的案例，libxml2 的官方文档在<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/index.html">此处</a>，在 fuzz 的时候可以参考此<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/parse1.c">案例</a>，对库的 xmlReadMemory 函数进行 fuzz。如下是官方提供的 API 调用案例，读取 XML 文件到树上，并释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * section: Parsing</span></span><br><span class="line"><span class="comment"> * synopsis: Parse an XML file to a tree and free it</span></span><br><span class="line"><span class="comment"> * purpose: Demonstrate the use of xmlReadFile() to read an XML file</span></span><br><span class="line"><span class="comment"> *          into a tree and xmlFreeDoc() to free the resulting tree</span></span><br><span class="line"><span class="comment"> * usage: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * test: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * author: Daniel Veillard</span></span><br><span class="line"><span class="comment"> * copy: see Copyright for the status of this software.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * example1Func:</span></span><br><span class="line"><span class="comment"> * @filename: a filename or an URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse the resource and free the resulting tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">example1Func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    xmlDocPtr doc; <span class="comment">/* the resulting document tree */</span></span><br><span class="line"></span><br><span class="line">    doc = xmlReadFile(filename, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse %s\n&quot;</span>, filename);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlFreeDoc(doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this initialize the library and check potential ABI mismatches</span></span><br><span class="line"><span class="comment">     * between the version it was compiled for and the actual shared</span></span><br><span class="line"><span class="comment">     * library used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LIBXML_TEST_VERSION</span><br><span class="line"></span><br><span class="line">    <span class="title function_">example1Func</span><span class="params">(argv[<span class="number">1</span>])</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cleanup function for the XML library.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlCleanupParser();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this is to debug memory for regression tests</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlMemoryDump();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们可以根据上面的案例写出一个 harness，这个在挑战的 ANSWERS.md 中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlInitParser();</span><br><span class="line">    <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">        xmlDocPtr doc = xmlReadFile(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (doc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            xmlFreeDoc(doc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完 harness.c 后插桩编译，-I 选项是指定包含的头文件目录，然后接上 libxml2 的静态链接库，-lz 是使用 zlib 库，-lm 是使用 math 库，然后编译出来的是一个将 libxml2 静态链接的可执行文件，这样在编译插桩的时候就可以直接对 libxml2 的汇编代码进行插桩（如果之前已经对 libxml2 进行了插桩编译，应该就不需要再静态编译了）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I libxml2/include libxml2/.libs/libxml2.a -lz -lm -o fuzzer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101002978.png" alt="undifined"></p>
<p>编写完 harness 后，就需要使用高质量的种子来启动 afl-fuzz，afl 的源码中提供了一个不错的 XML 字典，可以就使用它来作为初始种子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">echo &quot;&lt;hi&gt;&lt;/hi&gt;&quot; &gt; inout/hi.xml</span><br></pre></td></tr></table></figure>

<p>然后开始 fuzz，-x 是设定 fuzzer 的字典，@@ 类似于占位符，表示输入的位置，因为 harness 使用的是 argv 作为输入。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out -x ~/Code/AFL/dictionaries/xml.dict ./fuzzer @@</span><br></pre></td></tr></table></figure>

<p>然后让 AFL 在后台运行吧，等待结果，用虚拟机跑了一天，挖出来 16 个 crashes</p>
<p><img src="/images/image-2023-0413-101017775.png" alt="undifined"></p>
<h2 id="处理-crashes"><a href="#处理-crashes" class="headerlink" title="处理 crashes"></a>处理 crashes</h2><p>我们写出来的 harness 是通过命令参数读取文件，那么直接将 output&#x2F;crashes 中的文件给程序，就会报错。而且因为编译的时候使用了  ASAN 标志，会有详细的报错信息提醒。跑出来的 16 个 unique creashes 都是相同的报错：</p>
<p><img src="/images/image-2023-0413-101035360.png" alt="undifined"></p>
<p>通过上图中的函数堆栈回溯，我们可以定位错误的性质是一个字节的堆溢出，而且漏洞是发生在 libxml2&#x2F;parse.c 文件中。个人对堆了解得不是很深入，就在这个地方吧，埋一个坑，以后有空更新。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254167">[安全客] AFL-Training学习记录</a> </li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7400">[先知] 使用AFL挖掘libxml2</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20quickstart/" class="post-title-link" itemprop="url">[afl-training] quickstart</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:05:10 / Modified: 10:26:52" itemprop="dateCreated datePublished" datetime="2023-04-13T10:05:10+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-quickstart"><a href="#afl-training-quickstart" class="headerlink" title="[afl-training] quickstart"></a>[afl-training] quickstart</h1><p>afl-trainning 是之前在安全客上发现的关于 AFL 实战的学习资料，之前一直想通过 AFL 来进行实战，苦于网上的都是一些基础的使用教程，发现这个资料的时候欣喜万分。</p>
<p>在这个 AFL workshop 中，主要包含了以下的一些内容：</p>
<ul>
<li>quickstart：一个简单的例子，通过 afl 编译程序然后使用 afl-fuzz 来 fuzz，新手入门必看，也就是这一篇文章</li>
<li>harness：</li>
<li>challenges：几个使用 fuzz 可以挖掘出来的经典漏洞<ul>
<li>libxml2：CVE-2015-8317</li>
<li>heartbleed：openssl 的心脏滴血漏洞 CVE-2014-0160</li>
<li>sendmail：CVE-1999-0206, CVE-2003-0161</li>
<li>ntpq：CVE-2009-0159</li>
<li>date：CVE-2017-7476</li>
<li>cyber-grand-challenge</li>
<li>sendmail&#x2F;1305</li>
</ul>
</li>
</ul>
<p>教程是可以使用 docker 的形式创建学习环境的，我这个地方就没有使用了，直接在 git 目录中进行学习。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>trainning 中使用的是 AFLplusplus，我此处使用的就是 AFL，因为之前在看 AFL 的源码。</p>
<p>首先进入 quickstart 目录，然后使用 afl-clang 对程序源码进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd quickstart</span><br><span class="line">CC=afl-clang AFL_HARDEN=1 make</span><br></pre></td></tr></table></figure>

<p>编译出来的程序是读取 STDIN 标准输入进行处理，可直接运行程序，如果敲下回车不输入数据会显示程序帮助信息，也可以直接从 inputs 提供的种子文件进行运行。</p>
<p><img src="/images/image-2023-0413-100605033.png" alt="undifined"></p>
<h2 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h2><p>使用如下的命令直接进行 fuzz，下图是 fuzz 出来的结果，运行了 44 分钟之后跑出了 9 个 crash</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i inputs -o out ./vulnerable</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-100622630.png" alt="undifined"></p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ul>
<li><p>AFL 是如何使用 afl-clang 进行插桩的？</p>
<p>首先需要知道正常使用 gcc 进行编译和使用 alf-clang 进行编译，产生的可执行文件在二进制上的差别。安全相关，因此先使用 checksec 查看 afl-clang 编译出来的可执行文件开启了哪些防御措施，然后使用 gcc 开启对应的防御参数重新进行编译</p>
</li>
</ul>
<p><img src="/images/image-2023-0413-100640530.png" alt="undifined"></p>
<p>  那么使用 gcc 进行编译的命令如下，FORTIFY 选项没有编译出来</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie -fstack-protector-all -z noexecstack -O2 -D_FORTIFY_SOURCE=1 -o vulnerable_gcc vulnerable.c</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-100655331.png" alt="undifined"></p>
<p>  然后使用 bindiff 工具进行查看，可以看到 afl-clang 编译出来的可执行文件中，在每一个基本块中，都加入了 afl_maybe_log 函数，通过在 AFL 源码目录中搜索该函数，可以定位到是在 afl-as.h 文件中，在源码中是以一串静态字符串形式存储的汇编代码，此处以 64 位为例，源码部分如下。</p>
<p><img src="/images/image-2023-0413-100709554.png" alt="undifined"></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>  将源代码编译成二进制文件的基本流程是：源代码 -&gt; 汇编代码 -&gt; 二进制代码，将汇编代码编译成二进制的工具就是汇编器 assembler。Linux 常用的汇编器是 as，当完成了 AFL 的编译后，在目录下也会存在一个 as 文件，并且作为符号链接指向 afl-as。因此，此处的代码插桩实现应该是使用的 afl-as，在将源代码编译成汇编代码的过程中，将如上的 afl_maybe_log 函数插入到分支处，也就是在基本块中进行插桩。如上的插桩代码就是 x64 下正常调用一个函数的流程：开辟栈空间，调用 afl_maybe_log 函数，执行完毕函数之后恢复栈平衡。afl_maybe_log 函数也就是插桩具体要执行的内容。此处不多分析 afl_maybe_log 函数的源码，函数位于 afl-as.c 中，就简单说一下函数的实现功能：通过共享内存对基本块的执行情况进行保存。</p>
<p>  对于插桩分析得比较不错的可以参考看雪的这篇文章：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-265973.htm">[原创]AFL编译插桩部分源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">使用afl对无源码程序进行测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:01:10 / Modified: 10:03:06" itemprop="dateCreated datePublished" datetime="2023-04-13T10:01:10+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用-afl-对无源码的程序进行-fuzz"><a href="#使用-afl-对无源码的程序进行-fuzz" class="headerlink" title="使用 afl 对无源码的程序进行 fuzz"></a>使用 afl 对无源码的程序进行 fuzz</h1><p>有源码的情况下，可以使用 afl 相关的编译器进行编译插桩，然后进行 fuzz；如果是无源码的情况下，就需要使用 afl 的 qemu mode 进行 fuzz。这个地方我使用的是 <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFLPlusPlus</a>，之前已经大概看过 afl 的源码，afl++ 源码的结构更加清晰，因此后面都是在使用 afl++ 作为 fuzz 工具。</p>
<h2 id="待-fuzz-程序和函数劫持-so"><a href="#待-fuzz-程序和函数劫持-so" class="headerlink" title="待 fuzz 程序和函数劫持 so"></a>待 fuzz 程序和函数劫持 so</h2><p>手上有的程序是 x64 的一个简易 cgi，源码如下，是从环境变量中读取数据存放在 buffer 中，当前的目标就是对其中的一个环境变量进行模糊测试，使用 hook 对 REQUEST_METHOD 赋予给定值 GET，然后对 QUERY_STRING 环境变量从标准输入中读取。具体的 hook 实现过程可以参考<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/12/29/%E5%A6%82%E4%BD%95%E5%8A%AB%E6%8C%81%E4%B8%80%E4%B8%AAcgi%E7%9A%84getenv%E5%87%BD%E6%95%B0/">如何劫持一个 cgi 的 getenv 函数</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cgi_nolen.c</span></span><br><span class="line"><span class="comment">// gcc cgi_nolen.c -o cgi_nolen</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* method = getenv(<span class="string">&quot;REQUEST_METHOD&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* url;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] no init env!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两条路径：</span></span><br><span class="line">    <span class="comment">// GET-&gt;URL 两个环境变量导致的缓冲区溢出</span></span><br><span class="line">    <span class="comment">// POST-&gt;STDIN 一个环境变量+标准输入导致的缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(method, <span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] this is get method\n&quot;</span>);</span><br><span class="line">        url = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] get query string %s\n&quot;</span>, url);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] copy url to buffer\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, url);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] buffer is %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(method, <span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] this is post method\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这个地方存在缓冲区溢出</span></span><br><span class="line">        gets(buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] get stdin: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.c</span></span><br><span class="line"><span class="comment">// gcc -D_GUN_SOURCE -shared -fPIC -o hook_getenv.so hook.c -ldl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// 使用RELD_NEXT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *(*original_getenv_func)(<span class="type">const</span> <span class="type">char</span> *) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 定义全局变量buffer来存储STDIN中读取的数据</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  <span class="comment">// 这个地方还需要考虑变异出来的数据的长度和大小</span></span><br><span class="line">  <span class="keyword">if</span> (!original_getenv_func) original_getenv_func = dlsym(RTLD_NEXT, <span class="string">&quot;getenv&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个地方需要定义一个缓冲区才行，用来从stdin中读取数据</span></span><br><span class="line">  <span class="type">char</span> *result = original_getenv_func(name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[hook] hook env %s, origin = %s\n&quot;</span>, name, result);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;REQUEST_METHOD&quot;</span>, <span class="number">14</span>)) &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(buffer, <span class="string">&quot;GET\0&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;GET\0&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] changing to %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;QUERY_STRING&quot;</span>, <span class="number">12</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] hook env URL,change to STDIN\n&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] from STDIN %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译-qemu-mode"><a href="#编译-qemu-mode" class="headerlink" title="编译 qemu-mode"></a>编译 qemu-mode</h2><p>要使用 qemu-mode，首先要编译和待 fuzz 程序架构一致的 afl-qemu-trace。打开 qemu-mode 文件夹，准备编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU_TARGET=x86_64 ./build_qemu_support.sh</span><br><span class="line">cd ..</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>如果要 fuzz 其他架构的程序，那么对应把 CPU_TARGET 进行设定即可，例如 arm、i386 等等。</p>
<h2 id="设置-QEMU-的-so-劫持"><a href="#设置-QEMU-的-so-劫持" class="headerlink" title="设置 QEMU 的 so 劫持"></a>设置 QEMU 的 so 劫持</h2><p>正常情况下如果要劫持一个程序的某些函数，使用环境变量 LD_PRELOAD 即可。afl 的 qemu mode 本质上也是使用的 qemu，如果要劫持待 fuzz 程序的函数，需要在启动 afl 的时候使用环境变量 QEMU_SET_ENV 设置程序在 QEMU 运行下的环境变量。那么 fuzz 的启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_SET_ENV=LD_PRELOAD=&quot;./hook_getenv.so&quot; REQUEST_METHOD=GET afl-fuzz -i input -o output -m none -Q ./cgi_nolen </span><br></pre></td></tr></table></figure>

<p>可以对上面的启动命令做解释：</p>
<ul>
<li><code>QEMU_SET_ENV=LD_PRELOAD=&quot;./hook_getenv.so&quot;</code> 设置待 fuuz 程序的环境变量，设置劫持</li>
<li><code>REQUEST_METHOD=GET</code> 相当于是将 afl-fuzz 和待 fuzz 程序的 REQUEST_METHOD 值都设置成了 POST，因为在 fuzz 的时候使用 fork 创建的子进程继承了 afl-fuzz 的环境变量。</li>
<li><code>afl-fuzz -i input -o output -m none -Q ./cgi_nolen</code> 从 input 文件夹读取种子，fuzz 结果存放在 output 文件夹，无内存限制，使用 QEMU 模式。</li>
</ul>
<p>跑了 11 分钟，出来了 5000 多个 crash，其中的两个是 unique crash。</p>
<p><img src="/images/image-2023-0413-100152606.png" alt="undifined"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">afl命令参数说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:56:47 / Modified: 09:58:12" itemprop="dateCreated datePublished" datetime="2023-04-13T09:56:47+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-命令参数说明"><a href="#AFL-命令参数说明" class="headerlink" title="AFL 命令参数说明"></a>AFL 命令参数说明</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]</span><br><span class="line"></span><br><span class="line">Required parameters:</span><br><span class="line"></span><br><span class="line">  -i dir        - input directory with test cases</span><br><span class="line">  -o dir        - output directory for fuzzer findings</span><br><span class="line"></span><br><span class="line">Execution control settings:</span><br><span class="line"></span><br><span class="line">  -f file       - location read by the fuzzed program (stdin)</span><br><span class="line">  -t msec       - timeout for each run (auto-scaled, 50-1000 ms)</span><br><span class="line">  -m megs       - memory limit for child process (50 MB)</span><br><span class="line">  -Q            - use binary-only instrumentation (QEMU mode)</span><br><span class="line">  -U            - use Unicorn-based instrumentation (Unicorn mode)</span><br><span class="line"></span><br><span class="line">Fuzzing behavior settings:</span><br><span class="line"></span><br><span class="line">  -d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">  -n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">  -x dir        - optional fuzzer dictionary (see README)</span><br><span class="line"></span><br><span class="line">Other stuff:</span><br><span class="line"></span><br><span class="line">  -T text       - text banner to show on the screen</span><br><span class="line">  -M / -S id    - distributed mode (see parallel_fuzzing.txt)</span><br><span class="line">  -C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line"></span><br><span class="line">For additional tips, please consult /usr/local/share/doc/afl/README.</span><br></pre></td></tr></table></figure>

<p>必须的参数：</p>
<ul>
<li>-i：输入文件夹路径，里面有基本的测试样例</li>
<li>-o：afl 的输出文件夹路径</li>
</ul>
<p>额外控制选项：</p>
<ul>
<li>-f：被 fuzz 的程序从何处读取输入，默认是从 stdin 中读取</li>
<li>-t：每一轮模糊测试的超时时间</li>
<li>-m：fuzz fork 出来的子进程的内存限制</li>
<li>-Q：Qemu 模式启动，可以用来 fuzz 其他架构的程序</li>
<li>-u：unicorn 模式，没有怎么用过</li>
</ul>
<p>fuzz 行为设定：</p>
<ul>
<li>-d：quick &amp; dirty 模式，没有使用过</li>
<li>-n：dumb mode，同样没有使用过</li>
<li>-x dir：额外的 fuzzer 目录，没有使用过</li>
</ul>
<p>其他的设定：</p>
<ul>
<li>t：banner 的设定</li>
<li>-M：分布式相关的设定，或者说是并行 fuzz</li>
<li>-C：crash 探索模式</li>
</ul>
<p>这些命令参数的使用目前自己也还不大熟练，对于命令参数的解析在 afl-fuzz.c 的 main 函数中的第一个循环内，如下，可以看出参数的设定并不止帮助提示中的那些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) FATAL(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 这个地方不知道是用来做什么的 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = ck_strdup(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) FATAL(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) FATAL(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) FATAL(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) FATAL(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) FATAL(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  FATAL(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) FATAL(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) FATAL(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) FATAL(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        read_bitmap(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) FATAL(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) FATAL(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">afl qemu mode中关于forkserver的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:53:28 / Modified: 09:55:20" itemprop="dateCreated datePublished" datetime="2023-04-13T09:53:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-mode-中关于-forkserver-作用"><a href="#afl-qemu-mode-中关于-forkserver-作用" class="headerlink" title="afl qemu-mode 中关于 forkserver 作用"></a>afl qemu-mode 中关于 forkserver 作用</h1><p>之前在看 afl 源码，粗略看了大概，没有对判断逻辑仔细查看。我原本理解的 afl 创建目标程序进程的方式为：afl-fuzz 父进程先通过 init_forkserver 创建一个 forkserver 子进程，然后对于每次新产生的变异数据，都在 forkserver 进程中通过 fork 创建子进程，通过之前 dup2 函数将变异数据传递到目标程序进程的标准输入，再 execv 加载目标程序，进行执行。</p>
<p>在 runtarget 函数中，只有当如下标志被设置了，才会使用上面描述的每次 fork 一个子进程，再 execve 这种每次需要额外花费进程生命周期（创建-&gt;执行-&gt;销毁）的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) </span><br></pre></td></tr></table></figure>

<p>afl 采用的 forkserver 技术，实际上是只进行一次 execve 函数执行，之后对于目标程序进程，是通过写时拷贝技术从已经停止的目标程序进程直接拷贝进程镜像，这样就节约了大量的性能。</p>
<p>最近在实现对于 cgi 的 fuzz，并且也还没有看过 afl-gcc 插桩的原理，此处就以 afl 的 qemu-mode 为例（似乎更加简介明了介绍 forkserver，源码编译的话，是汇编代码），简单介绍一下 afl 中 forkserver 的作用以及实现机制。</p>
<h2 id="afl-qemu-mode-中的-forkserver"><a href="#afl-qemu-mode-中的-forkserver" class="headerlink" title="afl qemu-mode 中的 forkserver"></a>afl qemu-mode 中的 forkserver</h2><p>首先简单说明一下 qemu 的基本执行流程，当 qemu 执行一个程序的时候，需要将 elf 进行加载，从被执行程序的入口点开始对基本块进行翻译。为了提升效率，qemu 会将翻译出来的基本块 TB 存放在 cache 中，当 qemu 执行一个基本块的时候首先判断基本块是否在 cache 中，如果在 cache 则命中直接执行基本块 TB，否则翻译再执行。</p>
<p>afl 的 qemu mode 在编译的时候对 qemu 的源码进行了修改 patch。首先在 elf 加载的时候在 elf 入口点、代码段的 start 和 end 三个地方修改，获得相关地址；然后在 cpu 执行也就是基本块翻译执行的地方进行了修改，也就是进行了与覆盖率统计和 forkserver 相关的插桩。详细的介绍可以看下我的这篇文章：<a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">afl qemu 模式简介</a></p>
<p>afl 的 qemu 模式，在每次执行一个基本块的时候，会调用宏定义 AFL_QEMU_CPU_SNIPPET2 来与 afl-fuzz 进程通信。这也就是在 qemu 实现对于目标程序插桩的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \	</span></span><br><span class="line">      afl_setup(); \</span><br><span class="line">      afl_forkserver(cpu); \</span><br><span class="line">    &#125; \</span><br><span class="line">    afl_maybe_log(itb-&gt;pc); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>如果当前执行的基本块是 afl_entry_point，也就是目标程序的入口点，就通过 afl_setup 函数初始化管道和共享内存，然后初始化 forkserver。然后通过 afl-maybe-log 往共享内存中设置覆盖率通信相关信息。此处主要是看一下 forkserver 是如何进行设置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fork server logic, invoked once we hit _start. */</span></span><br><span class="line"><span class="comment">// forkserver，会在程序的_start入口处激活一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_forkserver</span><span class="params">(CPUState *cpu)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmp[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!afl_area_ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the parent that we&#x27;re alive. If the parent doesn&#x27;t want</span></span><br><span class="line"><span class="comment">     to talk, assume that we&#x27;re not running in forkserver mode. */</span></span><br><span class="line">  <span class="comment">// 通过状态管道向afl-fuzz主进程说明，forkserver已经启动</span></span><br><span class="line">  <span class="comment">// 如果写入失败，默认没有使用forkserver模式，return结束</span></span><br><span class="line">  <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 获取自身的进程号</span></span><br><span class="line">  afl_forksrv_pid = getpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All right, let&#x27;s await orders... */</span></span><br><span class="line">  <span class="comment">// forkserver的主循环，也是在这个地方一直执行目标程序</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    <span class="type">int</span> status, t_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whoops, parent dead? */</span></span><br><span class="line">    <span class="comment">// 从afl-fuzz进程的控制管道读取控制信息，如果读取失败，说明afl-fuzz主进程已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (read(FORKSRV_FD, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish a channel with child to grab translation commands. We&#x27;ll</span></span><br><span class="line"><span class="comment">       read from t_fd[0], child will write to TSL_FD. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(t_fd) || dup2(t_fd[<span class="number">1</span>], TSL_FD) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    close(t_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 进入子进程，</span></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Child process. Close descriptors and run free. */</span></span><br><span class="line">	  <span class="comment">// 关闭无关的管道描述符</span></span><br><span class="line">      afl_fork_child = <span class="number">1</span>;</span><br><span class="line">      close(FORKSRV_FD);</span><br><span class="line">      close(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">      close(t_fd[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 进入forkserver进程</span></span><br><span class="line">    <span class="comment">/* Parent. */</span></span><br><span class="line"></span><br><span class="line">    close(TSL_FD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collect translation requests until child dies and closes the pipe. */</span></span><br><span class="line"></span><br><span class="line">    afl_wait_tsl(cpu, t_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get and relay exit status to parent. */</span></span><br><span class="line">    <span class="comment">// 获取目标程序进程的结束信息，并通过状态管道写回到afl-fuzz主进程中</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forkserver 的代码主要流程就是：</p>
<ol>
<li>首先通过状态管道发送数据给 afl-fuzz 主进程，说明 forkserver 创建成功，然后进入 while(1) 循环。在循环中 forkserver 会 read 阻塞在控制管道，等待 alf-fuzz 主进程发送消息。</li>
<li>从控制管道接受到 afl-fuzz 主进程发送的数据后，forkserver fork 出新的子进程，此时的子进程也就是新的目标程序进程，会关闭与afl-fuzz通信的管道，返回继续向下执行目标程序进程在 qemu 中的代码。此时父进程 forkserver 则将新 fork 出来的目标程序进程 pid 通过状态管道发送给afl-fuzz</li>
<li>之后 forkserver 进程进入 afl_wait_tsl，不断循环处理目标程序进程翻译基本块的请求。</li>
<li>最后当目标程序进程执行完毕后，forkserver 获取结束信息，将结束信息通过控制管道发送给 afl-fuzz 用于判断处理 crash。</li>
</ol>
<h2 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h2><p>如上是 qemu mode 中 forkserver 的基本流程，如下对中间涉及到的函数进行简单说明：</p>
<h3 id="static-void-afl-setup-void"><a href="#static-void-afl-setup-void" class="headerlink" title="static void afl-setup(void)"></a>static void afl-setup(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up SHM region and initialize other stuff. */</span></span><br><span class="line"><span class="comment">// 设置共享内存和相关初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 从环境变量SHM_ENV_VAR中获取共享内存ID</span></span><br><span class="line">  <span class="type">char</span> *id_str = getenv(SHM_ENV_VAR),</span><br><span class="line">       *inst_r = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> shm_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_r) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    r = atoi(inst_r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">100</span>) r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    afl_inst_rms = MAP_SIZE * r / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line">    <span class="comment">// 获取共享内存ID</span></span><br><span class="line">    shm_id = atoi(id_str);</span><br><span class="line">    <span class="comment">// 获取共享内存指针</span></span><br><span class="line">    afl_area_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afl_area_ptr == (<span class="type">void</span>*)<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With AFL_INST_RATIO set to a low value, we want to touch the bitmap</span></span><br><span class="line"><span class="comment">       so that the parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst_r) afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_INST_LIBS&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    afl_start_code = <span class="number">0</span>;</span><br><span class="line">    afl_end_code   = (abi_ulong)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pthread_atfork() seems somewhat broken in util/rcu.c, and I&#x27;m</span></span><br><span class="line"><span class="comment">     not entirely sure what is the cause. This disables that</span></span><br><span class="line"><span class="comment">     behaviour, and seems to work alright? */</span></span><br><span class="line">  <span class="comment">// 线程安全相关？</span></span><br><span class="line">  rcu_disable_atfork();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 afl_setup 函数中，最主要的就是从相关环境变量获取到共享内存的指针，用于之后进行覆盖率信息统计。</p>
<h3 id="static-void-afl-wait-tsl-CPUState-cpu-int-fd"><a href="#static-void-afl-wait-tsl-CPUState-cpu-int-fd" class="headerlink" title="static void afl_wait_tsl(CPUState *cpu, int fd)"></a>static void afl_wait_tsl(CPUState *cpu, int fd)</h3><p>首先通过分析 qemu mode 的 patch 可知，qemu 在翻译每一个基本块之后，都会执行宏 AFL_QEMU_CPU_SNIPPET1，</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>在宏中主要是执行函数 afl_request_tsl，代码如下，基本流程就是：目标程序进程如果需要翻译一个新的基本块，将基本块信息发送给forkserver，让其加入到基本块 cache 中。这样 forkserver 下次 fork 出来一个新的目标程序进程的时候，就可从 cache 中不用再次翻译基本块，提高性能。该函数是在 forkserver fork 出来的目标程序进程中执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This code is invoked whenever QEMU decides that it doesn&#x27;t have a</span></span><br><span class="line"><span class="comment">   translation of a particular block and needs to compute it. When this happens,</span></span><br><span class="line"><span class="comment">   we tell the parent to mirror the operation, so that the next fork() has a</span></span><br><span class="line"><span class="comment">   cached copy. */</span></span><br><span class="line"><span class="comment">// 此代码只有当qemu翻译一个新的基本块tb时才会执行，并会将其加入到forkserver中，使得下一次fork目标程序进程有cache备份</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_request_tsl</span><span class="params">(target_ulong pc, target_ulong cb, <span class="type">uint64_t</span> flags)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!afl_fork_child) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  t.pc      = pc;</span><br><span class="line">  t.cs_base = cb;</span><br><span class="line">  t.flags   = flags;</span><br><span class="line">  <span class="comment">// 通过管道发送给forkserver，加入到基本块tb cache中</span></span><br><span class="line">  <span class="keyword">if</span> (write(TSL_FD, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次就是 afl_wait_tsl 函数，该函数在 forkserver 中执行。代码的流程是，forkserver 执行该函数进入死循环不断接受来自目标程序进程的基本块翻译情况，接收到信息说明目标程序进程翻译了一个新的基本块，那么 forkserver 就在自身的 cache 中搜索该基本块。如果该基本块不在 cache 中，则将该基本块加入到 cache，这样下一次 forkserver fork 新进程就可以使用该缓存，避免重复翻译，提高性能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the other side of the same channel. Since timeouts are handled by</span></span><br><span class="line"><span class="comment">   afl-fuzz simply killing the child, we can just wait until the pipe breaks. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_wait_tsl</span><span class="params">(CPUState *cpu, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  TranslationBlock *tb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Broken pipe means it&#x27;s time to return to the fork server routine. */</span></span><br><span class="line">	<span class="comment">// 循环接受来自fork出来的子进程的基本块翻译请求</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 从forkserver的基本块缓存中搜索fork出来的目标进程的基本块</span></span><br><span class="line">    tb = tb_htable_lookup(cpu, t.pc, t.cs_base, t.flags);</span><br><span class="line">	<span class="comment">// 如果forkserver的基本块缓存中没有搜索到，则翻译基本块并加入到forkserver的缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(!tb) &#123;</span><br><span class="line">      mmap_lock();</span><br><span class="line">      tb_lock();</span><br><span class="line">      tb_gen_code(cpu, t.pc, t.cs_base, t.flags, <span class="number">0</span>);</span><br><span class="line">      mmap_unlock();</span><br><span class="line">      tb_unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结这篇文章的原因是自己一直没有理解到 forkserver 是如何执行的，毕设涉及到 qemu mode，也需要稍微了解下其中的原理。其实 afl 的 qemu mode 从原理进行分析还是挺简单的，直接分析 patch 文件，看在 qemu 的哪些源码处进行了修改。然后再简单看一下是如何在 qemu 的翻译基本块前后进行相关判断和插桩的。代码量并不多，看完之后对 afl 有了更深的了解，也理解到了 forkserver 在 qemu 模式中是如何启动的，以及通过将每次新翻译的基本块加入到 forkserver 的 cache 中实现性能优化。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hac425/p/11614235.html">[hac425师傅] 基于qemu和unicorn的Fuzz技术分析</a></li>
<li><a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">[OneShell] afl-qemu模式简介</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">afl qemu mode简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:47:28 / Modified: 09:51:28" itemprop="dateCreated datePublished" datetime="2023-04-13T09:47:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-模式简介"><a href="#afl-qemu-模式简介" class="headerlink" title="afl qemu 模式简介"></a>afl qemu 模式简介</h1><p>这篇文章主要是参考了 <a target="_blank" rel="noopener" href="http://mozhucy.cn/2020/03/13/afl-qemu/">afl-qemu</a>，并简单扩展了自己对 QEMU 的理解和最近对于 AFL 源码阅读的一些理解。</p>
<h2 id="qemu-简介"><a href="#qemu-简介" class="headerlink" title="qemu 简介"></a>qemu 简介</h2><p>qemu 在 IoT 漏洞挖掘和复现中被使用得很多用来进行固件的模拟，根据模拟的级别可以分为用户程序模拟和系统虚拟化模拟。</p>
<p>用户程序模拟就是 QEMU 能够将一个平台编译的二进制文件运行在另外一个不同的平台，例如一个 ARM 指令集的二进制程序，通过 QEMU 的 TCG（Tiny Code Generator）处理之后，ARM 指令被转换成 TCG 的中间代码，然后再转换成目的平台的代码。</p>
<p>系统虚拟化模拟指的是 QEMU 能够模拟一个完整的操作系统虚拟机，该虚拟机有自己的虚拟 CPU、芯片组、虚拟内存以及其他的虚拟外设例如网卡，能够给虚拟机中运行的操作系统提供和物理硬件平台一致的硬件视图。</p>
<p>QEMU 能够模拟的平台也很多，常见的 x86&#x2F;64、ARM、MIPS、PPC 等，早期的 QEMU 都是通过 TCG 来完成对硬件平台的模拟，所有的虚拟机指令也需要通过 QEMU 来进行转换，这个地方不继续深入说明，就简单知道有这个基本 TCG 进行指令翻译的流程。回到正式话题，如果我们要对某个其他指令集的二进制文件进行模糊测试，就可以使用 afl 的 qemu mode。</p>
<p>当我们使用 qemu 来加载一个其他指令集的可执行文件（ELF 为例）时，基本的流程如下：</p>
<ul>
<li>qemu 初始化</li>
<li>TCG 初始化</li>
<li>CPU 初始化</li>
<li>加载可执行文件，以 ELF 为例，有对 ELF 的解析过程</li>
<li>syscall 初始化，qemu 是将可执行文件的系统调用转发到宿主机的系统调用来实现</li>
<li>signal 初始化，在 afl 中也是根据 target 执行过程中的 signal 或者结束代码来判断 crash</li>
<li>gdbserver 初始化，如果启动 qemu 的时候选择调试 -g</li>
<li>cpu_loop 开始模拟</li>
</ul>
<p>如上，重要的流程就是 QEMU 分析目标程序的 ELF 结构，分配必要的内存，装载所需要的库，然后开始进行指令集的翻译、执行，并且将遇见的 syscall 系统调用转发到宿主机进行模拟。CPU 执行的基本流程大概是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">	cpu_exec();</span><br><span class="line">	switch(处理退出事件)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-qemu-mode"><a href="#afl-qemu-mode" class="headerlink" title="afl qemu mode"></a>afl qemu mode</h2><p>在 afl 源码的 qemu mode 文件夹，目录结构如下，其中有编译 qemu mode 的脚本，qemu-2.10.0 的源码，以及一个 readme 文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode [22:38:50] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── build_qemu_support.sh</span><br><span class="line">├── patches</span><br><span class="line">├── qemu-2.10.0</span><br><span class="line">├── qemu-2.10.0.tar.xz</span><br><span class="line">└── README.qemu</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>在 readme 文档中，有对 qemu mode 的简单介绍，是基于 QEMU 的用户级模拟，用于仿真黑盒闭源二进制文件。</p>
<blockquote>
<ol>
<li>Introduction</li>
</ol>
<hr>
<p>The code in this directory allows you to build a standalone feature that<br>leverages the QEMU “user emulation” mode and allows callers to obtain<br>instrumentation output for black-box, closed-source binaries. This mechanism<br>can be then used by afl-fuzz to stress-test targets that couldn’t be built<br>with afl-gcc.</p>
<p>The usual performance cost is 2-5x, which is considerably better than<br>seen so far in experiments with tools such as DynamoRIO and PIN.</p>
<p>The idea and much of the implementation comes from Andrew Griffiths.</p>
</blockquote>
<p>接下来就是看看 qemu mode 的编译流程，其中大概做了一些注释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright 2015 Google LLC All rights reserved.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You may obtain a copy of the License at:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">limitations under the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">american fuzzy lop - QEMU build script</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Written by Andrew Griffiths &lt;agriffiths@google.com&gt; and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script downloads, patches, and builds a version of QEMU with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor tweaks to allow non-instrumented binaries to be run under</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">afl-fuzz.</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The modifications reside in patches/*. The standalone QEMU binary</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">will be written to ../afl-qemu-trace.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"></span><br><span class="line">VERSION=&quot;2.10.0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">QEMU 2.10.0 源码下载</span></span><br><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br><span class="line">QEMU_SHA384=&quot;68216c935487bc8c0596ac309e1e3ee75c2c4ce898aab796faa321db5740609ced365fedda025678d072d09ac8928105&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo &quot;AFL binary-only instrumentation QEMU build script&quot;</span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Performing basic sanity checks...&quot;</span><br><span class="line"></span><br><span class="line">if [ ! &quot;`uname -s`&quot; = &quot;Linux&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: QEMU instrumentation is supported only on Linux.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行patch</span></span><br><span class="line">if [ ! -f &quot;patches/afl-qemu-cpu-inl.h&quot; -o ! -f &quot;../config.h&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: key files not found - wrong working directory?&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;../afl-showmap&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: ../afl-showmap not found - compile AFL first!&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in libtool wget python automake autoconf sha384sum bison iconv; do</span><br><span class="line"></span><br><span class="line">  T=`which &quot;$i&quot; 2&gt;/dev/null`</span><br><span class="line"></span><br><span class="line">  if [ &quot;$T&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: &#x27;$i&#x27; not found, please install first.&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;/usr/include/glib-2.0/&quot; -a ! -d &quot;/usr/local/include/glib-2.0/&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: devel version of &#x27;glib2&#x27; not found, please install first.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if echo &quot;$CC&quot; | grep -qF /afl-; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: do not use afl-gcc or afl-clang to compile this tool.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[+] All checks passed!&quot;</span><br><span class="line"></span><br><span class="line">ARCHIVE=&quot;`basename -- &quot;$QEMU_URL&quot;`&quot;</span><br><span class="line"></span><br><span class="line">CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">if [ ! &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Downloading QEMU $&#123;VERSION&#125; from the web...&quot;</span><br><span class="line">  rm -f &quot;$ARCHIVE&quot;</span><br><span class="line">  wget -O &quot;$ARCHIVE&quot; -- &quot;$QEMU_URL&quot; || exit 1</span><br><span class="line"></span><br><span class="line">  CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Cryptographic signature on $ARCHIVE checks out.&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: signature mismatch on $ARCHIVE (perhaps download error?).&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Uncompressing archive (this will take a while)...&quot;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;qemu-$&#123;VERSION&#125;&quot; || exit 1</span><br><span class="line">tar xf &quot;$ARCHIVE&quot; || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Unpacking successful.&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据脚本执行的环境变量CPU_TARGET编译对应架构的QEMU</span></span><br><span class="line">echo &quot;[*] Configuring QEMU for $CPU_TARGET...&quot;</span><br><span class="line"></span><br><span class="line">ORIG_CPU_TARGET=&quot;$CPU_TARGET&quot;</span><br><span class="line"></span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;&quot; &amp;&amp; CPU_TARGET=&quot;`uname -m`&quot;</span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;i686&quot; &amp;&amp; CPU_TARGET=&quot;i386&quot;</span><br><span class="line"></span><br><span class="line">cd qemu-$VERSION || exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对QEMU源码进行patch</span></span><br><span class="line">echo &quot;[*] Applying patches...&quot;</span><br><span class="line"></span><br><span class="line">patch -p1 &lt;../patches/elfload.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/cpu-exec.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/syscall.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/configure.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd.diff || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Patching done.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--enable-pie seems to give a couple of <span class="built_in">exec</span><span class="string">&#x27;s a second performance</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">improvement, much to my surprise. Not sure how universal this is..</span></span></span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-O3 -ggdb&quot; ./configure --disable-system \</span><br><span class="line">  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \</span><br><span class="line">  --target-list=&quot;$&#123;CPU_TARGET&#125;-linux-user&quot; --enable-pie --enable-kvm || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Configuration complete.&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Attempting to build QEMU (fingers crossed!)...&quot;</span><br><span class="line"></span><br><span class="line">make || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Build process successful!&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Copying binary...&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将编译出来的qemu可执行文件复制为afl-qemu-trace</span></span></span><br><span class="line">cp -f &quot;$&#123;CPU_TARGET&#125;-linux-user/qemu-$&#123;CPU_TARGET&#125;&quot; &quot;../../afl-qemu-trace&quot; || exit 1</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">ls -l ../afl-qemu-trace || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Successfully created &#x27;../afl-qemu-trace&#x27;.&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$ORIG_CPU_TARGET&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Testing the build...&quot;</span><br><span class="line"></span><br><span class="line">  cd ..</span><br><span class="line"></span><br><span class="line">  make &gt;/dev/null || exit 1</span><br><span class="line"></span><br><span class="line">  gcc test-instr.c -o test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  unset AFL_INST_RATIO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">We shouldn&#x27;</span>t need the /dev/null hack because program isn<span class="string">&#x27;t compiled with any</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">optimizations.</span></span></span><br><span class="line">  echo 0 | ./afl-showmap -m none -Q -q -o .test-instr0 ./test-instr || exit 1</span><br><span class="line">  echo 1 | ./afl-showmap -m none -Q -q -o .test-instr1 ./test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  rm -f test-instr</span><br><span class="line"></span><br><span class="line">  cmp -s .test-instr0 .test-instr1</span><br><span class="line">  DR=&quot;$?&quot;</span><br><span class="line"></span><br><span class="line">  rm -f .test-instr0 .test-instr1</span><br><span class="line"></span><br><span class="line">  if [ &quot;$DR&quot; = &quot;0&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: afl-qemu-trace instrumentation doesn&#x27;t seem to work!&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Instrumentation tests passed. &quot;</span><br><span class="line">  echo &quot;[+] All set, you can now use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[!] Note: can&#x27;t test instrumentation when CPU_TARGET set.&quot;</span><br><span class="line">  echo &quot;[+] All set, you can now (hopefully) use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到编译脚本中是先下载指定 QEMU 版本的源码，进行一些检测，然后进行 patch。patch 是对 QEMU 的 ELF 装载、CPU 执行、系统调用、内存描述符等相关的代码进行了修改，以及对 configure 文件也进行修改。patch 完成之后进行 make，然后将编译完成的 qemu-${CPU_TARGET} 复制到 afl 的目录下，重命名为 afl-qemu-trace，在之后会从 afl-fuzz.c 简单说下 afl-qemu-trace 是如何进行调用的。这个地方说一下，如果要 fuzz 指定架构的二进制文件，那么需要在编译的时候指定编译 qemu 可执行文件针对的架构，例如编译 mips 的命令：<code>CPU_TARGET=mips ./build_qemu_support.sh</code>。然后就是在脚本中测试编译出来的 afl-qemu-trace 能否正常使用。</p>
<p>可见最为关键的地方是进行的几个 patch，patch 文件内容不多，下面来简单分析一下 diff 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode/patches [0:49:08] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── afl-qemu-cpu-inl.h</span><br><span class="line">├── configure.diff</span><br><span class="line">├── cpu-exec.diff</span><br><span class="line">├── elfload.diff</span><br><span class="line">├── memfd.diff</span><br><span class="line">└── syscall.diff</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br></pre></td></tr></table></figure>

<h3 id="elfload-diff"><a href="#elfload-diff" class="headerlink" title="elfload.diff"></a>elfload.diff</h3><p>如下是 elfload.diff 文件，新增了三个外部引用，在 QEMU 执行 ELF 文件解析的时候获取这些地址。</p>
<ul>
<li>afl_entry_point：ELF 的入口点</li>
<li>afl_start_code：ELF 代码段的 start</li>
<li>afl_end_code：ELF 代码段的 end</li>
</ul>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/elfload.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/elfload.c	2017-08-22 14:33:57.397127516 -0700</span></span><br><span class="line"><span class="meta">@@ -20,6 +20,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #define ELF_OSABI   ELFOSABI_SYSV</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern abi_ulong afl_entry_point, afl_start_code, afl_end_code;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* from personality.h */</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -2085,6 +2087,8 @@</span></span><br><span class="line">     info-&gt;brk = 0;</span><br><span class="line">     info-&gt;elf_flags = ehdr-&gt;e_flags;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (!afl_entry_point) afl_entry_point = info-&gt;entry;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     for (i = 0; i &lt; ehdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">         struct elf_phdr *eppnt = phdr + i;</span><br><span class="line">         if (eppnt-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line"><span class="meta">@@ -2118,9 +2122,11 @@</span></span><br><span class="line">             if (elf_prot &amp; PROT_EXEC) &#123;</span><br><span class="line">                 if (vaddr &lt; info-&gt;start_code) &#123;</span><br><span class="line">                     info-&gt;start_code = vaddr;</span><br><span class="line"><span class="addition">+                    if (!afl_start_code) afl_start_code = vaddr;</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 if (vaddr_ef &gt; info-&gt;end_code) &#123;</span><br><span class="line">                     info-&gt;end_code = vaddr_ef;</span><br><span class="line"><span class="addition">+                    if (!afl_end_code) afl_end_code = vaddr_ef;</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             if (elf_prot &amp; PROT_WRITE) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="cpu-exec-diff"><a href="#cpu-exec-diff" class="headerlink" title="cpu-exec.diff"></a>cpu-exec.diff</h3><p>如下是 cpu-exec.diff 文件，新增了一个头文件 afl-qemu-cpu-inl.h，在 CPU 执行 QEMU 翻译代码的前后位置分别加入了宏定义 AFL_QEMU_CPU_SNIPPET2 和 AFL_QEMU_CPU_SNIPPET1。TB（Translation Block）是 QEMU 进行指令翻译的基本单位。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/accel/tcg/cpu-exec.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/accel/tcg/cpu-exec.c	2017-08-22 14:34:55.868730680 -0700</span></span><br><span class="line"><span class="meta">@@ -36,6 +36,8 @@</span></span><br><span class="line"> #include &quot;sysemu/cpus.h&quot;</span><br><span class="line"> #include &quot;sysemu/replay.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#include &quot;../patches/afl-qemu-cpu-inl.h&quot;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* -icount align implementation. */</span><br><span class="line"> </span><br><span class="line"> typedef struct SyncClocks &#123;</span><br><span class="line"><span class="meta">@@ -144,6 +146,8 @@</span></span><br><span class="line">     int tb_exit;</span><br><span class="line">     uint8_t *tb_ptr = itb-&gt;tc_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    AFL_QEMU_CPU_SNIPPET2;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,</span><br><span class="line">                            &quot;Trace %p [%d: &quot; TARGET_FMT_lx &quot;] %s\n&quot;,</span><br><span class="line">                            itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,</span><br><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             mmap_unlock();</span><br></pre></td></tr></table></figure>

<p>如下是两个宏定义的源码，AFL_QEMU_CPU_SNIPPET1 是用来实现翻译的加速，AFL_QEMU_CPU_SNIPPET2 位于执行 TB 的函数，在待 fuzz 程序的入口处，进行 afl_setup，然后执行 afl_forkserver，其中有 fork 执行过程。对于覆盖率的计算则是常见的 afl_maybe_log 函数，在使用 afl-gcc 等编译的程序中也会在基本块插入 afl_maybe_log 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A snippet patched into tb_find_slow to inform the parent process that</span></span><br><span class="line"><span class="comment">   we have hit a new block that hasn&#x27;t been translated yet, and to tell</span></span><br><span class="line"><span class="comment">   it to translate within its own context, too (this avoids translation</span></span><br><span class="line"><span class="comment">   overhead in the next forked-off copy). */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This snippet kicks in when the instruction pointer is positioned at</span></span><br><span class="line"><span class="comment">   _start and does the usual forkserver stuff, not very different from</span></span><br><span class="line"><span class="comment">   regular instrumentation injected via afl-as.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \</span></span><br><span class="line"><span class="meta">      afl_setup(); \</span></span><br><span class="line"><span class="meta">      afl_forkserver(cpu); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">    afl_maybe_log(itb-&gt;pc); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h3 id="syscall-diff"><a href="#syscall-diff" class="headerlink" title="syscall.diff"></a>syscall.diff</h3><p>如下是 syscall.diff，定义了全局变量 qemu.h，新增外部引用 afl_forksrv_pid，也就是 forkserver 的 pid，新增了对于 TARGET_NR_tgkill 的判定，具体的含义不是很懂，但应该和 target 的执行返回错误码有关。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/syscall.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/syscall.c	2017-08-22 14:34:03.193088186 -0700</span></span><br><span class="line"><span class="meta">@@ -116,6 +116,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"><span class="meta">@@ -11688,8 +11690,21 @@</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line">     case TARGET_NR_tgkill:</span><br><span class="line"><span class="deletion">-        ret = get_errno(safe_tgkill((int)arg1, (int)arg2,</span></span><br><span class="line"><span class="deletion">-                        target_to_host_signal(arg3)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+          int pid  = (int)arg1,</span></span><br><span class="line"><span class="addition">+              tgid = (int)arg2,</span></span><br><span class="line"><span class="addition">+              sig  = (int)arg3;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          /* Not entirely sure if the below is correct for all architectures. */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          if(afl_forksrv_pid &amp;&amp; afl_forksrv_pid == pid &amp;&amp; sig == SIGABRT)</span></span><br><span class="line"><span class="addition">+              pid = tgid = getpid();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line"> #ifdef TARGET_NR_set_robust_list</span><br></pre></td></tr></table></figure>

<p>综上所述，三个 patch 文件所作的工作就是在 qemu 代码翻译的阶段，在 QEMU 翻译基本块 TB 加入指令插桩代码，从 ELF 的入口开始执行，然后进行代码覆盖率和错误代码的相关计算。</p>
<h2 id="afl-fuzz-c-中使用-qemu-mode"><a href="#afl-fuzz-c-中使用-qemu-mode" class="headerlink" title="afl-fuzz.c 中使用 qemu mode"></a>afl-fuzz.c 中使用 qemu mode</h2><p>假设已经简单阅读过 afl-fuzz.c 的源码，在 main 函数参数解析时，会判定 -Q 使用了 qemu mode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">       qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>如果是使用了 qemu mode，会根据 afl-fuzz 的命令参数构造 qemu 的启动参数。在 get_qemu_argv 函数中，主要执行的工作就是为 QEMU 设置相关环境变量，搜索 afl-qemu-trace 程序，构造 afl-qemu-trace 启动的命令参数，也就是将 target_path 修改为如何使用 afl-qemu-trace 执行待 fuzz 程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line">  use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  use_argv = argv + optind;</span><br></pre></td></tr></table></figure>

<p>那么最终 qemu 模式是如何启动起来的，我根据源码的理解大概是，在 afl-fuzz.c 的 main 函数，在最后的循环中，调用 fuzz_one -&gt; calibrate_case -&gt; init_forkserver -&gt;   execv</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue)</span>;</span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 init_forkserver 函数中，有将变异数据的文件描述符和待 fuzz 程序的标准输入绑定的过程。当使用 execv 执行 afl-qemu-trace，此时 patch 了的 afl-qemu-trace 会在 ELF 的入口处执行 afl_setup() 函数和 afl_forkserver() 函数，进行真正的待 fuzz 程序的执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章先简单介绍了 QEMU 执行用户级程序的基本流程，然后通过分析 afl qemu mode 的编译脚本和 diff 文件，简单说明了在 afl 中使用 qemu fuzz 闭源程序的基本流程，然后分析 afl-fuzz.c 源码，简要说明 afl-fuzz 是如何将进行一个变异数据送到待 fuzz 程序中去执行。</p>
<p>如果有问题，或者看到这篇文章的师傅有其他的见解讨论，请联系我，谢谢！</p>
<p>这里有一个简单的对于 AFL qemu mode 的使用，参见<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/12/30/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8Cfuzz/">使用afl对无源码程序进行fuzz</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/%E5%BA%94%E5%AF%B9%E5%8A%A0%E5%AF%86%E5%9B%BA%E4%BB%B6%E4%B9%8B%E4%BB%8E%E6%9C%AA%E5%8A%A0%E5%AF%86%E8%80%81%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/%E5%BA%94%E5%AF%B9%E5%8A%A0%E5%AF%86%E5%9B%BA%E4%BB%B6%E4%B9%8B%E4%BB%8E%E6%9C%AA%E5%8A%A0%E5%AF%86%E8%80%81%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86/" class="post-title-link" itemprop="url">应对加密固件之从未加密老固件进行解密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 07:17:29 / Modified: 19:20:05" itemprop="dateCreated datePublished" datetime="2023-04-12T07:17:29+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="加密固件之依据老固件进行解密"><a href="#加密固件之依据老固件进行解密" class="headerlink" title="加密固件之依据老固件进行解密"></a>加密固件之依据老固件进行解密</h1><p>IoT漏洞分析最为重要的环节之一就是获取固件以及固件中的文件系统。固件获取的方式也五花八门，硬核派有直接将flash拆下来到编程器读取，通过硬件调试器UART&#x2F;SPI、JTAG&#x2F;SWD获取到控制台访问；网络派有中间人攻击拦截OTA升级，从制造商的网页进行下载；社工派有假装研究者（学生）直接向客服索要，上某鱼进行PY。有时候千辛万苦获取到固件了，开开心心地使用<code>binwalk -Me</code>一把梭哈，却发现，固件被加密了，惊不惊喜，刺不刺激。</p>
<p>如下就是针对如何对加密固件进行解密的其中一个方法：回溯未加密的老固件，从中找到负责对固件进行解密的程序，然后解密最新的加密固件。此处做示范使用的设备是前几天爆出存在漏洞的路由器D-Link DIR 3040 US，固件使用的最新加密版本<a target="_blank" rel="noopener" href="https://support.dlink.com/productinfo.aspx?m=DIR-3040-US">1.13B03</a>，老固件使用的是已经解密固件版本<a target="_blank" rel="noopener" href="https://support.dlink.com/productinfo.aspx?m=DIR-3040-US">1.13B02</a>。</p>
<h2 id="判断固件是否已经被加密"><a href="#判断固件是否已经被加密" class="headerlink" title="判断固件是否已经被加密"></a>判断固件是否已经被加密</h2><p>一般从官网下载到固件的时候，是先以zip等格式进行了一次压缩的，通常可以先正常解压一波。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── DIR3040A1_FW112B01_middle.bin</span><br><span class="line">├── DIR3040A1_FW113B03.bin</span><br><span class="line">└── DIR-3040_REVA_RELEASE_NOTES_v1.13B03.pdf</span><br></pre></td></tr></table></figure>

<p>使用binwalk查看一下固件的信息，如果是未加密的固件，通常可以扫描出来使用了何种压缩算法。以常见的嵌入式文件系统squash-fs为例，比较常见的有LZMA、LZO、LAMA2这些。如下是使用binwalk分别查看一个未加密固件（netgear）和加密固件（DIR 3040）信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk GS108Tv3_GS110TPv3_GS110TPP_V7.0.6.3.bix</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">64            0x40            LZMA compressed data, properties: 0x5D, dictionary size: 67108864 bytes, uncompressed size: -1 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk DIR3040A1_FW113B03.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一种方式就是查看固件的熵值。熵值是用来衡量不确定性，熵值越大则说明固件越有可能被加密或者压缩了。这个地方说的是被加密或者压缩了，被压缩的情况也是会让熵值变高或者接近1的，如下是使用<code>binwalk -E</code>查看一个未加密固件（RAX200）和加密固件（DIR 3040）。可以看到，RAX200和DIR 3040相对比，不像后者那样直接全部是接近1了。</p>
<p><img src="/images/image-2023-0412-191809650.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-191825028.png" alt="undifined"></p>
<h2 id="找到负责解密的可执行文件"><a href="#找到负责解密的可执行文件" class="headerlink" title="找到负责解密的可执行文件"></a>找到负责解密的可执行文件</h2><p>接下来是进入正轨了。首先是寻找到老固件中负责解密的可执行文件。基本逻辑是先从HTML文件中找到显示升级的页面，然后在服务器程序例如此处使用的是lighttpd中去找到何处进行了调用可执行文件下载新固件、解密新固件，这一步也可能是发生在调用的CGI中。</p>
<p>使用find命令定位和升级相关的页面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*htm*&quot;</span> | grep -i <span class="string">&quot;firmware&quot;</span></span></span><br><span class="line">./etc_ro/lighttpd/www/web/MobileUpdateFirmware.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_e.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_Multi.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_Simple.html</span><br></pre></td></tr></table></figure>

<p>然后现在后端lighttpd中去找相关字符串，似乎没有结果呢，那么猜测可能发生在CGI中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*httpd*&quot;</span> | xargs strings | grep <span class="string">&quot;firm&quot;</span></span></span><br><span class="line">strings: Warning: &#x27;./etc_ro/lighttpd&#x27; is a directory</span><br></pre></td></tr></table></figure>

<p>从CGI程序中查找，似乎运气不错，，，直接就定位到了，结果过多就只展示了最有可能的结果。Bingo！似乎已经得到了解密固件的程序，img、decrypt。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*cgi*&quot;</span> | xargs strings | grep -i <span class="string">&quot;firm&quot;</span></span></span><br><span class="line">/bin/imgdecrypt /tmp/firmware.img</span><br></pre></td></tr></table></figure>

<h2 id="仿真并解密固件"><a href="#仿真并解密固件" class="headerlink" title="仿真并解密固件"></a>仿真并解密固件</h2><p>拿到了解密程序，也知道解密程序是怎么输入参数运行的，这个时候可以尝试对直接使用qemu模拟解密程序跑起来，直接对固件进行解密。最好保持解密可执行文件在老版本固件文件系统的位置不变，因为不确定是否使用相对或者绝对路径引用了什么文件，例如解密公私钥。</p>
<p>先查看可执行文件的运行架构，然后选择对应qemu进行模拟。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file bin/imgdecrypt</span></span><br><span class="line">bin/imgdecrypt: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) ./usr/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount -t proc /proc proc/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount --rbind /sys sys/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount --rbind /dev/ dev/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . qemu-mipsel-static /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.22.1 (2020-05-09 10:44:01 CST) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">/ # /bin/imgdecrypt tmp/DIR3040A1_FW113B03.bin</span><br><span class="line">key:C05FBF1936C99429CE2A0781F08D6AD8</span><br><span class="line">/ # ls -a tmp/</span><br><span class="line">..                      .firmware.orig          .                       DIR3040A1_FW113B03.bin</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<p>那么就解压出来了，解压到了tmp文件夹中，.firmware.orig文件。这个时候使用binwalk再次进行查看，可以看到已经被成功解密了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk .firmware.orig</span></span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             uImage header, header size: 64 bytes, header CRC: 0x7EA490A0, created: 2020-08-14 10:42:39, image size: 17648005 bytes, Data Address: 0x81001000, Entry Point: 0x81637600, data CRC: 0xAEF2B79F, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;Linux Kernel Image&quot;</span><br><span class="line">160           0xA0            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 23083456 bytes</span><br><span class="line">1810550       0x1BA076        PGP RSA encrypted session key - keyid: 12A6E329 67B9887A RSA (Encrypt or Sign) 1024b</span><br><span class="line">14275307      0xD9D2EB        Cisco IOS microcode, for &quot;z&quot;</span><br></pre></td></tr></table></figure>

<h2 id="加解密逻辑分析（重点）"><a href="#加解密逻辑分析（重点）" class="headerlink" title="加解密逻辑分析（重点）"></a>加解密逻辑分析（重点）</h2><h3 id="关于固件安全开发到发布的一般流程"><a href="#关于固件安全开发到发布的一般流程" class="headerlink" title="关于固件安全开发到发布的一般流程"></a>关于固件安全开发到发布的一般流程</h3><p>如果要考虑到固件的安全性，需要解决的一些痛点基本上是：</p>
<ul>
<li>机密性：通过类似官网的公开渠道获取到解密后的固件</li>
<li>完整性：攻击者劫持升级渠道，或者直接将修改后的固件上传到设备，使固件升级</li>
</ul>
<p>对于机密性，从固件的源头、传输渠道到设备三个点来分析。首先在源头，官网上或者官方TFP可以提供已经被加密的固件，设备自动或手动检查更新并从源头下载，下载到设备上后进行解密。其次是渠道，可以采用类似于HTTPS的加密传输方式来对固件进行传输。但是前面两种方式终归是要将固件下载到设备中。</p>
<p>如果是进行简单的加密，很常见的一种方式，尤其是对于一些低端嵌入式固件，通常使用了硬编码的对称加密方式，例如AES、DES之类的，还可以基于硬编码的字符串进行一些数据计算，然后作为解密密钥。这次分析的DIR 3040就是采用的这种方式。</p>
<p>对于完整性，开发者在一开始可以通过基于自签名证书来实现对固件完整性的校验。开发者使用私钥对固件进行签名，并把签名附加到固件中。设备在接受安装时使用提前预装的公钥进行验证，如果检测到设备完整性受损，那么就拒绝固件升级。签名的流程一般不直接对固件本身的内容进行签名，首先计算固件的HASH值，然后开发者使用私钥对固件HASH进行签名，将签名附加到固件中。设备在出厂时文件系统中就被预装了公钥，升级通过公钥验证签名是否正确。</p>
<p><img src="/images/image-2023-0412-191853123.png" alt="undifined"></p>
<h3 id="加解密逻辑分析"><a href="#加解密逻辑分析" class="headerlink" title="加解密逻辑分析"></a>加解密逻辑分析</h3><p>既然到这个地方了，那么顺便进去看一看解密程序是如何进行运作的。从IDA的符号表中可以看到，使用到了对称加密AES、非对称加密RSA和哈希SHA512，是不是对比上面提到的固件安全开发到发布的流程，心中大概有个数了。</p>
<p>首先我们进入main函数，可以知道，这个解密程序imgdecrypt实际上也是具有加密功能的。这里提一下，因为想要把整个解密固件的逻辑都撸一撸，可能会在文章里面贴出很多的具体函数分析，那么文章篇幅就会有点长，不过最后会进行一个流程的小总结，希望看的师傅不用觉得啰嗦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*argv, <span class="string">&quot;decrypt&quot;</span>, envp) )</span><br><span class="line">    result = decrypt_firmare(argc, (<span class="type">int</span>)argv);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = encrypt_firmare(argc, argv);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步继续进入到函数decrypt_firmare中，这个地方结合之前仿真可以知道：argc&#x3D;2，argv&#x3D;参数字符串地址。首先是进行一些参数的初始化，例如aes_key、公钥的存储地址pubkey_loc。</p>
<p>接下来是对输入参数数量和参数字符串的判定，输入参数数量从2开始判定，结合之前的仿真，那么argc&#x3D;2，第一个是程序名，第二个是已加密固件地址。</p>
<p>然后在004021AC地址处的函数check_rsa_cert，该函数内部逻辑也非常简单，基本就是调用RSA相关的库函数，读取公钥并判定公钥是否有效，有效则将读取到的RSA对象保存在dword_413220。检查成功后，就进入到004025A4地址处的函数aes_cbc_crypt中。这个函数的主要作用就是根据一个固定字符串0123456789ABCDEF生成密钥，是根据硬编码生成的解密密钥，因此每次生成并打印出来的密钥是相同的，此处密钥用变量aes_key表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">decrypt_firmare</span><span class="params">(<span class="type">int</span> argc, <span class="type">int</span> argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *pubkey_loc; <span class="comment">// [sp+18h] [-1Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+1Ch] [-18h]</span></span><br><span class="line">  <span class="type">int</span> aes_key[<span class="number">5</span>]; <span class="comment">// [sp+20h] [-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(aes_key, <span class="string">&quot;0123456789ABCDEF&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  pubkey_loc = <span class="string">&quot;/etc_ro/public.pem&quot;</span>;</span><br><span class="line">  i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &gt;= <span class="number">3</span> )</span><br><span class="line">      pubkey_loc = *(<span class="type">const</span> <span class="type">char</span> **)(argv + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( check_rsa_cert((<span class="type">int</span>)pubkey_loc, <span class="number">0</span>) )   <span class="comment">// 读取公钥并进行保存RSA对象到dword_413220中</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      aes_cbc_crypt((<span class="type">int</span>)aes_key);              <span class="comment">// 生成aes_key</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;key:&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, *((<span class="type">unsigned</span> __int8 *)aes_key + i));<span class="comment">// 打印出key</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">      i = actual_decrypt(*(_DWORD *)(argv + <span class="number">4</span>), (<span class="type">int</span>)<span class="string">&quot;/tmp/.firmware.orig&quot;</span>, (<span class="type">int</span>)aes_key);</span><br><span class="line">      <span class="keyword">if</span> ( !i )</span><br><span class="line">      &#123;</span><br><span class="line">        unlink(*(_DWORD *)(argv + <span class="number">4</span>));</span><br><span class="line">        rename(<span class="string">&quot;/tmp/.firmware.orig&quot;</span>, *(_DWORD *)(argv + <span class="number">4</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      RSA_free(dword_413220);</span><br><span class="line">      result = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;sourceFile&gt;\r\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)argv);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正的负责解密和验证固件的函数actual_decrypt，位于地址00401770处。在分析这个函数的时候，我发现IDA的MIPS32在反编译处理函数的输入参数的时候，似乎会把数值给弄错了，，，比如fun(a + 10)，可能会反编译成fun(a + 12)。已经修正过函数参数数值的反编译代码就放在下面，代码分析也全部直接放在注释中了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">actual_decrypt</span><span class="params">(<span class="type">int</span> img_loc, <span class="type">int</span> out_image_loc, <span class="type">int</span> aes_key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> image_fp; <span class="comment">// [sp+20h] [-108h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+24h] [-104h]</span></span><br><span class="line">  _DWORD *MEM; <span class="comment">// [sp+28h] [-100h]</span></span><br><span class="line">  <span class="type">int</span> OUT_MEM; <span class="comment">// [sp+2Ch] [-FCh]</span></span><br><span class="line">  <span class="type">int</span> file_blocks; <span class="comment">// [sp+30h] [-F8h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+34h] [-F4h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+38h] [-F0h]</span></span><br><span class="line">  <span class="type">int</span> out_image_fp; <span class="comment">// [sp+3Ch] [-ECh]</span></span><br><span class="line">  <span class="type">int</span> data1_len; <span class="comment">// [sp+40h] [-E8h]</span></span><br><span class="line">  <span class="type">int</span> data2_len; <span class="comment">// [sp+44h] [-E4h]</span></span><br><span class="line">  _DWORD *IN_MEM; <span class="comment">// [sp+48h] [-E0h]</span></span><br><span class="line">  <span class="type">char</span> hash_buf[<span class="number">68</span>]; <span class="comment">// [sp+4Ch] [-DCh] BYREF</span></span><br><span class="line">  <span class="type">int</span> image_info[<span class="number">38</span>]; <span class="comment">// [sp+90h] [-98h] BYREF</span></span><br><span class="line"></span><br><span class="line">  image_fp = <span class="number">-1</span>;</span><br><span class="line">  out_image_fp = <span class="number">-1</span>;</span><br><span class="line">  v5 = <span class="number">-1</span>;</span><br><span class="line">  MEM = <span class="number">0</span>;</span><br><span class="line">  OUT_MEM = <span class="number">0</span>;</span><br><span class="line">  file_blocks = <span class="number">-1</span>;</span><br><span class="line">  v9 = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 这个hashbuf用于存储SHA512的计算结果，在后面比较会一直被使用到</span></span><br><span class="line">  <span class="built_in">memset</span>(hash_buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">  data1_len = <span class="number">0</span>;</span><br><span class="line">  data2_len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(image_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(image_info));</span><br><span class="line">  IN_MEM = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 通过stat函数读取加密固件的相关信息写入结构体到image_info，最重要的是文件大小</span></span><br><span class="line">  <span class="keyword">if</span> ( !stat(img_loc, image_info) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    file_blocks = image_info[<span class="number">13</span>];</span><br><span class="line">    <span class="comment">// 以只读打开加密固件</span></span><br><span class="line">    image_fp = open(img_loc, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 将加密固件映射到内存中</span></span><br><span class="line">      MEM = (_DWORD *)mmap(<span class="number">0</span>, file_blocks, <span class="number">1</span>, <span class="number">1</span>, image_fp, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( MEM )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 以O_RDWR | O_NOCTTY获得解密后固件应该存放的文件描述符</span></span><br><span class="line">        out_image_fp = open(out_image_loc, <span class="number">258</span>);</span><br><span class="line">        <span class="keyword">if</span> ( out_image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = file_blocks;</span><br><span class="line">          <span class="comment">// 比较写入到内存的大小和固件的真实大小是否相同</span></span><br><span class="line">          <span class="keyword">if</span> ( file_blocks - <span class="number">1</span> == lseek(out_image_fp, file_blocks - <span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            write(out_image_fp, &amp;unk_402EDC, <span class="number">1</span>);</span><br><span class="line">            close(out_image_fp);</span><br><span class="line">            out_image_fp = open(out_image_loc, <span class="number">258</span>);</span><br><span class="line">            <span class="comment">// 以加密固件的文件大小，将待解密的固件映射到内存中，返回内存地址OUT_MEM</span></span><br><span class="line">            OUT_MEM = mmap(<span class="number">0</span>, v9, <span class="number">3</span>, <span class="number">1</span>, out_image_fp, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( OUT_MEM )</span><br><span class="line">            &#123;</span><br><span class="line">              IN_MEM = MEM;                     <span class="comment">// 重新赋值指针</span></span><br><span class="line">              <span class="comment">// 检查固件的Magic，通过查看HEX可以看到加密固件的开头有SHRS魔数</span></span><br><span class="line">              <span class="keyword">if</span> ( check_magic((<span class="type">int</span>)MEM) )      <span class="comment">// 比较读取到的固件信息中含有SHRS</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">// 获得解密后固件的大小</span></span><br><span class="line">                data1_len = htonl(IN_MEM[<span class="number">2</span>]);  </span><br><span class="line">                data2_len = htonl(IN_MEM[<span class="number">1</span>]);	</span><br><span class="line">                <span class="comment">// 从加密固件的1756地址起，计算data1_len个字节的SHA512，也就是解密后固件大小的消息摘要，并保存到hash_buf</span></span><br><span class="line">                sub_400C84((<span class="type">int</span>)(IN_MEM + <span class="number">0x6dc</span>), data1_len, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                <span class="comment">// 比较原始固件从156地址起，64个字节大小，和hash_buf中的值进行比较，也就是和加密固件头中预保存的真实加密固件大小的消息摘要比较</span></span><br><span class="line">                <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x9c</span>, <span class="number">64</span>) )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">// AES对加密固件进行解密，并输出到OUT_MEM中</span></span><br><span class="line">                  <span class="comment">// 这个地方也可以看出从加密固件的1756地址起就是真正被加密的固件数据，前面都是一些头部信息</span></span><br><span class="line">                  <span class="comment">// 函数逻辑比较简单，就是AES加解密相关，从保存在固件头IN_MEM + 0xc获取解密密钥</span></span><br><span class="line">                  sub_40107C((<span class="type">int</span>)(IN_MEM + <span class="number">0x6dc</span>), data1_len, aes_key, IN_MEM + <span class="number">0xc</span>, OUT_MEM);</span><br><span class="line">                  <span class="comment">// 计算解密后固件的SHA_512消息摘要</span></span><br><span class="line">                  sub_400C84(OUT_MEM, data2_len, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                  <span class="comment">// 和存储在原始加密固件头，从92地址开始、64字节的SHA512进行比较</span></span><br><span class="line">                  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x5c</span>, <span class="number">64</span>) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="comment">// 获取解密固件+aes_key的SHA512</span></span><br><span class="line">                    sub_400D24(OUT_MEM, data2_len, aes_key, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                    <span class="comment">// 和存储在原始固件头，从28地址开始、64字节的SHA512进行比较</span></span><br><span class="line">                    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x1c</span>, <span class="number">64</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">// 使用当前文件系统内的公钥，通过RSA验证消息摘要和签名是否匹配</span></span><br><span class="line">                      <span class="keyword">if</span> ( sub_400E78((<span class="type">int</span>)(IN_MEM + <span class="number">0x5c</span>), <span class="number">64</span>, (<span class="type">int</span>)(IN_MEM + <span class="number">0x2dc</span>), <span class="number">0x200</span>) == <span class="number">1</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( sub_400E78((<span class="type">int</span>)(IN_MEM + <span class="number">0x9c</span>), <span class="number">64</span>, (<span class="type">int</span>)(IN_MEM + <span class="number">0x4dc</span>), <span class="number">0x200</span>) == <span class="number">1</span> )</span><br><span class="line">                          v5 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                          v5 = <span class="number">-1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        v5 = <span class="number">-1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="built_in">puts</span>(<span class="string">&quot;check sha512 vendor failed\r&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;check sha512 before failed %d %d\r\n&quot;</span>, data2_len, data1_len);</span><br><span class="line">                    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i )</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, (<span class="type">unsigned</span> __int8)hash_buf[i]);</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i )</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, *((<span class="type">unsigned</span> __int8 *)IN_MEM + i + <span class="number">92</span>));</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">puts</span>(<span class="string">&quot;check sha512 post failed\r&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no image matic found\r&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( MEM )</span><br><span class="line">    munmap(MEM, file_blocks);</span><br><span class="line">  <span class="keyword">if</span> ( OUT_MEM )</span><br><span class="line">    munmap(OUT_MEM, v9);</span><br><span class="line">  <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    close(image_fp);</span><br><span class="line">  <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    close(image_fp);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="概述DIR-3040的固件组成以及解密验证逻辑"><a href="#概述DIR-3040的固件组成以及解密验证逻辑" class="headerlink" title="概述DIR 3040的固件组成以及解密验证逻辑"></a>概述DIR 3040的固件组成以及解密验证逻辑</h3><p>从上面最关键的解密函数逻辑分析中，可以知道如果仅仅是解密相关，实际上只用到了AES解密，而且还是使用的硬编码密钥（通过了一些计算）。只是看上面的解密+验证逻辑分析，对整个流程可能还是会有点混乱，下面就说一下加密固件的文件结构和总结一下上面的解密+验证逻辑。</p>
<p>先直接给出加密固件文件结构的结论，只展现出重要的Header内容，大小1756字节，其后全部是真正的被加密固件数据。</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>长度（Bytes）</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>0：0x00</td>
<td>4</td>
<td>魔数：SHRS</td>
</tr>
<tr>
<td>4：0x4</td>
<td>4</td>
<td>解密固件的大小，带填充</td>
</tr>
<tr>
<td>8：0x8</td>
<td>4</td>
<td>解密固件的大小，不带填充</td>
</tr>
<tr>
<td>12：0xC</td>
<td>16</td>
<td>AES_128_CBC解密密钥</td>
</tr>
<tr>
<td>28：0x1C</td>
<td>64</td>
<td>解密后固件+KEY的SHA512消息摘要</td>
</tr>
<tr>
<td>92：0x5C</td>
<td>64</td>
<td>解密后固件的SHA512消息摘要</td>
</tr>
<tr>
<td>156：0x9C</td>
<td>64</td>
<td>加密固件的SHA512消息摘要</td>
</tr>
<tr>
<td>220：0xDC</td>
<td>512</td>
<td>未使用</td>
</tr>
<tr>
<td>732：0x2DC</td>
<td>512</td>
<td>解密后固件消息摘要的数字签名</td>
</tr>
<tr>
<td>1244：0x4DC</td>
<td>512</td>
<td>加密后固件消息摘要的数字签名</td>
</tr>
</tbody></table>
<p>结合上面的加密固件文件结构，再次概述一下解密逻辑：</p>
<ol>
<li><p>判断加密固件是否以Magic Number：SHRS开始。</p>
</li>
<li><p>判断（加密固件中存放的，真正被加密的固件数据大小的SHA512消息摘要），和，（去除Header之后，数据的SHA512消息摘要）。</p>
<p>这一步是通过验证固件的文件大小，判定是否有人篡改过固件，如果被篡改，解密失败。</p>
</li>
<li><p>读取保存在Header中的AES解密密钥，对加密固件数据进行解密</p>
</li>
<li><p>计算（解密后固件数据的SHA512消息摘要），和（预先保存在Header中的、解密后固件SHA512消息摘要）进行对比</p>
</li>
<li><p>计算（解密固件数据+解密密钥的、SHA512消息摘要），和（预先保存在Header中的、解密后固件数据+解密密钥的、SHA512消息摘要）进行对比</p>
</li>
<li><p>使用保存在当前文件系统中的RSA公钥，验证解密后固件的消息摘要和其签名是否匹配</p>
</li>
<li><p>使用保存在当前文件系统中的RSA公钥，验证加密后固件的消息摘要和其签名是否匹配</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章主要是以DIR 3040固件为例，说明如何从未加密的老固件中去寻找负责解密的可执行文件，用于解密新版的加密固件。先说明拿到一个固件后如何判断已经被加密，然后说明如何去找到负责解密的可执行文件，再通过qemu仿真去执行解密程序，将固件解密，最后简单说了下固件完整性相关的知识，并重点分析了解密程序的解密+验证逻辑。</p>
<p>这次对于DIR 3040的漏洞分析和固件解密验证过程分析还是花费了不少的时间。首先是固件的获取，从官网下载到的固件是加密的，然后看到一篇文章简单说了下基于未加密固件版本对加密固件进行解密，也是DIR 3040相关的。但是我在官网上没有找到未加密的固件，全部是被加密的固件。又在信息搜集的过程中，发现了原来在Github上有一个比较通用的、针对D-Link系列的<a target="_blank" rel="noopener" href="https://github.com/0xricksanchez/dlink-decrypt">固件解密脚本</a>。原来，Dlink近两年使用的加密、验证程序imgdecrypt基本上都是一个套路，于是我参考了解密脚本开发者在2020年的分析思路，结合之前看过的关于可信计算相关的一些知识点，简单叙述了固件安全性，然后重点分析了解密验证逻辑如上。</p>
<p>关于漏洞分析，感兴趣的师傅可以看一下我的这篇<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/07/23/D-Link%20DIR%203040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%88%B0RCE/">分析文章</a>。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943">Breaking the D-Link DIR3060 Firmware Encryption</a></li>
<li><a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/07/23/D-Link%20DIR%203040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%88%B0RCE/">D-Link DIR 3040从信息泄露到RCE</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">OneShell</p>
  <div class="site-description" itemprop="description">ToT</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OneShell</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
